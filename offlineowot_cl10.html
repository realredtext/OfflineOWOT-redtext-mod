<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Our World of Text</title>
		<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
		<link rel="shortcut icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAACxIAAAsSAdLdfvwAAAAHdElNRQfhCh4FGBfsuYX/AAAAGXRFWHRTb2Z0d2FyZQBwYWludC5uZXQgNC4wLjIx8SBplQAAAXFJREFUWEftkztOA0EQRH0O58Sk3MBkcAAyQgISchIkDkFMzik4BAE5l8CorHlyedQ9HyzYxCWVdmemuvtp1l4tru3351Yuy/+Xhj9fXy0HsTiA5BA9l5JUs/mdFATg6e6maW8eOcuXUbEUEAAQXx9vqesBtbN8CqGD9eZyFxiFiPz++hju4xSiBrg/u5gGYHgLYgqAWxhpPJLBIQQAahBBRI1mrL64eQsyg/XkU/yFy9hDcchwh9AN1Y726dGqaf4jJB3WAJgmvbXv15kugKRABEEzfVvW0V62lqdvoAfAma99n/fuD9GlwCiAm5xneapmGEBSKIKgma9HrBp5CkB2AJoc6yYEg2Wu7zcAfPPojL5l5F4MdQOwWZ9PQTiAg+g9BGD4y8PtgbWv4XgGwg2Qeh4NQLNZp8OlCIC1Q0QAytR77rpnCCABgb0QCD1plNnrMGfpcKRADeLF/p7Za+p8GdOXN4xcYqFm8yedtKBWqx9ASySa1Ve81QAAAABJRU5ErkJggg==">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
		<meta name="description" content="Offline OWOT">
		<style>
* {
	margin: 0;
	padding: 0;
}
html, body {
	overflow: hidden;
	width: 100%;
	height: 100%;
	overscroll-behavior: contain;
	touch-action: pan-down;
}
.announce_text {
	text-align: center;
	margin-right: 3px;
}
.screen_canvas {
	overflow: hidden;
}
body {
	background: #ccc;
}
img {
	border: 0;
	text-decoration: none;
}
a,
a:link,
a:hover,
a:active,
a:visited {
	text-decoration: none;
	color: inherit;
}
#topbar {
	position: absolute;
	top: 0;
	width: 100%;
}
#topbar_inner {
	width: 100%;
	position: absolute;
}
#announce_container {
	text-align: center;
}
.announce_close {
	font-size: 11px;
	font-weight: bold;
	color: #636060;
	background-color: #C5C2C2;
	border-radius: 2px;
	padding: 0 3px;
}
.announce_close:hover {
	background: #928E8E;
	color: white;
	cursor: pointer;
}
.ui {
	color: #888;
	font-family: Verdana;
	font-size: 12px;
	z-index: 100;
}
.ui-vis {
	background-color: rgba(0, 0, 255, .1);
	padding: 2px;
}
.tab {
	padding-top: 0;
	top: 0px;
	position: absolute;
}
.message {
	margin-left: auto;
	margin-right: auto;
	padding: 5px 0px;
	width: 60%;
	text-align: center;
	background: #E5E5FF;
	color: #333;
}
.message a {
	color: blue;
}
#loading {
	font-family: Verdana;
}
#coords {
	position: absolute;
	bottom: 0;
	right: 0;
	color: #555;
	background: #E5E5FF;
	cursor: pointer;
}
.menu {
	right: 0;
}
#menu {
	cursor: pointer;
}
#menu.hover {
	color: #555;
	background: #E5E5FF;
	border-left: 1px solid #ccc;
}
#nav {
	position: absolute;
	text-align: right;
	top: 1.5em;
	background: #E5E5FF;
	width: 8em;
	color: #555;
	border-left: 1px solid #ccc;
	border-bottom: 1px solid #ccc;
	overflow: hidden;
	max-height: 100%;
}
#nav li {
	display: block;
	list-style: none;
	position: relative;
	cursor: pointer;
	border-top: 1px solid #ccc;
}
#nav li:first-child {
	border-top: 0;
}
#nav a {
	display: block;
}
* html #nav ul {
	line-height: 0;
}
#nav li.hover {
	background-color: white;
}
#goto_submit {
	margin-left: 1em;
	margin-top: 3px;
}
#protect_precision {
	position: absolute;
	left: 0px;
	top: 30px;
	background-color: #626262;
	color: white;
	padding: 4px;
}
#protect_selection {
	display: block;
	text-decoration: underline;
	color: white;
	text-align: center;
	cursor: pointer;
}
#protect_selection:hover {
	color: #F3DB65;
}
#protect_selection:active {
	color: #917c17;
}
#char_choice {
	margin-left: 14px;
}
.protect_button {
	border: solid 1px white;
	text-align: center;
	cursor: pointer;
	min-width: 40px;
	display: inline-block;
}
.auto_prog_panel {
	position: absolute;
	left: 0px;
	top: 100px;
	width: 150px;
	height: 30px;
	background-color: rgb(104, 104, 104);
	text-align: center;
	color: white;
}
#chat_open {
	position: absolute;
	bottom: 0px;
	left: 0px;
	width: 70px;
	text-align: center;
	background-color: #003399;
	color: white;
	height: 20px;
	border-style: solid;
	border-width: 1px;
	border-color: #000033;
	cursor: default;
}
#chat_open:hover {
	background-color: #2763dc;
}
#chat_open:active {
	background-color: #0e2961;
}
#usr_online {
	padding-left: 16px;
	display: inline-block;
}
#chatsend {
	padding: 1px 6px 1px 6px;
}
.chat_tab_button {
	height: 20px;
	border: solid 1px black;
	text-align: center;
	font-family: Verdana;
	font-size: 13px;
	cursor: default;
	display: inline-flex;
	align-items: center;
	justify-content: center;
	margin-right: 3px;
}
.chat_tab_selected {
	background-color: #8C8C8C;
	color: white;
}
#chat_page_tab {
	width: 100px;
}
#chat_global_tab {
	width: 80px;
}
.chatfield {
	border: solid 1px black;
	background-color: white;
	overflow: scroll;
	overflow-x: hidden;
	overflow-wrap: break-word;
	margin: 3px;
	margin-bottom: 0px;
	height: 100%;
	padding: 2px;
}
.unread_bar {
	background-color: red;
	width: 100%;
	height: 2px;
	margin-top: 6px;
	margin-bottom: 6px;
	text-align: center;
}
.unread_bar_msg {
	background-color: white;
	position: relative;
	top: -8px;
	padding-left: 3px;
	padding-right: 3px;
	font-family: Verdana;
	font-size: 0.7em;
	color: red;
}
.unread {
	color: red;
	font-size: 11px;
}
#total_unread {
	font-size: 15px;
}
#chat_window {
	position: absolute;
	background-color: #e0e0e0;
	border: solid 1px black;
	display: flex;
	flex-flow: column;
}
#chat_close {
	background-color: red;
	width: 20px;
	height: 20px;
	text-align: center;
	color: white;
	border: solid 1px black;
	font-family: monospace;
	font-size: 16px;
	cursor: default;
	float: right;
}
#confirm_js {
	width: 441px;
	height: 256px;
	position: absolute;
	background-color: #dbdbdb;
	border-width: 2px;
	border-style: solid;
	border-color: black;
}
#confirm_js_code {
	background-color: #e6e6e6;
	position: absolute;
	width: 365px;
	height: 110px;
	top: 90px;
	left: 35px;
	padding: 3px;
	font-family: "Courier New", monospace;
	word-wrap: break-word;
	word-break: break-all;
	overflow: scroll;
	overflow-x: hidden;
}
#confirm_js_cancel {
	position: absolute;
	font-family: Helvetica;
	background-color: green;
	border-style: solid;
	width: 80px;
	height: 17px;
	top: 220px;
	left: 340px;
	border-width: 1px;
	padding: 2px;
	text-align: center;
	font-size: 15px;
	color: white;
	border-color: black;
	cursor: pointer;
}
#confirm_js_cancel_x {
	background-color: red;
	width: 20px;
	height: 20px;
	position: absolute;
	right: 3px;
	top: 2px;
	text-align: center;
	color: white;
	font-family: monospace;
	font-size: 16px;
	border-style: solid;
	border-width: 1px;
	border-color: black;
	cursor: pointer;
}
#confirm_js_msg {
	text-align: center;
	position: absolute;
	left: 20px;
	font-family: verdana;
	top: 40px;
}
#confirm_js_cancel:hover {
	background-color: #00AE00;
}
#run_js_confirm {
	position: absolute;
	color: blue;
	text-decoration: underline;
	top: 220px;
	left: 20px;
}
.region_selection {
	position: absolute;
	border: 1px solid black;
	pointer-events: none;
}
#area_results {
	width: 100%;
	height: 200px;
	white-space: pre;
	overflow: auto;
	overflow-x: scroll;
}
#link_element {
	position: absolute;
	display: block;
}
#owot {
	background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAAAAACMmsGiAAAAAklEQVR4AewaftIAAAAYSURBVAXBgQAAAADDoPsDRTWI14pFo6YcgrQNEaFuVVoAAAAASUVORK5CYII=");
	background-repeat: repeat;
}
#owot.nightmode {
	background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAEAQMAAACTPww9AAAABlBMVEVJSUkTExPF/tKBAAAAEElEQVQI12M4wDCBwYAhAQAJCAHhHe5F/AAAAABJRU5ErkJggg==");
}
#zoombar {
	width: 100%;
}
.color_btn {
	background-color: black;
	width: 16px;
	height: 16px;
	border-radius: 4px;
	border: solid 1px black;
	display: inline-block;
	font-weight: bold;
	font-family: verdana;
	text-align: center;
	cursor: default;
	font-size: 0.8em;
	overflow: hidden;
	margin: 3px;
	user-select: none;
	vertical-align: top;
}
.color_btn:hover {
	border-color: orange;
}
.color_btn:active {
	border-color: rgb(165, 107, 0);
}
.modal_corner_checkbox_label {
	margin-left: 5px;
	user-select: none;
}
#modal_overlay {
	position: absolute;
	top: 0px;
	left: 0px;
	width: 100%;
	height: 100%;
	cursor: default;
	background-color: rgba(0, 0, 0, 0.5);
	display: flex;
	justify-content: center;
	align-items: center;
	z-index: 1000;
}
.modal_close {
	position: absolute;
	right: 0px;
	bottom: 0px;
	margin-right: 8px;
	margin-bottom: 8px;
	color: blue;
	text-decoration: underline;
	cursor: pointer
}
.modal_frame {
	background-color: #C3C3FF;
}
.modal_client {
	background-color: #E5E5FF;
}
		</style>
		<style>
/* Force file picker to be hidden, but be interactable */
#import_world {
	cursor: pointer;
	position: absolute;
	top: 0;
	right: 0;
	opacity: 0;
	-moz-opacity: 0;
	filter: progid:DXImageTransform.Microsoft.Alpha(opacity=0);
}
		</style>
	</head>
	<body>
		<div id="main_view">
			<canvas id="owot" class="screen_canvas" style="display: none;"></canvas>
		</div>
		<a href="javascript: void 0;" id="link_element" title="Link to url..." target="_blank" style="cursor: pointer;">
			<div id="link_div"></div>
		</a>
		<div id="topbar" class="ui">
			<div id="topbar_inner">
				<div id="announce_container"></div>
				<span id="menu" class="ui-vis tab menu" style="display: none;">
					<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsAAAA7AAWrWiQkAAABWSURBVChTY2QAgtDQUBBFFGCC0kQDmmj4D6XBAKYBJOgHxPJoeB8QowCYp1FMwQLA6kCAZp4GuQCMidUAchIYU+QkfyBWQMP7gRgFEJM0QG6HhhIDAwBHgQ0nu8eENgAAAABJRU5ErkJggg==" class="menuPin" style="display: none;">
					<span class="menuText">Menu</span>
					<span style="font-size:50%">â–¼</span>
				</span>
			</div>
		</div>
		<div id="nav" class="ui menu ui-vis" style="display: none;">
			<ul></ul>
		</div>
		<div id="coords" class="ui ui-vis" style="display: none;">
			X: <span id="coord_X"></span>
			Y: <span id="coord_Y"></span>
			<div id="cursor_coords" style="display: none;">
				Cursor:
				<span id="cursor_on" style="display: none;">
					<span id="tile_X"></span>, <span id="tile_Y"></span> /
					<span id="char_X"></span>, <span id="char_Y"></span>
				</span>
				<span id="cursor_off" style="display: none">
					N/A
				</span>
			</div>
		</div>

		<div id="modal_overlay" style="display: none;"></div>

		<h1 id="loading">Loading...</h1>
		<div style="display:none"><input type="hidden" name="csrfmiddlewaretoken" value="abc123" /></div>
		<script>
			var state = {"userModel":{"username":"fp","is_superuser":true,"authenticated":true,"is_member":true,"is_owner":true,"is_staff":true,"is_operator":true},"worldModel":{"feature_membertiles_addremove":true,"writability":0,"feature_url_link":0,"feature_go_to_coord":0,"name":"","feature_paste":0,"readability":0,"feature_coord_link":0,"pathname":"","chat_permission":0,"color_text":0,"show_cursor":-1,"char_rate":[20480,1000],"write_interval":1000}};
		</script>

		<textarea autocapitalize="off" autocorrect="off" autocomplete="off" style="left: -1000px; top: -1000px; position: absolute;" id="textInput"></textarea>

		<div id="protect_precision" style="display: none;">
			<div style="padding-bottom: 3px;">
				Protect type:
			</div>
			<div class="protect_button" id="tile_choice" onclick="protectPrecisionOption(0);">
				Tile
			</div>
			<div class="protect_button" id="char_choice" onclick="protectPrecisionOption(1);">
				Char
			</div>
			<a id="protect_selection" onclick="protectSelection();">Select</a>
		</div>
		<div id="auto_prog" class="auto_prog_panel" style="display: none"></div>

		<div id="chat_open" style="display: none;">
			<span>Chat&nbsp;<b id="total_unread" class="unread" style="display: none;">(-)</b></span>
		</div>
		<div id="chat_window" style="width: 400px; height: 300px; bottom: 0px; left: 0px; display: none;">
			<div id="chat_upper" style="padding: 3px; padding-bottom: 0px;">
				<div class="chat_tab_button chat_tab_selected" id="chat_page_tab">
					This page&nbsp;<b id="page_unread" class="unread" style="display: none;">(-)</b>
				</div><div class="chat_tab_button" id="chat_global_tab">
					Global&nbsp;<b id="global_unread" class="unread" style="display: none;">(-)</b>
				</div>
				<span id="usr_online"></span>
				<div id="chat_close">X</div>
			</div>
			<div class="chatfield" id="page_chatfield"></div>
			<div class="chatfield" id="global_chatfield" style="display: none;"></div>
			<div id="chat_lower" style="width: 100%; display: flex;">
				<input style="width: 100%; margin: 3px; margin-right: 0px;" id="chatbar" autocomplete="off" aria-autocomplete="list">
				<button id="chatsend" style="margin: 3px;">Send</button>
			</div>
		</div>
		<div id="confirm_js" style="display: none; top: 50px; left: 100px;">
			<a href="javascript:void 0;" id="run_js_confirm">run</a>
			<span id="confirm_js_msg">
				Are you sure you want to run this javascript link?
				<br>
				Press Close to <i>not</i> run it.
			</span>
			<span id="confirm_js_code">
				--
			</span>
			<div id="confirm_js_cancel">
				Close
			</div>
			<div id="confirm_js_cancel_x">
				X
			</div>
		</div>

		<script>
/*
(MOD) = modified
(EXT) = extra script
*/
		
var start_time = Date.now();
var _time_ago = ["millisecond", "second", "minute", "hour", "day", "month", "year"];
function uptime(custom_ms_ago) {
	// (milliseconds ago)
	var difference = custom_ms_ago || (Date.now() - start_time);
	var milliseconds_ago = difference;
	var _data = _time_ago[0];
	var show_minutes = true; // EG: ... and 20 minutes
	var divided = 1;
	if(milliseconds_ago >= 30067200000) {
		_data = _time_ago[6];
		divided = 30067200000;
		milliseconds_ago = Math.floor(milliseconds_ago / divided);
	} else if(milliseconds_ago >= 2505600000) {
		_data = _time_ago[5];
		divided = 2505600000;
		milliseconds_ago = Math.floor(milliseconds_ago / divided);
	} else if(milliseconds_ago >= 86400000) {
		_data = _time_ago[4];
		divided = 86400000;
		milliseconds_ago = Math.floor(milliseconds_ago / divided);
	} else if(milliseconds_ago >= 3600000) {
		_data = _time_ago[3];
		divided = 3600000;
		milliseconds_ago = Math.floor(milliseconds_ago / divided);
	} else if(milliseconds_ago >= 60000) {
		_data = _time_ago[2];
		divided = 60000;
		show_minutes = false;
		milliseconds_ago = Math.floor(milliseconds_ago / divided);
	} else if(milliseconds_ago >= 1000) {
		_data = _time_ago[1];
		divided = 1000;
		show_minutes = false;
		milliseconds_ago = Math.floor(milliseconds_ago / divided);
	} else {
		show_minutes = false;
	}
	if(milliseconds_ago !== 1) {
		_data += "s";
	}
	var extra = "";
	if(show_minutes) {
		var t_difference = difference;
		t_difference -= divided;
		if(t_difference > 0) {
			t_difference %= divided;
			t_difference = Math.floor(t_difference / 60000);
			if(t_difference > 0) {
				extra = " and " + t_difference + " minute";
				if(t_difference != 1) extra += "s";
			}
		}
	}
	return milliseconds_ago + " " + _data + extra;
}
            
var tile_database = {};

function SimulatedServerSocket() {
	var self = this;
	this.cli_id = Math.floor(Math.random() * 10000);
	this.cli_channel = "";
	this.readyState = 0;
	for(var i = 0; i < 14; i++) {
		this.cli_channel += "0123456789abcdef"[Math.floor(Math.random() * 16)];
	}
	this.send = function(data) {
		setTimeout(function() {
			data = JSON.parse(data);
			if(data.kind == "ping") {
				self.onmessage({
					data: JSON.stringify({
						kind: "ping",
						result: "pong",
						id: data.id
					})
				});
			}
			if(data.kind == "fetch") {
				var fr = data.fetchRectangles;
				var resp = {
					kind: "fetch",
					tiles: {}
				};
				for(var i = 0; i < fr.length; i++) {
					var rect = fr[i];
					var x1 = rect.minX;
					var y1 = rect.minY;
					var x2 = rect.maxX;
					var y2 = rect.maxY;
					for(var y = y1; y <= y2; y++) {
						for(var x = x1; x <= x2; x++) {
							var tile = tile_database[y + "," + x];
							if(!tile) tile = null;
							resp.tiles[y + "," + x] = tile;
						}
					}
				}
				self.onmessage({
					data: JSON.stringify(resp)
				});
			}
			if(data.kind == "write") {
				var edits = data.edits;
				var editedTiles = {};
				var accepted = [];
				for(var i = 0; i < edits.length; i++) {
					var edit = edits[i];
					var tileY = edit[0];
					var tileX = edit[1];
					var charY = edit[2];
					var charX = edit[3];
					var time = edit[4];
					var char = edit[5];
					var id = edit[6];
					var color = edit[7];
					var tile = tile_database[tileY + "," + tileX];
					if(!tile) {
						tile_database[tileY + "," + tileX] = {
							content: " ".repeat(128),
							properties: {
								cell_props: {},
								writability: null
							}
						};
						tile = tile_database[tileY + "," + tileX];
					}
					if(tile.properties.cell_props[charY]) {
						if(tile.properties.cell_props[charY][charX]) {
							tile.properties.cell_props[charY][charX] = {};
						}
					}
					editedTiles[tileY + "," + tileX] = 1;
					var con = advancedSplit(tile.content);
					con[charY * 16 + charX] = char;
					tile.content = con.join("");
					if(color) {
						if(!tile.properties.color) {
							tile.properties.color = new Array(128).fill(0);
						}
						tile.properties.color[charY * 16 + charX] = color;
					}
					accepted.push(id);
				}
				var dataResp = {
					channel: self.cli_channel,
					kind: "tileUpdate",
					source: "write",
					tiles: {}
				};
				for(var i in editedTiles) {
					dataResp.tiles[i] = tile_database[i];
				}
				self.onmessage({
					data: JSON.stringify(dataResp)
				});
				self.onmessage({
					data: JSON.stringify({
						accepted: accepted,
						rejected: {},
						kind: "write"
					})
				});
			}
			if(data.kind == "link") {
				var ldata = data.data;
				var type = data.type;
				var tileX = ldata.tileX;
				var tileY = ldata.tileY;
				var charX = ldata.charX;
				var charY = ldata.charY;
				var url = ldata.url;
				var link_tileX = ldata.link_tileX;
				var link_tileY = ldata.link_tileY;
				var tile = tile_database[tileY + "," + tileX];
				if(!tile) {
					tile_database[tileY + "," + tileX] = {
						content: " ".repeat(128),
						properties: {
							cell_props: {},
							writability: null
						}
					};
					tile = tile_database[tileY + "," + tileX];
				}
				var cell_props = tile.properties.cell_props;
				if(!cell_props[charY]) {
					cell_props[charY] = {};
				}
				if(!cell_props[charY][charX]) {
					cell_props[charY][charX] = {};
				}
				cell_props[charY][charX] = {
					link: {
						type: type
					}
				};
				var lobj = cell_props[charY][charX].link;
				if(type == "url") {
					lobj.url = url;
				}
				if(type == "coord") {
					lobj.link_tileX = link_tileX;
					lobj.link_tileY = link_tileY;
				}
				self.onmessage({
					data: JSON.stringify({
						channel: self.cli_channel,
						kind: "tileUpdate",
						source: "write",
						tiles: {
							[tileY + "," + tileX]: tile
						}
					})
				});
			}
			if(data.kind == "protect") {
				var pdata = data.data;
				var action = data.action;
				var tileX = pdata.tileX;
				var tileY = pdata.tileY;
				var charX = pdata.charX;
				var charY = pdata.charY;
				var precise = pdata.precise;
				var type = pdata.type;
				var tile = tile_database[tileY + "," + tileX];
				if(!tile) {
					tile_database[tileY + "," + tileX] = {
						content: " ".repeat(128),
						properties: {
							cell_props: {},
							writability: null
						}
					};
					tile = tile_database[tileY + "," + tileX];
				}
				if(precise) {
					var pchardata = tile.properties.char;
					if(pchardata) {
						pchardata = decodeCharProt(pchardata);
					} else {
						pchardata = new Array(128).fill(null);
					}
					if(action == "protect") {
						var protVal = null;
						if(type == "owner-only") {
							protVal = 2;
						} else if(type == "member-only") {
							protVal = 1;
						} else if(type == "public") {
							protVal = 0;
						}
						pchardata[charY * 16 + charX] = protVal;
					} else if(action == "unprotect") {
						if(tile.properties.writability == null) {
							pchardata[charY * 16 + charX] = null;
						} else {
							for(var a = 0; a < pchardata.length; a++) {
								if(pchardata[a] == null) {
									pchardata[a] = tile.properties.writability;
								}
							}
							tile.properties.writability = null;
							pchardata[charY * 16 + charX] = null;
						}
					}
					tile.properties.char = encodeCharProt(pchardata);
				} else {
					delete tile.properties.char;
					if(action == "protect") {
                        let ownerPerms = state.userModel.is_owner || state.userModel.is_superuser;
                        let memberPerms = ownerPerms || (state.userModel.is_member || state.userModel.is_staff)
						if(type == "owner-only" && ownerPerms) {
							tile.properties.writability = 2;
						} else if(type == "member-only" && memberPerms) {
							tile.properties.writability = 1;
						} else if(type == "public") {
							tile.properties.writability = 0;
						}
					} else if(action == "unprotect") {
						tile.properties.writability = null;
					}
				}
				self.onmessage({
					data: JSON.stringify({
						channel: self.cli_channel,
						kind: "tileUpdate",
						source: "write",
						tiles: {
							[tileY + "," + tileX]: tile
						}
					})
				});
			}
			if(data.kind == "clear_tile") {
                var canClear = state.userModel.is_superuser || state.userModel.is_owner;
				var tileX = data.tileX;
				var tileY = data.tileY;
				var tile = tile_database[tileY + "," + tileX];
				if(!tile) return;
                if(tile.properties.writability !== -1) {
				    tile.content = " ".repeat(128);
				    tile.properties.cell_props = {};
                }
				self.onmessage({
					data: JSON.stringify({
						kind: "tileUpdate",
						source: "write",
						tiles: {
							[tileY + "," + tileX]: tile
						}
					})
				});
			}
            if(data.kind == "lock_tile") {
                const locData = {
                    ty: data.tileY,
                    tx: data.tileX
                };
                
                if(!tiles[`${locData.ty},${locData.tx}`]) return;
                var canLock = state.userModel.is_superuser || state.userModel.is_owner;
                if(!canLock) return;
                
                tiles[`${locData.ty},${locData.tx}`].properties.writability = -1;
                tiles[`${locData.ty},${locData.tx}`].backgroundColor = "#ccc";
                tiles[`${locData.ty},${locData.tx}`].properties.char = new Array(128).fill(-1);
                //couldnt lock tiles with locked chars in them without this mod
                renderTile(locData.tx, locData.ty, true);
                self.onmessage({
					data: JSON.stringify({
						kind: "tileUpdate",
						source: "write",
						tiles: {
							[tileY + "," + tileX]: tile
						}
					})
				});
            };
			if(data.kind == "chat") {
				var msg = data.message;
				if(msg == "/help") {
					self.onmessage({
						data: JSON.stringify({
							nickname: "[ Server ]",
							realUsername: "[ Server ]",
							id: 0,
							message: `Commands:<br>${Object.keys(client_commands).join("<br>")}`,
							registered: true,
							location: data.location,
							op: true,
							admin: true,
							staff: true,
							color: "",
							kind: "chat"
						})
					});
				} else {
					self.onmessage({
						data: JSON.stringify({
							nickname: data.nickname || YourWorld.Nickname,
							realUsername: data.realUsername || state.userModel.username,
							id: self.cli_id || data.id,
							message: data.message,
							registered: true,
							location: data.location,
							op: state.userModel.is_operator || data.op,
							admin: state.userModel.is_superuser || data.admin,
							staff: state.userModel.is_staff || data.staff,
							color: data.color,
							kind: "chat"
						})
					});
				}
			}
		}, 1);
	}
	this.close = function() {
		this.onclose();
	}
	setTimeout(function() {
		self.readyState = WebSocket.OPEN;
		self.onopen();
		self.onmessage({
			data: JSON.stringify({
				kind: "channel",
				sender: self.cli_channel,
				id: self.cli_id,
				initial_user_count: 1
			})
		});
	}, 1);
	return this;
}
		</script>
		<script>
if(!window.WebSocket && window.MozWebSocket) {
	window.WebSocket = window.MozWebSocket;
}

function assert(exp, optMsg) {
	if(!exp) {
		throw new Error(optMsg || "Assertion failed");
	}
}

function intmax(ints) {
	if(typeof ints == "number") ints = [ints];
	for(var i = 0; i < ints.length; i++)
		if(ints[i] > Number.MAX_SAFE_INTEGER || ints[i] < Number.MIN_SAFE_INTEGER) return false;
	return true;
}

function clipIntMax(x) {
	if(x < Number.MIN_SAFE_INTEGER) x = Number.MIN_SAFE_INTEGER;
	if(x > Number.MAX_SAFE_INTEGER) x = Number.MAX_SAFE_INTEGER;
	return x;
}

function closest(element, parElement) {
	var currentElm = element;
	while(currentElm) {
		if(currentElm == parElement) return true;
		currentElm = currentElm.parentNode;
	}
	return false;
}

function lineGen(x0, y0, x1, y1, max) {
	if(!max) max = 2000;
	var list = [];
	var x0 = Math.floor(x0);
	var y0 = Math.floor(y0);
	var x1 = Math.floor(x1);
	var y1 = Math.floor(y1);
	var dx = Math.abs(x1 - x0);
	var dy = Math.abs(y1 - y0);
	var sx = (x0 < x1) ? 1 : -1;
	var sy = (y0 < y1) ? 1 : -1;
	var err = dx - dy;
	for(var i = 0; i < max; i++) {
		list.push([x0, y0]);
		if((x0 == x1) && (y0 == y1)) break;
		var e2 = 2 * err;
		if(e2 > -dy) {
			err -= dy;
			x0 += sx;
		}
		if(e2 < dx) {
			err += dx;
			y0 += sy;
		}
	}
	return list;
}

function orderRangeABCoords(coordA, coordB) {
	var tmp;
	if(coordA[0] > coordB[0]) {
		// swap X coords
		tmp = coordA[0];
		coordA[0] = coordB[0];
		coordB[0] = tmp;
		tmp = coordA[2];
		coordA[2] = coordB[2];
		coordB[2] = tmp;
	} else if(coordA[0] == coordB[0] && coordA[2] > coordB[2]) {
		// swap X char coords
		tmp = coordA[2];
		coordA[2] = coordB[2];
		coordB[2] = tmp;
	}
	if(coordA[1] > coordB[1]) {
		// swap Y coords
		tmp = coordA[1];
		coordA[1] = coordB[1];
		coordB[1] = tmp;
		tmp = coordA[3];
		coordA[3] = coordB[3];
		coordB[3] = tmp;
	} else if(coordA[1] == coordB[1] && coordA[3] > coordB[3]) {
		// swap Y char coords
		tmp = coordA[3];
		coordA[3] = coordB[3];
		coordB[3] = tmp;
	}
}

function ajaxRequest(settings) {
	var req = new XMLHttpRequest();

	var formData = "";
	var ampAppend = false;
	if(settings.data) {
		for(var i in settings.data) {
			if(ampAppend) formData += "&";
			ampAppend = true;
			formData += encodeURIComponent(i) + "=" + encodeURIComponent(settings.data[i]);
		}
	}
	// append form data to url if this is a GET
	if(settings.type == "GET" && formData) {
		settings.url += "?" + formData;
	}
	var async = !!settings.async;
	req.open(settings.type, settings.url, !async);
	req.onload = function() {
		if(req.status >= 200 && req.status < 400) {
			if(settings.done) {
				settings.done(req.responseText, req);
			}
		} else {
			if(settings.error) {
				settings.error(req);
			}
		}
	}
	req.onerror = function() {
		if(settings.error) {
			settings.error(req);
		}
	}
	if(settings.type == "POST") {
		if(formData) req.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
		req.send(formData);
	} else {
		req.send();
	}
}

function removeAlpha(data) {
	var res = [];
	var len = data.length / 4;
	for(var i = 0; i < len; i++) {
		var indx = i * 4;
		res.push(data[indx + 0]);
		res.push(data[indx + 1]);
		res.push(data[indx + 2]);
	}
	return res;
}

function getRange(x1, y1, x2, y2) {
	var tmp;
	if(x1 > x2) {
		tmp = x1;
		x1 = x2;
		x2 = tmp;
	}
	if(y1 > y2) {
		tmp = y1;
		y1 = y2;
		y2 = tmp;
	}

	assert(intmax([x1, y1, x2, y2]), "Invalid ranges");

	var coords = [];
	for(var y = y1; y <= y2; y++) {
		for(var x = x1; x <= x2; x++) {
			coords.push([x, y]);
			if(coords.length >= 400000) throw "Potential memory leak";
		}
	}
	return coords;
}

var colors = ["#660066", "#003366", "#ff9900", "#ff0066", "#003300", "#ff0000", "#3a3a3a", "#006666", "#3399ff", "#3333ff", "#000000"];
function assignColor(username) {
	username = username.toUpperCase();
	var colLen = colors.length;
	var usrLen = username.length;
	var avg = 0;
	for(var i = 0; i < usrLen; i++) {
		var chr = username.charCodeAt(i);
		avg += (chr * chr | (i * chr) % 628) * (i << chr) + (chr*(i + 19 + (chr % 56))*chr);
	}
	return colors[(Math.abs(avg | 0)) % colLen];
}

function spaceTrim(str_array, left, right, gaps, secondary_array) {
	// secondary_array is an optional argument where elements are trimmed in parallel with str_array
	var marginLeft = 0;
	var marginRight = 0;
	var countL = left;
	var countR = right;
	var whitespaces = "\u0009\u000a\u000b\u000d\u0020\u0085\u00a0";
	for(var i = 0; i < str_array.length; i++) {
		var idxL = i;
		var idxR = str_array.length - 1 - i;
		if(whitespaces.indexOf(str_array[idxL]) > -1 && countL) {
			marginLeft++;
		} else {
			countL = false;
		}
		if(whitespaces.indexOf(str_array[idxR]) > -1 && countR) {
			marginRight++;
		} else {
			countR = false;
		}
		if(!countL && !countR) break;
	}
	if(marginLeft) {
		str_array.splice(0, marginLeft);
		spliceArray(secondary_array, 0, marginLeft);
	}
	if(marginRight) {
		str_array.splice(str_array.length - marginRight);
		spliceArray(secondary_array, secondary_array.length - marginRight);
	}
	if(gaps) {
		var spaceFreq = 0;
		for(var i = 0; i < str_array.length; i++) {
			var chr = str_array[i];
			if(whitespaces.indexOf(chr) > -1) {
				spaceFreq++;
			} else {
				spaceFreq = 0;
			}
			if(spaceFreq > 1) {
				str_array.splice(i, 1);
				spliceArray(secondary_array, i, 1);
				i--;
			}
		}
	}
	return str_array;
}

function spliceArray(array, A, B) {
	if(!array) return;
	if(Array.isArray(array)) {
		// list of arrays
		for(var i = 0; i < array.length; i++) {
			if(!array[i]) continue;
			array[i].splice(A, B);
		}
	} else {
		array.splice(A, B);
	}
}

function byId(a) {
	return document.getElementById(a);
}

function getDate() {
	return Date.now();
}

var keydownTable = {};
function keydownTableDown(e) {
	var key = e.key;
	if(!key) return;
	keydownTable[key] = 1;
}
function keydownTableUp(e) {
	var key = e.key;
	if(!key) return;
	if(keydownTable[key]) {
		delete keydownTable[key];
	}
}
document.addEventListener("keydown", keydownTableDown);
document.addEventListener("keyup", keydownTableUp);

// Element references
var elm = {};
function defineElements(list) {
	for(var el in list) {
		elm[el] = list[el];
	}
}

var keyCodeTbl = {
	"BACKSPACE":8, "TAB":9, "ENTER":13, "SHIFTRIGHT":16, "CONTROLLEFT":17, "CAPSLOCK":20, "ESCAPE":27, 
	"SPACE":32, "PAGEUP":33, "PAGEDOWN":34, "END":35, "HOME":36, "ARROWLEFT":37, "ARROWUP":38, "ARROWRIGHT":39, 
	"ARROWDOWN":40, "DELETE":46, "DIGIT0":48, "DIGIT1":49, "DIGIT2":50, "DIGIT3":51, "DIGIT4":52, "DIGIT5":53, 
	"DIGIT6":54, "DIGIT7":55, "DIGIT8":56, "DIGIT9":57, "KEYA":65, "KEYB":66, "KEYC":67, "KEYD":68, "KEYE":69, 
	"KEYF":70, "KEYG":71, "KEYH":72, "KEYI":73, "KEYJ":74, "KEYK":75, "KEYL":76, "KEYM":77, "KEYN":78, "KEYO":79, 
	"KEYP":80, "KEYQ":81, "KEYR":82, "KEYS":83, "KEYT":84, "KEYU":85, "KEYV":86, "KEYW":87, "KEYX":88, "KEYY":89, 
	"KEYZ":90, "CONTEXTMENU":93, "NUMPAD0":96, "NUMPAD1":97, "NUMPAD2":98, "NUMPAD3":99, "NUMPAD4":100, 
	"NUMPAD5":101, "NUMPAD6":102, "NUMPAD7":103, "NUMPAD8":104, "NUMPAD9":105, "NUMPADMULTIPLY":106, 
	"NUMPADADD":107, "NUMPADSUBTRACT":109, "NUMPADDECIMAL":110, "NUMPADDIVIDE":111, "F1":112, "F2":113, 
	"F3":114, "F4":115, "F5":116, "F6":117, "F7":118, "F8":119, "F9":120, "F10":121, "F11":122, "F12":123,
	"SEMICOLON":186, "COMMA":188, "MINUS":189, "PERIOD":190, "SLASH":191, "BACKQUOTE":192, "BRACKETLEFT":219,
	"BACKSLASH":220, "BRACKETRIGHT":221, "QUOTE":222
};

function getKeyCode(e) {
	if(e.keyCode != void 0) return e.keyCode;
	if(e.which != void 0) return e.which;
	if(e.code != void 0) return keyCodeTbl[e.code.toUpperCase()];
	return 0;
}

function escapeQuote(text) { // escapes " and ' and \
	return text.replace(/\\/g, "\\\\").replace(/\"/g, "\\\"").replace(/\'/g, "\\'");
}

function escapeURLQuote(url) {
	try {
		var decode = decodeURIComponent(url);
	} catch(e) {
		return "";
	}
	return encodeURIComponent(escapeQuote(decode));
}

function getPos(ref) {
	ref = ref.split(",");
	return [parseInt(ref[0]), parseInt(ref[1])];
}

function getPoolDimensions(tileWidth, tileHeight) {
	var sizeX = Math.floor(1024 / tileWidth);
	var sizeY = Math.floor(1024 / tileHeight);
	if(sizeX < 1) sizeX = 1;
	if(sizeY < 1) sizeY = 1;
	return [sizeX, sizeY];
}

function html_tag_esc(str, non_breaking_space, newline_br) {
	str += "";
	str = str.replace(/\&/g, "&amp;");
	str = str.replace(/\</g, "&lt;");
	str = str.replace(/\>/g, "&gt;");
	str = str.replace(/\0/g, " ");
	if(newline_br) {
		str = str.replace(/\r\n/g, "<br>");
		str = str.replace(/\n/g, "<br>");
		str = str.replace(/\r/g, "<br>");
	} else {
		str = str.replace(/\r/g, " ");
		str = str.replace(/\n/g, " ");
	}
	str = str.replace(/\"/g, "&quot;");
	str = str.replace(/\'/g, "&#39;");
	str = str.replace(/\`/g, "&#96;");
	str = str.replace(/\//g, "&#x2F;");
	str = str.replace(/\\/g, "&#x5C;");
	str = str.replace(/\=/g, "&#61;");
	if(non_breaking_space) str = str.replace(/\u0020/g, "&nbsp;");
	if(str.indexOf(">") > -1 || str.indexOf("<") > -1) return "";
	return str;
}

function isHexString(str) {
	if(!str.length) return false;
	for(var i = 0; i < str.length; i++) {
		var chr = str[i];
		var isHex = ("a" <= chr && chr <= "f") || ("A" <= chr && chr <= "F") || ("0" <= chr && chr <= "9");
		if(!isHex) return false;
	}
	return true;
}

function convertToDate(epoch) {
	var months = [
		"January", "February", "March",
		"April", "May", "June",
		"July", "August", "September",
		"October", "November", "December"
	];
	var str = "";
	var date = new Date(epoch);
	var month = date.getMonth();
	var day = date.getDate();
	var year = date.getFullYear();
	var hour = date.getHours();
	var minute = date.getMinutes();
	str += year + " " + months[month] + " " + day + " ";
	var per = "AM";
	if(hour >= 12) {
		per = "PM";
	}
	if(hour > 12) {
		hour = hour - 12;
	}
	if(hour == 0) {
		hour = 12;
	}
	str += hour + ":" + ("0" + minute).slice(-2) + " " + per;
	return str;
}

function int_to_rgb(value) {
	var r = (value >> 16) & 255;
	var g = (value >> 8) & 255;
	var b = value & 255;
	return [r, g, b];
}

function int_to_hexcode(value) {
	return "#" + value.toString(16).padStart(6, 0);
}

function rgb_to_int(r, g, b) {
	return b | g << 8 | r << 16;
}

function easeOutQuad(h, f, j, i) {
	return -j * (h /= i) * (h - 2) + f;
}

if(!Math.trunc) {
	Math.trunc = function(v) {
		v = +v;
		return (v - v % 1) || (!isFinite(v) || v === 0 ? v : v < 0 ? -0 : 0);
	}
}

if(!Object.assign) {
	Object.assign = function(target, vars) {
		for(var i in vars) {
			target[i] = vars[i];
		}
		return target;
	}
}

if(!Array.prototype.fill) {
	Array.prototype.fill = function(val) {
		var ar = this;
		for(var i = 0; i < ar.length; i++) {
			ar[i] = val;
		}
		return ar;
	}
}

if(!String.prototype.startsWith) {
	String.prototype.startsWith = function(search, pos) {
		return this.substr(!pos || pos < 0 ? 0 : +pos, search.length) == search;
	}
}

if(!String.prototype.codePointAt) {
	String.prototype.codePointAt = function() {
		return this[0].charCodeAt();
	}
}

if(!String.prototype.repeat) {
	String.prototype.repeat = function(count) {
		if(count < 0) throw "Range error";
		var res = "";
		for(var i = 0; i < count; i++) {
			res += this;
		}
		return res;
	}
}

if(!String.prototype.padStart) {
	String.prototype.padStart = function(count, fillStr) {
		fillStr += "";
		return (fillStr.repeat(count) + this).slice(-count);
	}
}

if(!Math.log2) {
	Math.log2 = function(x) {
		return Math.log(x) * Math.LOG2E;
	}
}

function CircularBuffer(maxLen) {
	this.len = maxLen;
	this.buffer = [];
	this.pos = 0;
	this.elms = 0;
	return this;
}

CircularBuffer.prototype.push = function(data) {
	if(data === undefined) throw "Element cannot be undefined";
	if(this.pos >= this.buffer.length) {
		this.buffer.push(data);
		this.elms++;
		this.pos++;
		if(this.pos >= this.len) this.pos = 0;
		return;
	}
	this.buffer[this.pos] = data;
	this.elms++;
	if(this.elms > this.len) this.elms = this.len;
	this.pos++;
	if(this.pos >= this.len) this.pos = 0;
}

CircularBuffer.prototype.pop = function() {
	if(!this.buffer.length) return;
	if(!this.elms) return;
	this.pos--;
	if(this.pos < 0) this.pos = this.len - 1;
	var res = this.buffer[this.pos];
	this.elms--;
	return res;
}

CircularBuffer.prototype.unpop = function() {
	if(!this.buffer.length) return;
	if(this.elms >= this.buffer.length) return;
	var res = this.buffer[this.pos];
	if(res === undefined) return;
	this.pos++;
	if(this.pos >= this.len) this.pos = 0;
	this.elms++;
	return res;
}

CircularBuffer.prototype.trim = function() {
	var tmpPos = this.pos;
	for(var i = this.elms; i < this.buffer.length; i++) {
		if(tmpPos >= this.buffer.length) tmpPos = 0;
		if(this.buffer[tmpPos] === undefined) return;
		this.buffer[tmpPos] = undefined;
		tmpPos++;
	}
}

CircularBuffer.prototype.unwind = function() {
	var res = [];
	var tmpPos = this.pos - this.elms;
	if(tmpPos < 0) tmpPos += this.buffer.length;
	for(var i = 0; i < this.elms; i++) {
		if(tmpPos >= this.buffer.length) tmpPos = 0;
		var elm = this.buffer[tmpPos];
		if(elm === undefined) break;
		res.push(elm);
		tmpPos++;
	}
	return res;
}

function getBasicHostname(host) {
	var host = host.toLowerCase().split(".");
	if(host[0] == "www") host.shift();
	return host.join(".");
}

function isSafeHostname(host) {
	return safeLinkHosts.includes(host);
}

var safeLinkHosts = [
	getBasicHostname(window.location.host),
	"yourworldoftext.com",
	"ourworldofpixels.com",
	"ourworldoftext.com",
	"dir.ourworldoftext.com",
	"testserver1.ourworldoftext.com",
	"spooks.me",
	"youtube.com",
	"discord.com",
	"discord.gg",
	"discordapp.com",
	"reddit.com",
	"old.reddit.com"
];

// compatibility (deprecated)
var blankColor = new Array(128).fill(0);

if(state.worldModel.nsfw) {
	var check = localStorage.getItem("nsfw_yes");
	if(check) {
		check = JSON.parse(check);
		if(!check[state.worldModel.name.toUpperCase()]) {
			window.location.pathname = "/accounts/nsfw/" + state.worldModel.name;
		}
	} else {
		window.location.pathname = "/accounts/nsfw/" + state.worldModel.name;
	}
}

function ReconnectingWebSocket(url) {
	this.binaryType = "blob";
	this.onopen = null;
	this.onclose = null;
	this.onmessage = null;
	this.onerror = null;
	this.reconnectTimeout = 1000;
	var closed = false;
	var self = this;
	function connect() {
		self.socket = new SimulatedServerSocket(url); // (MOD)
		self.socket.onclose = function(r) {
			if(self.onclose) self.onclose(r);
			if(closed) return;
			setTimeout(connect, self.reconnectTimeout);
		}
		self.socket.onopen = function(e) {
			self.socket.binaryType = self.binaryType;
			if(self.onopen) self.onopen(e);
		}
		self.socket.onmessage = function(m) {
			if(self.onmessage) self.onmessage(m);
		}
		self.socket.onerror = function(m) {
			if(self.onerror) self.onerror(m);
		}
	}
	connect();
	this.send = function(data) {
		this.socket.send(data);
	}
	this.close = function() {
		closed = true;
		this.socket.close();
	}
	this.refresh = function() {
		this.socket.close();
	}
	return this;
}

// split a mixed string with surrogates and combining characters
function advancedSplit(str, noSurrog, noComb, norm) {
	if(str && str.constructor == Array) return str.slice(0);
	var chars = [];
	var buffer = "";
	var surrogMode = false;
	var charMode = false;
	var combCount = 0;
	var combLimit = 15;
	for(var i = 0; i < str.length; i++) {
		var char = str[i];
		var code = char.charCodeAt();
		if(code >= 0xDC00 && code <= 0xDFFF) {
			if(surrogMode) {
				buffer += char;
			} else {
				buffer = "";
				chars.push("?");
			}
			surrogMode = false;
			continue;
		} else if(surrogMode) {
			buffer = "";
			chars.push("?");
			surrogMode = false;
			continue;
		}
		if(!noSurrog && code >= 0xD800 && code <= 0xDBFF) {
			if(charMode) {
				chars.push(buffer);
			}
			charMode = true;
			surrogMode = true;
			buffer = char;
			continue;
		}
		if(!norm && ((code >= 0x0300 && code <= 0x036F) ||
		  (code >= 0x1DC0 && code <= 0x1DFF) ||
		  (code >= 0x20D0 && code <= 0x20FF) ||
		  (code >= 0xFE20 && code <= 0xFE2F))) {
			if(!noComb && charMode && combCount < combLimit) {
				buffer += char;
				combCount++;
			}
			continue;
		} else {
			if(charMode) {
				chars.push(buffer);
			}
			combCount = 0;
			charMode = true;
			buffer = char;
		}
	}
	if(buffer) {
		chars.push(buffer);
	}
	return chars;
}

var w = {
	loadScript: function(url, callback) {
		var script = document.createElement("script");
		if(callback === true) {
			// synchronous
			ajaxRequest({
				type: "GET",
				url: url,
				async: true,
				done: function(e) {
					script.innerText = e;
					document.head.appendChild(script);
				}
			});
		} else {
			script.src = url;
			document.head.appendChild(script);
			script.onload = callback;
		}
	},
	clipboard: {
		textarea: null,
		init: function() {
			var area = document.createElement("textarea");
			area.value = "";
			area.id = "textCopy";
			area.style.width = "1px";
			area.style.height = "1px";
			area.style.position = "absolute";
			area.style.left = "-1000px";
			area.style.top = "-1000px";
			document.body.appendChild(area);
			w.clipboard.textarea = area;
		},
		copy: function(string) {
			w.clipboard.textarea.value = string;
			w.clipboard.textarea.select();
			document.execCommand("copy");
			w.clipboard.textarea.value = "";
		}
	},
	events: {
        chatmod: []
    },
	on: function(type, call) {
		if(typeof call != "function") {
			throw "Callback is not a function";
		}
		type = type.toLowerCase();
		if(!OWOT.events[type]) {
			OWOT.events[type] = [];
		}
		OWOT.events[type].push(call);
	},
	off: function(type, call) {
		type = type.toLowerCase();
		if(!OWOT.events[type]) return;
		while(true) {
			var idx = OWOT.events[type].indexOf(call);
			if(idx == -1) break;
			OWOT.events[type].splice(idx, 1);
		}
	},
	emit: function(type, data) {
		type = type.toLowerCase();
		var evt = OWOT.events[type];
		if(!evt) return;
		for(var e = 0; e < evt.length; e++) {
			var func = evt[e];
			func(data);
		}
	},
	listening: function(type) {
		type = type.toLowerCase();
		return !!OWOT.events[type];
	},
	split: advancedSplit
};

var OWOT = w;
w.clipboard.init();
		</script>
		<script>
/**
 * jscolor - JavaScript Color Picker
 *
 * @link    http://jscolor.com
 * @license For open source use: GPLv3
 *          For commercial use: JSColor Commercial License
 * @author  Jan Odvarko
 *
 * See usage examples at http://jscolor.com/examples/
 */"use strict";window.jscolor||(window.jscolor=function(){var e={register:function(){e.attachDOMReadyEvent(e.init),e.attachEvent(document,"mousedown",e.onDocumentMouseDown),e.attachEvent(document,"touchstart",e.onDocumentTouchStart),e.attachEvent(window,"resize",e.onWindowResize)},init:function(){e.jscolor.lookupClass&&e.jscolor.installByClassName(e.jscolor.lookupClass)},tryInstallOnElements:function(t,n){var r=new RegExp("(^|\\s)("+n+")(\\s*(\\{[^}]*\\})|\\s|$)","i");for(var i=0;i<t.length;i+=1){if(t[i].type!==undefined&&t[i].type.toLowerCase()=="color"&&e.isColorAttrSupported)continue;var s;if(!t[i].jscolor&&t[i].className&&(s=t[i].className.match(r))){var o=t[i],u=null,a=e.getDataAttr(o,"jscolor");a!==null?u=a:s[4]&&(u=s[4]);var f={};if(u)try{f=(new Function("return ("+u+")"))()}catch(l){e.warn("Error parsing jscolor options: "+l+":\n"+u)}o.jscolor=new e.jscolor(o,f)}}},isColorAttrSupported:function(){var e=document.createElement("input");if(e.setAttribute){e.setAttribute("type","color");if(e.type.toLowerCase()=="color")return!0}return!1}(),isCanvasSupported:function(){var e=document.createElement("canvas");return!!e.getContext&&!!e.getContext("2d")}(),fetchElement:function(e){return typeof e=="string"?document.getElementById(e):e},isElementType:function(e,t){return e.nodeName.toLowerCase()===t.toLowerCase()},getDataAttr:function(e,t){var n="data-"+t,r=e.getAttribute(n);return r!==null?r:null},attachEvent:function(e,t,n){e.addEventListener?e.addEventListener(t,n,!1):e.attachEvent&&e.attachEvent("on"+t,n)},detachEvent:function(e,t,n){e.removeEventListener?e.removeEventListener(t,n,!1):e.detachEvent&&e.detachEvent("on"+t,n)},_attachedGroupEvents:{},attachGroupEvent:function(t,n,r,i){e._attachedGroupEvents.hasOwnProperty(t)||(e._attachedGroupEvents[t]=[]),e._attachedGroupEvents[t].push([n,r,i]),e.attachEvent(n,r,i)},detachGroupEvents:function(t){if(e._attachedGroupEvents.hasOwnProperty(t)){for(var n=0;n<e._attachedGroupEvents[t].length;n+=1){var r=e._attachedGroupEvents[t][n];e.detachEvent(r[0],r[1],r[2])}delete e._attachedGroupEvents[t]}},attachDOMReadyEvent:function(e){var t=!1,n=function(){t||(t=!0,e())};if(document.readyState==="complete"){setTimeout(n,1);return}if(document.addEventListener)document.addEventListener("DOMContentLoaded",n,!1),window.addEventListener("load",n,!1);else if(document.attachEvent){document.attachEvent("onreadystatechange",function(){document.readyState==="complete"&&(document.detachEvent("onreadystatechange",arguments.callee),n())}),window.attachEvent("onload",n);if(document.documentElement.doScroll&&window==window.top){var r=function(){if(!document.body)return;try{document.documentElement.doScroll("left"),n()}catch(e){setTimeout(r,1)}};r()}}},warn:function(e){window.console&&window.console.warn&&window.console.warn(e)},preventDefault:function(e){e.preventDefault&&e.preventDefault(),e.returnValue=!1},captureTarget:function(t){t.setCapture&&(e._capturedTarget=t,e._capturedTarget.setCapture())},releaseTarget:function(){e._capturedTarget&&(e._capturedTarget.releaseCapture(),e._capturedTarget=null)},fireEvent:function(e,t){if(!e)return;if(document.createEvent){var n=document.createEvent("HTMLEvents");n.initEvent(t,!0,!0),e.dispatchEvent(n)}else if(document.createEventObject){var n=document.createEventObject();e.fireEvent("on"+t,n)}else e["on"+t]&&e["on"+t]()},classNameToList:function(e){return e.replace(/^\s+|\s+$/g,"").split(/\s+/)},hasClass:function(e,t){return t?-1!=(" "+e.className.replace(/\s+/g," ")+" ").indexOf(" "+t+" "):!1},setClass:function(t,n){var r=e.classNameToList(n);for(var i=0;i<r.length;i+=1)e.hasClass(t,r[i])||(t.className+=(t.className?" ":"")+r[i])},unsetClass:function(t,n){var r=e.classNameToList(n);for(var i=0;i<r.length;i+=1){var s=new RegExp("^\\s*"+r[i]+"\\s*|"+"\\s*"+r[i]+"\\s*$|"+"\\s+"+r[i]+"(\\s+)","g");t.className=t.className.replace(s,"$1")}},getStyle:function(e){return window.getComputedStyle?window.getComputedStyle(e):e.currentStyle},setStyle:function(){var e=document.createElement("div"),t=function(t){for(var n=0;n<t.length;n+=1)if(t[n]in e.style)return t[n]},n={borderRadius:t(["borderRadius","MozBorderRadius","webkitBorderRadius"]),boxShadow:t(["boxShadow","MozBoxShadow","webkitBoxShadow"])};return function(e,t,r){switch(t.toLowerCase()){case"opacity":var i=Math.round(parseFloat(r)*100);e.style.opacity=r,e.style.filter="alpha(opacity="+i+")";break;default:e.style[n[t]]=r}}}(),setBorderRadius:function(t,n){e.setStyle(t,"borderRadius",n||"0")},setBoxShadow:function(t,n){e.setStyle(t,"boxShadow",n||"none")},getElementPos:function(t,n){var r=0,i=0,s=t.getBoundingClientRect();r=s.left,i=s.top;if(!n){var o=e.getViewPos();r+=o[0],i+=o[1]}return[r,i]},getElementSize:function(e){return[e.offsetWidth,e.offsetHeight]},getAbsPointerPos:function(e){e||(e=window.event);var t=0,n=0;return typeof e.changedTouches!="undefined"&&e.changedTouches.length?(t=e.changedTouches[0].clientX,n=e.changedTouches[0].clientY):typeof e.clientX=="number"&&(t=e.clientX,n=e.clientY),{x:t,y:n}},getRelPointerPos:function(e){e||(e=window.event);var t=e.target||e.srcElement,n=t.getBoundingClientRect(),r=0,i=0,s=0,o=0;return typeof e.changedTouches!="undefined"&&e.changedTouches.length?(s=e.changedTouches[0].clientX,o=e.changedTouches[0].clientY):typeof e.clientX=="number"&&(s=e.clientX,o=e.clientY),r=s-n.left,i=o-n.top,{x:r,y:i}},getViewPos:function(){var e=document.documentElement;return[(window.pageXOffset||e.scrollLeft)-(e.clientLeft||0),(window.pageYOffset||e.scrollTop)-(e.clientTop||0)]},getViewSize:function(){var e=document.documentElement;return[window.innerWidth||e.clientWidth,window.innerHeight||e.clientHeight]},redrawPosition:function(){if(e.picker&&e.picker.owner){var t=e.picker.owner,n,r;t.fixed?(n=e.getElementPos(t.targetElement,!0),r=[0,0]):(n=e.getElementPos(t.targetElement),r=e.getViewPos());var i=e.getElementSize(t.targetElement),s=e.getViewSize(),o=e.getPickerOuterDims(t),u,a,f;switch(t.position.toLowerCase()){case"left":u=1,a=0,f=-1;break;case"right":u=1,a=0,f=1;break;case"top":u=0,a=1,f=-1;break;default:u=0,a=1,f=1}var l=(i[a]+o[a])/2;if(!t.smartPosition)var c=[n[u],n[a]+i[a]-l+l*f];else var c=[-r[u]+n[u]+o[u]>s[u]?-r[u]+n[u]+i[u]/2>s[u]/2&&n[u]+i[u]-o[u]>=0?n[u]+i[u]-o[u]:n[u]:n[u],-r[a]+n[a]+i[a]+o[a]-l+l*f>s[a]?-r[a]+n[a]+i[a]/2>s[a]/2&&n[a]+i[a]-l-l*f>=0?n[a]+i[a]-l-l*f:n[a]+i[a]-l+l*f:n[a]+i[a]-l+l*f>=0?n[a]+i[a]-l+l*f:n[a]+i[a]-l-l*f];var h=c[u],p=c[a],d=t.fixed?"fixed":"absolute",v=(c[0]+o[0]>n[0]||c[0]<n[0]+i[0])&&c[1]+o[1]<n[1]+i[1];e._drawPosition(t,h,p,d,v)}},_drawPosition:function(t,n,r,i,s){var o=s?0:t.shadowBlur;e.picker.wrap.style.position=i,e.picker.wrap.style.left=n+"px",e.picker.wrap.style.top=r+"px",e.setBoxShadow(e.picker.boxS,t.shadow?new e.BoxShadow(0,o,t.shadowBlur,0,t.shadowColor):null)},getPickerDims:function(t){var n=!!e.getSliderComponent(t),r=[2*t.insetWidth+2*t.padding+t.width+(n?2*t.insetWidth+e.getPadToSliderPadding(t)+t.sliderSize:0),2*t.insetWidth+2*t.padding+t.height+(t.closable?2*t.insetWidth+t.padding+t.buttonHeight:0)];return r},getPickerOuterDims:function(t){var n=e.getPickerDims(t);return[n[0]+2*t.borderWidth,n[1]+2*t.borderWidth]},getPadToSliderPadding:function(e){return Math.max(e.padding,1.5*(2*e.pointerBorderWidth+e.pointerThickness))},getPadYComponent:function(e){switch(e.mode.charAt(1).toLowerCase()){case"v":return"v"}return"s"},getSliderComponent:function(e){if(e.mode.length>2)switch(e.mode.charAt(2).toLowerCase()){case"s":return"s";case"v":return"v"}return null},onDocumentMouseDown:function(t){t||(t=window.event);var n=t.target||t.srcElement;n._jscLinkedInstance?n._jscLinkedInstance.showOnClick&&n._jscLinkedInstance.show():n._jscControlName?e.onControlPointerStart(t,n,n._jscControlName,"mouse"):e.picker&&e.picker.owner&&e.picker.owner.hide()},onDocumentTouchStart:function(t){t||(t=window.event);var n=t.target||t.srcElement;n._jscLinkedInstance?n._jscLinkedInstance.showOnClick&&n._jscLinkedInstance.show():n._jscControlName?e.onControlPointerStart(t,n,n._jscControlName,"touch"):e.picker&&e.picker.owner&&e.picker.owner.hide()},onWindowResize:function(t){e.redrawPosition()},onParentScroll:function(t){e.picker&&e.picker.owner&&e.picker.owner.hide()},_pointerMoveEvent:{mouse:"mousemove",touch:"touchmove"},_pointerEndEvent:{mouse:"mouseup",touch:"touchend"},_pointerOrigin:null,_capturedTarget:null,onControlPointerStart:function(t,n,r,i){var s=n._jscInstance;e.preventDefault(t),e.captureTarget(n);var o=function(s,o){e.attachGroupEvent("drag",s,e._pointerMoveEvent[i],e.onDocumentPointerMove(t,n,r,i,o)),e.attachGroupEvent("drag",s,e._pointerEndEvent[i],e.onDocumentPointerEnd(t,n,r,i))};o(document,[0,0]);if(window.parent&&window.frameElement){var u=window.frameElement.getBoundingClientRect(),a=[-u.left,-u.top];o(window.parent.window.document,a)}var f=e.getAbsPointerPos(t),l=e.getRelPointerPos(t);e._pointerOrigin={x:f.x-l.x,y:f.y-l.y};switch(r){case"pad":switch(e.getSliderComponent(s)){case"s":s.hsv[1]===0&&s.fromHSV(null,100,null);break;case"v":s.hsv[2]===0&&s.fromHSV(null,null,100)}e.setPad(s,t,0,0);break;case"sld":e.setSld(s,t,0)}e.dispatchFineChange(s)},onDocumentPointerMove:function(t,n,r,i,s){return function(t){var i=n._jscInstance;switch(r){case"pad":t||(t=window.event),e.setPad(i,t,s[0],s[1]),e.dispatchFineChange(i);break;case"sld":t||(t=window.event),e.setSld(i,t,s[1]),e.dispatchFineChange(i)}}},onDocumentPointerEnd:function(t,n,r,i){return function(t){var r=n._jscInstance;e.detachGroupEvents("drag"),e.releaseTarget(),e.dispatchChange(r)}},dispatchChange:function(t){t.valueElement&&e.isElementType(t.valueElement,"input")&&e.fireEvent(t.valueElement,"change")},dispatchFineChange:function(e){if(e.onFineChange){var t;typeof e.onFineChange=="string"?t=new Function(e.onFineChange):t=e.onFineChange,t.call(e)}},setPad:function(t,n,r,i){var s=e.getAbsPointerPos(n),o=r+s.x-e._pointerOrigin.x-t.padding-t.insetWidth,u=i+s.y-e._pointerOrigin.y-t.padding-t.insetWidth,a=o*(360/(t.width-1)),f=100-u*(100/(t.height-1));switch(e.getPadYComponent(t)){case"s":t.fromHSV(a,f,null,e.leaveSld);break;case"v":t.fromHSV(a,null,f,e.leaveSld)}},setSld:function(t,n,r){var i=e.getAbsPointerPos(n),s=r+i.y-e._pointerOrigin.y-t.padding-t.insetWidth,o=100-s*(100/(t.height-1));switch(e.getSliderComponent(t)){case"s":t.fromHSV(null,o,null,e.leavePad);break;case"v":t.fromHSV(null,null,o,e.leavePad)}},_vmlNS:"jsc_vml_",_vmlCSS:"jsc_vml_css_",_vmlReady:!1,initVML:function(){if(!e._vmlReady){var t=document;t.namespaces[e._vmlNS]||t.namespaces.add(e._vmlNS,"urn:schemas-microsoft-com:vml");if(!t.styleSheets[e._vmlCSS]){var n=["shape","shapetype","group","background","path","formulas","handles","fill","stroke","shadow","textbox","textpath","imagedata","line","polyline","curve","rect","roundrect","oval","arc","image"],r=t.createStyleSheet();r.owningElement.id=e._vmlCSS;for(var i=0;i<n.length;i+=1)r.addRule(e._vmlNS+"\\:"+n[i],"behavior:url(#default#VML);")}e._vmlReady=!0}},createPalette:function(){var t={elm:null,draw:null};if(e.isCanvasSupported){var n=document.createElement("canvas"),r=n.getContext("2d"),i=function(e,t,i){n.width=e,n.height=t,r.clearRect(0,0,n.width,n.height);var s=r.createLinearGradient(0,0,n.width,0);s.addColorStop(0,"#F00"),s.addColorStop(1/6,"#FF0"),s.addColorStop(2/6,"#0F0"),s.addColorStop(.5,"#0FF"),s.addColorStop(4/6,"#00F"),s.addColorStop(5/6,"#F0F"),s.addColorStop(1,"#F00"),r.fillStyle=s,r.fillRect(0,0,n.width,n.height);var o=r.createLinearGradient(0,0,0,n.height);switch(i.toLowerCase()){case"s":o.addColorStop(0,"rgba(255,255,255,0)"),o.addColorStop(1,"rgba(255,255,255,1)");break;case"v":o.addColorStop(0,"rgba(0,0,0,0)"),o.addColorStop(1,"rgba(0,0,0,1)")}r.fillStyle=o,r.fillRect(0,0,n.width,n.height)};t.elm=n,t.draw=i}else{e.initVML();var s=document.createElement("div");s.style.position="relative",s.style.overflow="hidden";var o=document.createElement(e._vmlNS+":fill");o.type="gradient",o.method="linear",o.angle="90",o.colors="16.67% #F0F, 33.33% #00F, 50% #0FF, 66.67% #0F0, 83.33% #FF0";var u=document.createElement(e._vmlNS+":rect");u.style.position="absolute",u.style.left="-1px",u.style.top="-1px",u.stroked=!1,u.appendChild(o),s.appendChild(u);var a=document.createElement(e._vmlNS+":fill");a.type="gradient",a.method="linear",a.angle="180",a.opacity="0";var f=document.createElement(e._vmlNS+":rect");f.style.position="absolute",f.style.left="-1px",f.style.top="-1px",f.stroked=!1,f.appendChild(a),s.appendChild(f);var i=function(e,t,n){s.style.width=e+"px",s.style.height=t+"px",u.style.width=f.style.width=e+1+"px",u.style.height=f.style.height=t+1+"px",o.color="#F00",o.color2="#F00";switch(n.toLowerCase()){case"s":a.color=a.color2="#FFF";break;case"v":a.color=a.color2="#000"}};t.elm=s,t.draw=i}return t},createSliderGradient:function(){var t={elm:null,draw:null};if(e.isCanvasSupported){var n=document.createElement("canvas"),r=n.getContext("2d"),i=function(e,t,i,s){n.width=e,n.height=t,r.clearRect(0,0,n.width,n.height);var o=r.createLinearGradient(0,0,0,n.height);o.addColorStop(0,i),o.addColorStop(1,s),r.fillStyle=o,r.fillRect(0,0,n.width,n.height)};t.elm=n,t.draw=i}else{e.initVML();var s=document.createElement("div");s.style.position="relative",s.style.overflow="hidden";var o=document.createElement(e._vmlNS+":fill");o.type="gradient",o.method="linear",o.angle="180";var u=document.createElement(e._vmlNS+":rect");u.style.position="absolute",u.style.left="-1px",u.style.top="-1px",u.stroked=!1,u.appendChild(o),s.appendChild(u);var i=function(e,t,n,r){s.style.width=e+"px",s.style.height=t+"px",u.style.width=e+1+"px",u.style.height=t+1+"px",o.color=n,o.color2=r};t.elm=s,t.draw=i}return t},leaveValue:1,leaveStyle:2,leavePad:4,leaveSld:8,BoxShadow:function(){var e=function(e,t,n,r,i,s){this.hShadow=e,this.vShadow=t,this.blur=n,this.spread=r,this.color=i,this.inset=!!s};return e.prototype.toString=function(){var e=[Math.round(this.hShadow)+"px",Math.round(this.vShadow)+"px",Math.round(this.blur)+"px",Math.round(this.spread)+"px",this.color];return this.inset&&e.push("inset"),e.join(" ")},e}(),jscolor:function(t,n){function i(e,t,n){e/=255,t/=255,n/=255;var r=Math.min(Math.min(e,t),n),i=Math.max(Math.max(e,t),n),s=i-r;if(s===0)return[null,0,100*i];var o=e===r?3+(n-t)/s:t===r?5+(e-n)/s:1+(t-e)/s;return[60*(o===6?0:o),100*(s/i),100*i]}function s(e,t,n){var r=255*(n/100);if(e===null)return[r,r,r];e/=60,t/=100;var i=Math.floor(e),s=i%2?e-i:1-(e-i),o=r*(1-t),u=r*(1-t*s);switch(i){case 6:case 0:return[r,u,o];case 1:return[u,r,o];case 2:return[o,r,u];case 3:return[o,u,r];case 4:return[u,o,r];case 5:return[r,o,u]}}function o(){e.unsetClass(d.targetElement,d.activeClass),e.picker.wrap.parentNode.removeChild(e.picker.wrap),delete e.picker.owner}function u(){function l(){var e=d.insetColor.split(/\s+/),n=e.length<2?e[0]:e[1]+" "+e[0]+" "+e[0]+" "+e[1];t.btn.style.borderColor=n}d._processParentElementsInDOM(),e.picker||(e.picker={owner:null,wrap:document.createElement("div"),box:document.createElement("div"),boxS:document.createElement("div"),boxB:document.createElement("div"),pad:document.createElement("div"),padB:document.createElement("div"),padM:document.createElement("div"),padPal:e.createPalette(),cross:document.createElement("div"),crossBY:document.createElement("div"),crossBX:document.createElement("div"),crossLY:document.createElement("div"),crossLX:document.createElement("div"),sld:document.createElement("div"),sldB:document.createElement("div"),sldM:document.createElement("div"),sldGrad:e.createSliderGradient(),sldPtrS:document.createElement("div"),sldPtrIB:document.createElement("div"),sldPtrMB:document.createElement("div"),sldPtrOB:document.createElement("div"),btn:document.createElement("div"),btnT:document.createElement("span")},e.picker.pad.appendChild(e.picker.padPal.elm),e.picker.padB.appendChild(e.picker.pad),e.picker.cross.appendChild(e.picker.crossBY),e.picker.cross.appendChild(e.picker.crossBX),e.picker.cross.appendChild(e.picker.crossLY),e.picker.cross.appendChild(e.picker.crossLX),e.picker.padB.appendChild(e.picker.cross),e.picker.box.appendChild(e.picker.padB),e.picker.box.appendChild(e.picker.padM),e.picker.sld.appendChild(e.picker.sldGrad.elm),e.picker.sldB.appendChild(e.picker.sld),e.picker.sldB.appendChild(e.picker.sldPtrOB),e.picker.sldPtrOB.appendChild(e.picker.sldPtrMB),e.picker.sldPtrMB.appendChild(e.picker.sldPtrIB),e.picker.sldPtrIB.appendChild(e.picker.sldPtrS),e.picker.box.appendChild(e.picker.sldB),e.picker.box.appendChild(e.picker.sldM),e.picker.btn.appendChild(e.picker.btnT),e.picker.box.appendChild(e.picker.btn),e.picker.boxB.appendChild(e.picker.box),e.picker.wrap.appendChild(e.picker.boxS),e.picker.wrap.appendChild(e.picker.boxB));var t=e.picker,n=!!e.getSliderComponent(d),r=e.getPickerDims(d),i=2*d.pointerBorderWidth+d.pointerThickness+2*d.crossSize,s=e.getPadToSliderPadding(d),o=Math.min(d.borderRadius,Math.round(d.padding*Math.PI)),u="crosshair";t.wrap.style.clear="both",t.wrap.style.width=r[0]+2*d.borderWidth+"px",t.wrap.style.height=r[1]+2*d.borderWidth+"px",t.wrap.style.zIndex=d.zIndex,t.box.style.width=r[0]+"px",t.box.style.height=r[1]+"px",t.boxS.style.position="absolute",t.boxS.style.left="0",t.boxS.style.top="0",t.boxS.style.width="100%",t.boxS.style.height="100%",e.setBorderRadius(t.boxS,o+"px"),t.boxB.style.position="relative",t.boxB.style.border=d.borderWidth+"px solid",t.boxB.style.borderColor=d.borderColor,t.boxB.style.background=d.backgroundColor,e.setBorderRadius(t.boxB,o+"px"),t.padM.style.background=t.sldM.style.background="#FFF",e.setStyle(t.padM,"opacity","0"),e.setStyle(t.sldM,"opacity","0"),t.pad.style.position="relative",t.pad.style.width=d.width+"px",t.pad.style.height=d.height+"px",t.padPal.draw(d.width,d.height,e.getPadYComponent(d)),t.padB.style.position="absolute",t.padB.style.left=d.padding+"px",t.padB.style.top=d.padding+"px",t.padB.style.border=d.insetWidth+"px solid",t.padB.style.borderColor=d.insetColor,t.padM._jscInstance=d,t.padM._jscControlName="pad",t.padM.style.position="absolute",t.padM.style.left="0",t.padM.style.top="0",t.padM.style.width=d.padding+2*d.insetWidth+d.width+s/2+"px",t.padM.style.height=r[1]+"px",t.padM.style.cursor=u,t.cross.style.position="absolute",t.cross.style.left=t.cross.style.top="0",t.cross.style.width=t.cross.style.height=i+"px",t.crossBY.style.position=t.crossBX.style.position="absolute",t.crossBY.style.background=t.crossBX.style.background=d.pointerBorderColor,t.crossBY.style.width=t.crossBX.style.height=2*d.pointerBorderWidth+d.pointerThickness+"px",t.crossBY.style.height=t.crossBX.style.width=i+"px",t.crossBY.style.left=t.crossBX.style.top=Math.floor(i/2)-Math.floor(d.pointerThickness/2)-d.pointerBorderWidth+"px",t.crossBY.style.top=t.crossBX.style.left="0",t.crossLY.style.position=t.crossLX.style.position="absolute",t.crossLY.style.background=t.crossLX.style.background=d.pointerColor,t.crossLY.style.height=t.crossLX.style.width=i-2*d.pointerBorderWidth+"px",t.crossLY.style.width=t.crossLX.style.height=d.pointerThickness+"px",t.crossLY.style.left=t.crossLX.style.top=Math.floor(i/2)-Math.floor(d.pointerThickness/2)+"px",t.crossLY.style.top=t.crossLX.style.left=d.pointerBorderWidth+"px",t.sld.style.overflow="hidden",t.sld.style.width=d.sliderSize+"px",t.sld.style.height=d.height+"px",t.sldGrad.draw(d.sliderSize,d.height,"#000","#000"),t.sldB.style.display=n?"block":"none",t.sldB.style.position="absolute",t.sldB.style.right=d.padding+"px",t.sldB.style.top=d.padding+"px",t.sldB.style.border=d.insetWidth+"px solid",t.sldB.style.borderColor=d.insetColor,t.sldM._jscInstance=d,t.sldM._jscControlName="sld",t.sldM.style.display=n?"block":"none",t.sldM.style.position="absolute",t.sldM.style.right="0",t.sldM.style.top="0",t.sldM.style.width=d.sliderSize+s/2+d.padding+2*d.insetWidth+"px",t.sldM.style.height=r[1]+"px",t.sldM.style.cursor="default",t.sldPtrIB.style.border=t.sldPtrOB.style.border=d.pointerBorderWidth+"px solid "+d.pointerBorderColor,t.sldPtrOB.style.position="absolute",t.sldPtrOB.style.left=-(2*d.pointerBorderWidth+d.pointerThickness)+"px",t.sldPtrOB.style.top="0",t.sldPtrMB.style.border=d.pointerThickness+"px solid "+d.pointerColor,t.sldPtrS.style.width=d.sliderSize+"px",t.sldPtrS.style.height=m+"px",t.btn.style.display=d.closable?"block":"none",t.btn.style.position="absolute",t.btn.style.left=d.padding+"px",t.btn.style.bottom=d.padding+"px",t.btn.style.padding="0 15px",t.btn.style.height=d.buttonHeight+"px",t.btn.style.border=d.insetWidth+"px solid",l(),t.btn.style.color=d.buttonColor,t.btn.style.font="12px sans-serif",t.btn.style.textAlign="center";try{t.btn.style.cursor="pointer"}catch(c){t.btn.style.cursor="hand"}t.btn.onmousedown=function(){d.hide()},t.btnT.style.lineHeight=d.buttonHeight+"px",t.btnT.innerHTML="",t.btnT.appendChild(document.createTextNode(d.closeText)),a(),f(),e.picker.owner&&e.picker.owner!==d&&e.unsetClass(e.picker.owner.targetElement,d.activeClass),e.picker.owner=d,e.isElementType(v,"body")?e.redrawPosition():e._drawPosition(d,0,0,"relative",!1),t.wrap.parentNode!=v&&v.appendChild(t.wrap),e.setClass(d.targetElement,d.activeClass)}function a(){switch(e.getPadYComponent(d)){case"s":var t=1;break;case"v":var t=2}var n=Math.round(d.hsv[0]/360*(d.width-1)),r=Math.round((1-d.hsv[t]/100)*(d.height-1)),i=2*d.pointerBorderWidth+d.pointerThickness+2*d.crossSize,o=-Math.floor(i/2);e.picker.cross.style.left=n+o+"px",e.picker.cross.style.top=r+o+"px";switch(e.getSliderComponent(d)){case"s":var u=s(d.hsv[0],100,d.hsv[2]),a=s(d.hsv[0],0,d.hsv[2]),f="rgb("+Math.round(u[0])+","+Math.round(u[1])+","+Math.round(u[2])+")",l="rgb("+Math.round(a[0])+","+Math.round(a[1])+","+Math.round(a[2])+")";e.picker.sldGrad.draw(d.sliderSize,d.height,f,l);break;case"v":var c=s(d.hsv[0],d.hsv[1],100),f="rgb("+Math.round(c[0])+","+Math.round(c[1])+","+Math.round(c[2])+")",l="#000";e.picker.sldGrad.draw(d.sliderSize,d.height,f,l)}}function f(){var t=e.getSliderComponent(d);if(t){switch(t){case"s":var n=1;break;case"v":var n=2}var r=Math.round((1-d.hsv[n]/100)*(d.height-1));e.picker.sldPtrOB.style.top=r-(2*d.pointerBorderWidth+d.pointerThickness)-Math.floor(m/2)+"px"}}function l(){return e.picker&&e.picker.owner===d}function c(){d.importColor()}this.value=null,this.valueElement=t,this.styleElement=t,this.required=!0,this.refine=!0,this.hash=!1,this.uppercase=!0,this.onFineChange=null,this.activeClass="jscolor-active",this.minS=0,this.maxS=100,this.minV=0,this.maxV=100,this.hsv=[0,0,100],this.rgb=[255,255,255],this.width=181,this.height=101,this.showOnClick=!0,this.mode="HSV",this.position="bottom",this.smartPosition=!0,this.sliderSize=16,this.crossSize=8,this.closable=!1,this.closeText="Close",this.buttonColor="#000000",this.buttonHeight=18,this.padding=12,this.backgroundColor="#FFFFFF",this.borderWidth=1,this.borderColor="#BBBBBB",this.borderRadius=8,this.insetWidth=1,this.insetColor="#BBBBBB",this.shadow=!0,this.shadowBlur=15,this.shadowColor="rgba(0,0,0,0.2)",this.pointerColor="#4C4C4C",this.pointerBorderColor="#FFFFFF",this.pointerBorderWidth=1,this.pointerThickness=2,this.zIndex=1e6,this.container=null;for(var r in n)n.hasOwnProperty(r)&&(this[r]=n[r]);this.hide=function(){l()&&o()},this.show=function(){u()},this.redraw=function(){l()&&u()},this.importColor=function(){this.valueElement?e.isElementType(this.valueElement,"input")?this.refine?!this.required&&/^\s*$/.test(this.valueElement.value)?(this.valueElement.value="",this.styleElement&&(this.styleElement.style.backgroundImage=this.styleElement._jscOrigStyle.backgroundImage,this.styleElement.style.backgroundColor=this.styleElement._jscOrigStyle.backgroundColor,this.styleElement.style.color=this.styleElement._jscOrigStyle.color),this.exportColor(e.leaveValue|e.leaveStyle)):this.fromString(this.valueElement.value)||this.exportColor():this.fromString(this.valueElement.value,e.leaveValue)||(this.styleElement&&(this.styleElement.style.backgroundImage=this.styleElement._jscOrigStyle.backgroundImage,this.styleElement.style.backgroundColor=this.styleElement._jscOrigStyle.backgroundColor,this.styleElement.style.color=this.styleElement._jscOrigStyle.color),this.exportColor(e.leaveValue|e.leaveStyle)):this.exportColor():this.exportColor()},this.exportColor=function(t){if(!(t&e.leaveValue)&&this.valueElement){var n=this.toString();this.uppercase&&(n=n.toUpperCase()),this.hash&&(n="#"+n),e.isElementType(this.valueElement,"input")?this.valueElement.value=n:this.valueElement.innerHTML=n}t&e.leaveStyle||this.styleElement&&(this.styleElement.style.backgroundImage="none",this.styleElement.style.backgroundColor="#"+this.toString(),this.styleElement.style.color=this.isLight()?"#000":"#FFF"),!(t&e.leavePad)&&l()&&a(),!(t&e.leaveSld)&&l()&&f()},this.fromHSV=function(e,t,n,r){if(e!==null){if(isNaN(e))return!1;e=Math.max(0,Math.min(360,e))}if(t!==null){if(isNaN(t))return!1;t=Math.max(0,Math.min(100,this.maxS,t),this.minS)}if(n!==null){if(isNaN(n))return!1;n=Math.max(0,Math.min(100,this.maxV,n),this.minV)}this.rgb=s(e===null?this.hsv[0]:this.hsv[0]=e,t===null?this.hsv[1]:this.hsv[1]=t,n===null?this.hsv[2]:this.hsv[2]=n),this.exportColor(r)},this.fromRGB=function(e,t,n,r){if(e!==null){if(isNaN(e))return!1;e=Math.max(0,Math.min(255,e))}if(t!==null){if(isNaN(t))return!1;t=Math.max(0,Math.min(255,t))}if(n!==null){if(isNaN(n))return!1;n=Math.max(0,Math.min(255,n))}var o=i(e===null?this.rgb[0]:e,t===null?this.rgb[1]:t,n===null?this.rgb[2]:n);o[0]!==null&&(this.hsv[0]=Math.max(0,Math.min(360,o[0]))),o[2]!==0&&(this.hsv[1]=o[1]===null?null:Math.max(0,this.minS,Math.min(100,this.maxS,o[1]))),this.hsv[2]=o[2]===null?null:Math.max(0,this.minV,Math.min(100,this.maxV,o[2]));var u=s(this.hsv[0],this.hsv[1],this.hsv[2]);this.rgb[0]=u[0],this.rgb[1]=u[1],this.rgb[2]=u[2],this.exportColor(r)},this.fromString=function(e,t){var n;if(n=e.match(/^\W*([0-9A-F]{3}([0-9A-F]{3})?)\W*$/i))return n[1].length===6?this.fromRGB(parseInt(n[1].substr(0,2),16),parseInt(n[1].substr(2,2),16),parseInt(n[1].substr(4,2),16),t):this.fromRGB(parseInt(n[1].charAt(0)+n[1].charAt(0),16),parseInt(n[1].charAt(1)+n[1].charAt(1),16),parseInt(n[1].charAt(2)+n[1].charAt(2),16),t),!0;if(n=e.match(/^\W*rgba?\(([^)]*)\)\W*$/i)){var r=n[1].split(","),i=/^\s*(\d*)(\.\d+)?\s*$/,s,o,u;if(r.length>=3&&(s=r[0].match(i))&&(o=r[1].match(i))&&(u=r[2].match(i))){var a=parseFloat((s[1]||"0")+(s[2]||"")),f=parseFloat((o[1]||"0")+(o[2]||"")),l=parseFloat((u[1]||"0")+(u[2]||""));return this.fromRGB(a,f,l,t),!0}}return!1},this.toString=function(){return(256|Math.round(this.rgb[0])).toString(16).substr(1)+(256|Math.round(this.rgb[1])).toString(16).substr(1)+(256|Math.round(this.rgb[2])).toString(16).substr(1)},this.toHEXString=function(){return"#"+this.toString().toUpperCase()},this.toRGBString=function(){return"rgb("+Math.round(this.rgb[0])+","+Math.round(this.rgb[1])+","+Math.round(this.rgb[2])+")"},this.isLight=function(){return.213*this.rgb[0]+.715*this.rgb[1]+.072*this.rgb[2]>127.5},this._processParentElementsInDOM=function(){if(this._linkedElementsProcessed)return;this._linkedElementsProcessed=!0;var t=this.targetElement;do{var n=e.getStyle(t);n&&n.position.toLowerCase()==="fixed"&&(this.fixed=!0),t!==this.targetElement&&(t._jscEventsAttached||(e.attachEvent(t,"scroll",e.onParentScroll),t._jscEventsAttached=!0))}while((t=t.parentNode)&&!e.isElementType(t,"body"))};if(typeof t=="string"){var h=t,p=document.getElementById(h);p?this.targetElement=p:e.warn("Could not find target element with ID '"+h+"'")}else t?this.targetElement=t:e.warn("Invalid target element: '"+t+"'");if(this.targetElement._jscLinkedInstance){e.warn("Cannot link jscolor twice to the same element. Skipping.");return}this.targetElement._jscLinkedInstance=this,this.valueElement=e.fetchElement(this.valueElement),this.styleElement=e.fetchElement(this.styleElement);var d=this,v=this.container?e.fetchElement(this.container):document.getElementsByTagName("body")[0],m=3;if(e.isElementType(this.targetElement,"button"))if(this.targetElement.onclick){var g=this.targetElement.onclick;this.targetElement.onclick=function(e){return g.call(this,e),!1}}else this.targetElement.onclick=function(){return!1};if(this.valueElement&&e.isElementType(this.valueElement,"input")){var y=function(){d.fromString(d.valueElement.value,e.leaveValue),e.dispatchFineChange(d)};e.attachEvent(this.valueElement,"keyup",y),e.attachEvent(this.valueElement,"input",y),e.attachEvent(this.valueElement,"blur",c),this.valueElement.setAttribute("autocomplete","off")}this.styleElement&&(this.styleElement._jscOrigStyle={backgroundImage:this.styleElement.style.backgroundImage,backgroundColor:this.styleElement.style.backgroundColor,color:this.styleElement.style.color}),this.value?this.fromString(this.value)||this.exportColor():this.importColor()}};return e.jscolor.lookupClass="jscolor",e.jscolor.installByClassName=function(t){var n=document.getElementsByTagName("input"),r=document.getElementsByTagName("button");e.tryInstallOnElements(n,t),e.tryInstallOnElements(r,t)},e.register(),e.jscolor}());
		</script>
		<script>
var modalOverlay = document.getElementById("modal_overlay");
var modalOverlaySelected = false;

modalOverlay.onmousedown = function(e) {
	if(e.target == modalOverlay) {
		modalOverlaySelected = true;
	} else {
		modalOverlaySelected = false;
	}
}

modalOverlay.onmouseup = function(e) {
	if(modalOverlaySelected && e.target == modalOverlay) {
		if(Modal.current) {
			Modal.current.close();
		}
	}
	modalOverlaySelected = false;
}

function updateModalCheckboxField(list, parent) {
	if(parent) {
		if(!parent.cbElm.checked || parent.cbElm.disabled) {
			for(var i = 0; i < list.length; i++) {
				list[i].cbElm.disabled = true;
			}
		} else {
			for(var i = 0; i < list.length; i++) {
				list[i].cbElm.disabled = false;
			}
		}
	}
	for(var i = 0; i < list.length; i++) {
		updateModalCheckboxField(list[i].children, list[i]);
	}
}

function Modal() {
	this.inputField = null;
	this.formTitle = null;
	this.formField = null;
	this.formInputs = [];

	this.footerCont = [];
	this.footerField = null;

	this.isOpen = false;
	this.hasSubmitted = false;

	this.submitFn = null;
	this.openFn = null;
	this.closeFn = null;

	this.cbField = null;
	this.cbList = [];
	this.cbCallback = null;

	var frame = document.createElement("div");
	frame.className = "modal_frame";
	frame.style.flexDirection = "column";
	frame.style.display = "none";
	frame.style.position = "absolute";
	frame.style.minWidth = "16px";
	frame.style.minHeight = "16px";

	var fClient = document.createElement("div");
	fClient.className = "modal_client";
	fClient.style.flex = "1";
	fClient.style.margin = "6px";
	fClient.style.padding = "12px";
	fClient.style.position = "relative";

	frame.appendChild(fClient)
	modalOverlay.appendChild(frame);

	this.frame = frame;
	this.client = fClient;

	Modal.list.push(this);
	return this;
}

Modal.closeAll = function() {
	for(var i = 0; i < Modal.list.length; i++) {
		var modal = Modal.list[i];
		modal.close();
	}
}
Modal.isOpen = false;
Modal.current = null;
Modal.list = [];

/*
	Creates a form section in the modal.
	Modals are currently limited to one form only.
*/
Modal.prototype.createForm = function() {
	if(this.formField) return;
	var self = this;
	var formField = document.createElement("div");
	var inputField = document.createElement("div");
	var title = document.createElement("div");
	var subField = document.createElement("div");

	inputField.style.display = "grid";
	inputField.style.gap = "2px";
	inputField.style.marginBottom = "2px";

	var subm = document.createElement("button");
	subm.innerText = "Go";
	subm.style.paddingLeft = "11px";
	subm.style.paddingRight = "11px";
	subm.onclick = function() {
		self.submitForm();
	}
	var canc = document.createElement("span");
	canc.innerText = "cancel";
	canc.style.color = "blue";
	canc.style.textDecoration = "underline";
	canc.style.cursor = "pointer";
	canc.onclick = function() {
		self.cancelForm();
	}
	subField.appendChild(subm);
	subField.append(" or ");
	subField.appendChild(canc);

	formField.appendChild(title);
	formField.appendChild(inputField);
	formField.appendChild(subField);
	this.formTitle = title;
	this.formField = formField;
	this.inputField = inputField;
	this.subField = subField;
	this.client.appendChild(formField);
	this.alignForm();
}

/*
	Validates, processes, and submits the form.
	This triggers the onSubmit callback.
*/
Modal.prototype.submitForm = function() {
	if(this.hasSubmitted) return;

	// validation
	var formFailed = false;
	for(var i = 0; i < this.formInputs.length; i++) {
		var fInput = this.formInputs[i];
		var val = fInput.input.value;
		var failed = false;
		if(fInput.validation == "number") {
			var num = parseFloat(val);
			if(!isFinite(num) || isNaN(num)) {
				failed = true;
			}
		} else if(fInput.validation == "required") {
			failed = !val;
		}
		if(failed) {
			fInput.validationFailed = true;
			fInput.input.style.border = "1px solid red";
			formFailed = true;
		} else if(fInput.validationFailed) {
			fInput.validationFailed = false;
			fInput.input.style.border = "";
		}
	}
	if(formFailed) {
		return;
	}

	this.hasSubmitted = true;
	if(this.submitFn) {
		var argList = {};
		for(var i = 0; i < this.formInputs.length; i++) {
			var fInput = this.formInputs[i];
			argList[fInput.label] = fInput.input.value;
			argList[i] = fInput.input.value;
		}
		argList.length = this.formInputs.length;
		this.submitFn(argList);
	}
	if(this.isOpen) {
		this.close();
	}
}

/*
	Revert the form and close the modal.
*/
Modal.prototype.cancelForm = function() {
	// revert the form values
	this.close(true);
}

/*
	Line up all form labels.
	The form labels are set to the left and the inputs are set to the right.
*/
Modal.prototype.alignForm = function() {
	if(!this.formField) {
		throw "No form exists";
	}
	this.inputField.style.gridTemplateColumns = "0fr 1fr";
}

/*
	Set each form label on its own line.
*/
Modal.prototype.unalignForm = function() {
	if(!this.formField) {
		throw "No form exists";
	}
	this.inputField.style.gridTemplateColumns = "";
}

/*
	Add an input entry to the form.
	label: The label to be shown next to the input.
	type (optional): 'text' or 'color'.
	validation (optional): 'number'. Check if the entry contains a valid value.
*/
Modal.prototype.addEntry = function(label, type, validation) {
	if(!this.formField) {
		throw "No form exists";
	}
	var self = this;
	var lab = document.createElement("label");
	lab.innerText = label + ":";
	lab.style.marginRight = "3px";
	lab.style.whiteSpace = "nowrap";
	var inp = document.createElement("input");
	inp.style.width = "150px";
	var isColor = false;
	if(!type) {
		type = "text";
	}
	if(type == "color") {
		inp.className = "jscolor";
		isColor = true;
	}
	inp.onkeydown = function(e) {
		if(e.key == "Enter") {
			self.submitForm();
		}
	}
	this.inputField.appendChild(lab);
	this.inputField.appendChild(inp);
	if(isColor) {
		window.jscolor.installByClassName("jscolor");
	}
	this.formInputs.push({
		input: inp,
		value: inp.value,
		validation: validation,
		validationFailed: false,
		type: type,
		label: label
	});
	return {
		input: inp
	};
}

/*
	Sets the fixed size of the modal.
	Any overflown content will be hidden.
	Setting either dimension to zero will reset that dimension.
*/
Modal.prototype.setSize = function(width, height) {
	if(width) {
		this.frame.style.width = width + "px";
	} else {
		this.frame.style.width = "";
	}
	if(height) {
		this.frame.style.height = height + "px";
	} else {
		this.frame.style.height = "";
	}
}

/*
	Sets the minimum size of the modal.
	The modal cannot be smaller than this size.
	Setting either dimension to zero will reset that dimension.
*/
Modal.prototype.setMinimumSize = function(width, height) {
	if(width) {
		this.frame.style.minWidth = width + "px";
	} else {
		this.frame.style.minWidth = "";
	}
	if(height) {
		this.frame.style.minHeight = height + "px";
	} else {
		this.frame.style.minHeight = "";
	}
}

/*
	Sets the maximum size of the modal.
	The modal cannot be bigger than this size. Overflown content will be hidden.
	Setting either dimension to zero will reset that dimension.
*/
Modal.prototype.setMaximumSize = function(width, height) {
	if(width) {
		this.frame.style.maxWidth = width + "px";
	} else {
		this.frame.style.maxWidth = "";
	}
	if(height) {
		this.frame.style.maxHeight = height + "px";
	} else {
		this.frame.style.maxHeight = "";
	}

	// ensure client area doesn't overflow
	if(width && height) {
		this.client.style.overflow = "hidden";
	} else if(width) {
		this.client.style.overflowX = "hidden";
		this.client.style.overflowY = "";
	} else if(height) {
		this.client.style.overflowX = "";
		this.client.style.overflowY = "hidden";
	} else {
		this.client.style.overflow = "";
	}
}

/*
	Set a title or description at the top of the modal.
*/
Modal.prototype.setFormTitle = function(title, opts) {
	if(title == void 0) {
		title = "";
	}
	title += "";
	if(title[title.length - 1] == "\n" && title.length > 1) {
		title += "\n"; // add an extra newline due to html behavior
	}
	this.formTitle.innerText = title;
	if(opts) {
		if("bold" in opts) {
			if(opts.bold) {
				this.formTitle.style.fontWeight = "bold";
				this.formTitle.style.marginBottom = "4px";
			} else {
				this.formTitle.style.fontWeight = "";
				this.formTitle.style.marginBottom = "";
			}
		}
		if("center" in opts) {
			if(opts.center) {
				this.formTitle.style.textAlign = "center";
			} else {
				this.formTitle.style.textAlign = "";
			}
		}
	}
}

/*
	Add a footer to the bottom of the modal.
	The footer is split into three parts (left, center, right).
*/
Modal.prototype.setFooter = function() {
	if(this.footerField) return;
	var footer = document.createElement("div");
	footer.style.margin = "6px";
	footer.style.minHeight = "18px";
	footer.style.display = "flex";
	footer.style.justifyContent = "space-between";

	var cLeft = document.createElement("div");
	var cMid = document.createElement("div");
	var cRight = document.createElement("div");
	cLeft.style.display = "flex";
	cLeft.style.alignItems = "center";
	cMid.style.display = "flex";
	cMid.style.alignItems = "center";
	cRight.style.display = "flex";
	cRight.style.alignItems = "center";

	this.footerCont = [cLeft, cMid, cRight];
	footer.appendChild(cLeft);
	footer.appendChild(cMid);
	footer.appendChild(cRight);
	this.client.style.marginBottom = "0px";
	this.frame.appendChild(footer);
	this.footerField = footer;
}

/*
	Removes the footer from the modal.
*/
Modal.prototype.removeFooter = function() {
	if(!this.footerField) return;
	this.frame.removeChild(this.footerField);
	this.footerCont = [];
}

/*
	Adds a checkbox to the left section of the footer.
	labelName: name of the checkbox.
	callback: to be called when the checkbox is checked (parameter: checked)
*/
Modal.prototype.setFooterCheckbox = function(labelName, callback, defaultState) {
	if(!this.footerField) {
		this.setFooter();
	}
	var lab = document.createElement("label");
	lab.className = "modal_corner_checkbox_label";
	var cb = document.createElement("input");
	cb.type = "checkbox";
	cb.checked = Boolean(defaultState);
	cb.oninput = function() {
		if(callback) {
			callback(cb.checked);
		}
	}
	lab.appendChild(cb);
	lab.append(" " + labelName);
	this.footerCont[0].appendChild(lab);
}

/*
	Adds content to a section of the footer.
*/
Modal.prototype.setFooterContentLeft = function(data) {
	if(!this.footerField) throw "No footer exists";
	this.footerCont[0].appendChild(data);
}
Modal.prototype.setFooterContentCenter = function(data) {
	if(!this.footerField) throw "No footer exists";
	this.footerCont[1].appendChild(data);
}
Modal.prototype.setFooterContentRight = function(data) {
	if(!this.footerField) throw "No footer exists";
	this.footerCont[2].appendChild(data);
}

/*
	Clears a section of the footer.
*/
Modal.prototype.removeFooterContentLeft = function() {
	if(!this.footerField) return;
	this.footerCont[0].innerHTML = "";
}
Modal.prototype.removeFooterContentCenter = function() {
	if(!this.footerField) return;
	this.footerCont[1].innerHTML = "";
}
Modal.prototype.removeFooterContentRight = function() {
	if(!this.footerField) return;
	this.footerCont[2].innerHTML = "";
}

/*
	Set event callbacks.
	onSubmit: to be called whenever the form is submitted.
	onOpen: to be called whenever the modal is opened.
	onClose: to be called whenever the modal is closed.
*/
Modal.prototype.onSubmit = function(callback) {
	this.submitFn = callback;
}
Modal.prototype.onOpen = function(callback) {
	this.openFn = callback;
}
Modal.prototype.onClose = function(callback) {
	this.closeFn = callback;
}
Modal.prototype.checkboxFieldOnInput = function(callback) {
	this.cbCallback = callback;
}

/*
	Display the modal.
	All parameters will be passed to the onOpen event.
*/
Modal.prototype.open = function(...params) {
	if(Modal.isOpen) {
		Modal.closeAll();
	}
	Modal.isOpen = true;
	Modal.current = this;
	modalOverlay.style.display = "";
	this.hasSubmitted = false;
	this.isOpen = true;
	this.frame.style.display = "flex"; // make visible
	if(this.formInputs.length) {
		var firstForm = this.formInputs[0].input;
		firstForm.focus();
	}
	for(var i = 0; i < this.formInputs.length; i++) {
		var fInput = this.formInputs[i];
		fInput.value = fInput.input.value;
	}
	if(this.openFn) {
		this.openFn(...params);
	}
}

/*
	Hide the modal.
	canceled: This modal has closed as a result of form cancelation. This will revert the values of the form inputs.
*/
Modal.prototype.close = function(canceled) {
	if(!this.isOpen) return;
	this.isOpen = false;
	this.frame.style.display = "none";
	Modal.isOpen = false;
	Modal.current = null;
	modalOverlay.style.display = "none";
	// revert all values if canceled, otherwise record them
	for(var i = 0; i < this.formInputs.length; i++) {
		var fInput = this.formInputs[i];
		if(canceled) {
			if(fInput.type == "color") {
				fInput.input.jscolor.fromString(fInput.value);
			} else {
				fInput.input.value = fInput.value;
			}
		} else {
			fInput.value = fInput.input.value;
		}
	}
	if(this.closeFn) {
		this.closeFn(canceled);
	}
}

/*
	Add a checkbox section to the modal.
	The checkbox section contains a nestable list of checkbox inputs.
	Only one checkbox field is currently supported.
*/
Modal.prototype.createCheckboxField = function() {
	if(this.cbField) return;
	var field = document.createElement("div");
	this.cbField = field;
	this.client.appendChild(field);
}

/*
	Adds a checkbox to the checkbox field.
	label: The name of the checkbox.
	parent (optional): The parent checkbox. Nested checkboxes will be indented.
*/
Modal.prototype.addCheckbox = function(label, parent) {
	if(!this.cbField) {
		throw "No checkbox field exists";
	}
	var self = this;
	var cbTitle = label;
	var cbParent = null;
	if(parent) {
		cbParent = parent;
	}

	var label = document.createElement("label");
	var cb = document.createElement("input");
	cb.type = "checkbox";
	label.style.display = "block";
	label.style.userSelect = "none";
	label.appendChild(cb);
	label.append(" " + cbTitle);

	var threshold = 0;
	var cbObj = {
		elm: label,
		cbElm: cb,
		children: []
	};
	if(cbParent) {
		threshold = cbParent.level + 1;
		label.style.marginLeft = (20 * threshold) + "px";
		if(cbParent.children.length) {
			var lastChild = cbParent.children[cbParent.children.length - 1];
			var nextElm = lastChild.nextSibling;
			if(nextElm) {
				lastChild.elm.insertBefore(label, nextElm);
			} else {
				this.cbField.appendChild(label);
			}
		} else {
			var nextElm = cbParent.elm.nextSibling;
			if(nextElm) {
				cbParent.elm.insertBefore(label, nextElm);
			} else {
				this.cbField.appendChild(label);
			}
		}
		cbObj.level = threshold;
		cbParent.children.push(cbObj);
	} else {
		this.cbField.appendChild(label);
		cbObj.level = threshold;
		this.cbList.push(cbObj);
	}

	cb.onclick = function() {
		if(self.cbCallback) {
			self.cbCallback(cbObj, cb.checked);
		}
		updateModalCheckboxField(cbObj.children, cbObj);
	}

	updateModalCheckboxField(this.cbList);

	return cbObj;
}

/*
	Insert content to the modal.
*/
Modal.prototype.append = function(elm) {
	this.client.appendChild(elm);
}

/*
	Adds a close caption to the bottom right of the modal.
*/
Modal.prototype.createClose = function() {
	var span = document.createElement("span");
	span.className = "modal_close";
	span.innerText = "Close";
	var self = this;
	span.onclick = function() {
		self.close();
	}
	this.client.appendChild(span);
}
		</script>
		<script>
function Menu(titleEl, menuEl) {
	var _this = this;
	this.titleEl = titleEl;
	this.menuEl = menuEl;
	this.pinEl = null;
	this._SPEED = 250;
	this.entries = [];
	this.pinned = false;
	this.visible = false;
	this.lastEntryId = 1;
	this.entriesById = {};
	this.addOption = function(text, action) {
		var s = document.createElement("div");
		s.innerText = text;
		s.onclick = function() {
			action();
			_this.hideNow();
		}
		return _this.addEntry(s);
	}
	this.addCheckboxOption = function(text, checkedAction, uncheckedAction, checked) {
		var s = document.createElement("div");
		if(text.charAt(0) == " ") {
			text = text.substr(1);
		}
		s.innerText = " " + text;
		var i = document.createElement("input");
		i.type = "checkbox";
		i.checked = !!checked;
		s.insertBefore(i, s.firstChild);
		s.checked = !!checked;
		s.onclick = function(e) {
			if(e.target !== i) {
				i.checked = !i.checked;
			}
			if(i.checked) {
				checkedAction();
			} else {
				uncheckedAction();
			}
		}
		return _this.addEntry(s);
	}
	this.hideNow = function() {
		if(_this.pinned) return;
		_this.visible = false;
		slideMenu("up", _this.menuEl, _this._SPEED);
		_this.titleEl.classList.remove("hover");
	}
	this.cancelHide = false;
	this.hide = function() {
		if(_this.pinned) return;
		_this.cancelHide = false;
		setTimeout((function() {
			if (!_this.cancelHide) {
				_this.hideNow();
			}
		}), 500);
	}
	this.show = function() {
		_this.visible = true;
		_this.cancelHide = true;
		slideMenu("down", _this.menuEl, _this._SPEED);
		_this.titleEl.classList.add("hover");
	}
	this.getEntryContainer = function() {
		var mainUl = _this.menuEl.getElementsByTagName("ul");
		var entryLi = null;
		if(mainUl.length) {
			entryLi = document.createElement("li");
			mainUl[0].appendChild(entryLi);
		}
		return entryLi;
	}
	this.addEntry = function(liContents) {
		var entryLi = _this.getEntryContainer();
		if(!entryLi) {
			throw "Cannot locate space for new entry";
		}
		if(typeof liContents == "string") {
			var lcDiv = document.createElement("div");
			lcDiv.innerHTML = liContents;
			var ch = lcDiv.children;
			var len = ch.length;
			for(var r = 0; r < len; r++) {
				var elm = ch[0];
				entryLi.appendChild(elm);
			}
		} else {
			entryLi.appendChild(liContents);
		}
		var entryData = {
			element: entryLi,
			content: liContents
		};
		_this.entries.push(entryData);
		entryLi.onmouseenter = function() {
			this.classList.add("hover");
		}
		entryLi.onmouseleave = function() {
			this.classList.remove("hover");
		}
		var eid = _this.lastEntryId++;
		_this.entriesById[eid] = entryData;
		return eid;
	}
	this.hideEntry = function(id) {
		var entry = _this.entriesById[id];
		if(!entry) return;
		var elm = entry.element;
		elm.style.display = "none";
	}
	this.showEntry = function(id) {
		var entry = _this.entriesById[id];
		if(!entry) return;
		var elm = entry.element;
		elm.style.display = "";
	}
	this.setEntryVisibility = function(id, visible) {
		if(visible) {
			_this.showEntry(id);
		} else {
			_this.hideEntry(id);
		}
	}
	this.moveEntryLast = function(id) {
		var entry = _this.entriesById[id];
		if(!entry) return;
		var elm = entry.element;
		var mainUl = _this.menuEl.getElementsByTagName("ul")[0];
		if(!mainUl) {
			throw "Entry container not found";
		}
		elm.remove();
		mainUl.appendChild(elm);
	}
	this.pin = function() {
		_this.pinned = true;
		_this.show();
		if(!_this.pinEl) {
			var pin = _this.titleEl.getElementsByClassName("menuPin");
			if(pin.length) {
				_this.pinEl = pin[0];
			}
		}
		if(_this.pinEl) {
			_this.pinEl.style.display = "";
		}
	}
	this.unpin = function(noHide) {
		_this.pinned = false;
		if(!noHide) {
			_this.hide();
		}
		if(_this.pinEl) {
			_this.pinEl.style.display = "none";
		}
	}
	this.titleEl.style.display = "";

	this.menuEl.style.top = (this.titleEl.getBoundingClientRect().top + document.body.scrollTop) + this.titleEl.offsetHeight + "px";

	// "Menu" button
	this.titleEl.onmouseenter = this.show;
	this.titleEl.onmouseleave = this.hide;

	// menu list
	this.menuEl.onmouseenter = this.show;
	this.menuEl.onmouseleave = this.hide;

	this.titleEl.onclick = function() {
		if(!_this.visible) {
			_this.show();
			return;
		}
		if(_this.pinned) {
			_this.unpin(true);
		} else {
			_this.pin();
		}
	}
}

var menuAnimationState = "up";
var menuAnimationActive = false;
function slideMenu(direction, element, speed) {
	if(menuAnimationActive) return;
	var interval = 13;
	var menuMargin = 2;
	if(menuAnimationState == "up" && direction == "up") return;
	if(menuAnimationState == "down" && direction == "down") return;

	menuAnimationActive = true;
	menuAnimationState = direction;

	element.style.overflow = "hidden";
	element.style.marginTop = "0px";
	element.style.marginBottom = "0px";

	element.style.display = "block";
	var destHeight = element.offsetHeight - menuMargin * 2;
	if(direction == "down") element.style.height = "0px";
	var start = getDate();
	var end = start + speed;
	var lapse = end - start;
	var menu_int = setInterval(function() {
		element.style.display = "block";
		var duration = getDate() - start;
		if(duration >= lapse) {
			menuAnimationActive = false;
			clearInterval(menu_int);
			if(direction == "down") {
				element.style.display = "";
			} else if(direction == "up") {
				element.style.display = "none";
			}
			element.style.overflow = "";
			element.style.marginTop = "";
			element.style.marginBottom = "";
			element.style.height = "";
			element.style.paddingTop = "";
			element.style.paddingBottom = "";
			return;
		}
		var multiply = easeOutQuad(duration, 0, 1, speed);

		var currentHeight = multiply * destHeight;
		var currentPadding = multiply * menuMargin;

		if(direction == "up") {
			currentHeight = destHeight - currentHeight;
			currentPadding = menuMargin - currentPadding;
		}
		element.style.height = currentHeight + "px";
		element.style.paddingTop = currentPadding + "px";
		element.style.paddingBottom = currentPadding + "px";
	}, interval);
}
		</script>
		<script>
var PERM = {
	ADMIN: 2,
	MEMBERS: 1,
	PUBLIC: 0
};
var Permissions = {
	can_admin: function(user) {
		return user.is_owner;
	},
	can_coordlink: function(user, world) {
		return Permissions.user_matches_perm(user, world, world.feature_coord_link);
	},
	can_edit_tile: function(user, world, tile, charX, charY) {
		if(!tile) {
			throw new Error("Can't check perms on un-initted tile");
		}
		if(!Permissions.can_read(user, world)) {
			return false;
		}
		var targetWritability;
		if(tile.char) {
			targetWritability = tile.char[charY * tileC + charX];
			if(targetWritability == null) targetWritability = tile.writability; // inherit from tile
			if(targetWritability == null) targetWritability = world.writability; // inherit from world
		} else {
			targetWritability = tile.writability;
			if(targetWritability == null) targetWritability = world.writability;
		}
		return Permissions.user_matches_perm(user, world, targetWritability);
	},
	can_go_to_coord: function(user, world) {
		return Permissions.user_matches_perm(user, world, world.feature_go_to_coord);
	},
	can_paste: function(user, world) {
		return Permissions.user_matches_perm(user, world, world.feature_paste);
	},
	can_protect_tiles: function(user, world) {
		if(user.is_owner || user.is_superuser || user.is_operator) return true;
		return world.feature_membertiles_addremove && user.is_member;
	},
	can_read: function(user, world) {
		return Permissions.user_matches_perm(user, world, world.readability);
	},
	can_urllink: function(user, world) {
		return Permissions.user_matches_perm(user, world, world.feature_url_link);
	},
	can_write: function(user, world) {
		if(!Permissions.can_read(user, world)) {
			return false;
		}
		return Permissions.user_matches_perm(user, world, world.writability);
	},
	can_chat: function(user, world) {
		return Permissions.user_matches_perm(user, world, world.chat_permission);
	},
	can_show_cursor: function(user, world) {
		return Permissions.user_matches_perm(user, world, world.show_cursor);
	},
	can_color_text: function(user, world) {
		return Permissions.user_matches_perm(user, world, world.color_text);
	},
	user_matches_perm: function(user, world, perm) {
		if(perm == -1) { // no one
			return false;
		}
		if(perm == PERM.PUBLIC) { // anyone
			return true;
		}
		if(user.is_owner) {
			return true;
		}
		if(perm == PERM.ADMIN) {
			return false;
		}
		if(perm == PERM.MEMBERS && user.is_member) {
			return true;
		}
		return false;
	}
};
		</script>
		<script>
var selectedChatTab      = 0; // 0 is the page chat, 1 is the global chat
var chatOpen             = 0;
var chatPageUnread       = 0;
var chatGlobalUnread     = 0;
var initPageTabOpen      = false;
var initGlobalTabOpen    = false;
var chatWriteHistory     = []; // history of user's chats
var chatRecords          = [];
var chatWriteHistoryMax  = 100; // maximum size of chat write history length
var chatWriteHistoryIdx  = -1; // location in chat write history
var chatLimitCombChars   = true;
var chatWriteTmpBuffer   = "";
var defaultChatColor     = window.localStorage ? parseInt(localStorage.getItem("chatcolor")) : null; // 24-bit Uint
var chatPageUnreadBar    = null;
var chatGlobalUnreadBar  = null;
var chatGreentext        = true;
var acceptChatDeletions  = true;

if(isNaN(defaultChatColor)) {
	defaultChatColor = null;
} else {
	if(defaultChatColor < 0) defaultChatColor = 0;
	if(defaultChatColor > 16777215) defaultChatColor = 16777215;
}

defineElements({ // elm[<name>]
	chat_window: byId("chat_window"),
	chat_open: byId("chat_open"),
	chatsend: byId("chatsend"),
	chatbar: byId("chatbar"),
	chat_close: byId("chat_close"),
	page_chatfield: byId("page_chatfield"),
	global_chatfield: byId("global_chatfield"),
	chat_page_tab: byId("chat_page_tab"),
	chat_global_tab: byId("chat_global_tab"),
	usr_online: byId("usr_online"),
	total_unread: byId("total_unread"),
	page_unread: byId("page_unread"),
	global_unread: byId("global_unread")
});

if(Permissions.can_chat(state.userModel, state.worldModel)) {
	OWOT.on("chat", function(e) {
		w.emit("chatMod", e);
		if(e.hide) return;
		event_on_chat(e);
	});
}

if(state.userModel.is_staff) {
	elm.chatbar.maxLength = 3030;
} else {
	elm.chatbar.maxLength = 400;
}

var canChat = Permissions.can_chat(state.userModel, state.worldModel);
if(!canChat) {
	selectedChatTab = 1;
	elm.chat_window.style.display = "none";
} else {
	elm.chat_open.style.display = "";
}

function api_chat_send(message, opts) {
	if(!message) return;
	if(!opts) opts = {};
	var exclude_commands = opts.exclude_commands;
	var nick = opts.nick || YourWorld.Nickname;
	var location = opts.location ? opts.location : (selectedChatTab == 0 ? "page" : "global");

	var msgLim = state.userModel.is_staff ? 3030 : 400;

	message = message.trim();
	if(!message.length) return;
	message = message.slice(0, msgLim);
	chatWriteHistory.push(message);
	if(chatWriteHistory.length > chatWriteHistoryMax) {
		chatWriteHistory.shift();
	}
	chatWriteHistoryIdx = -1;
	chatWriteTmpBuffer = "";

	var chatColor;
	if(!opts.color) {
		if(!YourWorld.Color) {
			chatColor = assignColor(YourWorld.Nickname);
		} else {
			chatColor = "#" + ("00000" + YourWorld.Color.toString(16)).slice(-6);
		}
	} else {
		chatColor = opts.color;
	}

	if(!exclude_commands && message.startsWith("/")) {
		var args = message.substr(1).split(" ");
		var command = args[0].toLowerCase();
		args.shift();
		if(client_commands.hasOwnProperty(command)) {
			client_commands[command](args);
			return;
		}
	}

	network.chat(message, location, nick, chatColor);
}

function clientChatResponse(message) {
	addChat(null, 0, "user", "[ Client ]", message, "Client", true, true, true, null, getDate());
};

function serverChatResponse(msg, html=true) {
    addChat(null, 0, "user", "[ Server ]", msg, "Server", html, html, html, "#f00", getDate())
};  

var client_commands = {
    stats: (args) => {
        serverChatResponse("World stats:<br>Views: 1<br>Created on: March 24 2021, 5:32:11 PM");
    },
    whoami: (args) => {
        let user = state.userModel;
        let yw = YourWorld;
        let level = user.is_operator?3:user.is_superuser?2:user.is_staff?1:0;
        let levelCaption = level==3?"(Operator)":level==2?"(Superuser)":level==1?"(Staff)":"(Normal)";
        let levelStr = `${level} ${levelCaption}`
        
        let list = [`Username: <b style="color: ${int_to_hexcode(localStorage.getItem("chatcolor")*1)}">${user.username}</b>`, `Nickname: ${yw.Nickname}`, `Level: ${levelStr}`]
        
        serverChatResponse(`Who am I:<br>${list.join("<br>&emsp;")}`)
    },
    uptime: (args) => {
        serverChatResponse(`Server uptime: ${uptime()}`);
    },
    mute: (args) => {
        let mutedID = parseInt(args[0]);
        let muteTime = parseInt(args[1]);
        let muteFn = (e) => {
            if(e.id === muteID) e.hide = true;
        }
        
        w.events.chatmod.push(muteFn);
        let idx = w.events.chatmod.indexOf(muteFn);
        serverChatResponse(`Client muted until ${convertToDate(Date.now() + (muteTime * 1000))}`);
        
        setTimeout(()=>{w.events.chatmod.splice(idx, 1); serverChatResponse("Client unmuted")}, muteTime * 1000)
    },
    worlds: (args) => {
        serverChatResponse("Top active worlds:<br><span style=\"background-color: #ddd;\">(main) [1]</span>")
    },
	nick: function (args) {
		var newDisplayName = args.join(" ");
		if(!newDisplayName) {
			newDisplayName = state.userModel.username;
		}
		var nickLim = state.userModel.is_staff ? Infinity : 40;
		newDisplayName = newDisplayName.slice(0, nickLim);
		YourWorld.Nickname = newDisplayName;
		storeNickname();
		var nickChangeMsg;
		if(newDisplayName) {
			nickChangeMsg = "Set nickname to `" + newDisplayName + "`";
		} else {
			nickChangeMsg = "Nickname reset";
		}
		clientChatResponse(nickChangeMsg);
	},
	ping: function() {
		var pingTime = getDate();
		network.ping(function() {
			var pongTime = getDate();
			var pingMs = pongTime - pingTime;
			clientChatResponse("Ping: " + pingMs + " MS");
		});
	},
	gridsize: function (args) {
		var size = args[0];
		if(!size) size = "10x18";
		size = size.split("x");
		var width = parseInt(size[0]);
		var height = parseInt(size[1]);
		if(!width || isNaN(width) || !isFinite(width)) width = 10;
		if(!height || isNaN(height) || !isFinite(height)) height = 18;
		if(width < 4) width = 4;
		if(width > 160) width = 160;
		if(height < 4) height = 4;
		if(height > 144) height = 144;
		defaultSizes.cellW = width;
		defaultSizes.cellH = height;
		updateScaleConsts();
		w.reloadRenderer();
		clientChatResponse("Changed grid size to " + width + "x" + height);
	},
	color: function(args) {
		var color = args.join(" ");
		color = resolveColorValue(color);
		YourWorld.Color = color;
		clientChatResponse("Changed text color to #" + ("00000" + YourWorld.Color.toString(16)).slice(-6).toUpperCase());
	},
	chatcolor: function(args) {
		var color = args.join(" ");
		if(!color) {
			localStorage.removeItem("chatcolor");
			defaultChatColor = null;
			clientChatResponse("Chat color reset");
		} else {
			defaultChatColor = resolveColorValue(color);
			localStorage.setItem("chatcolor", defaultChatColor);
			clientChatResponse("Changed chat color to #" + ("00000" + defaultChatColor.toString(16)).slice(-6).toUpperCase());
		}
	},
	warp: function(args) {
		var address = args[0];
		if(!address) address = "";
		positionX = 0;
		positionY = 0;
		if(address.charAt(0) == "/") address = address.substr(1);
		state.worldModel.pathname = "/" + address;
		ws_path = createWsPath();
		w.changeSocket(ws_path);
		clientChatResponse("Switching to world: \"" + address + "\"");
	},
	warpserver: function(args) {
		var address = args[0];
		if(!address) {
			ws_path = createWsPath();
		} else {
			ws_path = address;
		}
		positionX = 0;
		positionY = 0;
		w.changeSocket(ws_path);
		clientChatResponse("Switching to server: " + ws_path);
	},
	night: function() {
		w.night();
	},
	day: function() {
		w.day(true);
	}
}

function sendChat() {
	var chatText = elm.chatbar.value;
	elm.chatbar.value = "";
	var opts = {};
	if(defaultChatColor != null) {
		opts.color = "#" + ("00000" + defaultChatColor.toString(16)).slice(-6);
	}
	api_chat_send(chatText, opts);
}

function updateUnread() {
	var total = elm.total_unread;
	var page = elm.page_unread;
	var global = elm.global_unread;
	var totalCount = chatPageUnread + chatGlobalUnread;
	total.style.display = "none";
	global.style.display = "none";
	page.style.display = "none";
	if(totalCount) {
		total.style.display = "";
		total.innerText = totalCount > 99 ? "99+" : "(" + totalCount + ")";
	}
	if(chatPageUnread) {
		page.style.display = "";
		page.innerText = chatPageUnread > 99 ? "99+" : "(" + chatPageUnread + ")";
	}
	if(chatGlobalUnread) {
		global.style.display = "";
		global.innerText = chatGlobalUnread > 99 ? "99+" : "(" + chatGlobalUnread + ")";
	}
}

function event_on_chat(data) {
	if((!chatOpen || selectedChatTab == 1) && data.location == "page") {
		chatPageUnread++;
	}
	if((!chatOpen || selectedChatTab == 0) && data.location == "global") {
		chatGlobalUnread++;
	}
	updateUnread();
	addChat(data.location, data.id, data.type,
		data.nickname, data.message, data.realUsername, data.op, data.admin, data.staff, data.color, data.date || Date.now(), data.dataObj);
}

elm.chatsend.addEventListener("click", function() {
	sendChat();
});

elm.chatbar.addEventListener("keypress", function(e) {
	var keyCode = e.keyCode;
	if(keyCode == 13) { // Enter
		sendChat();
	}
});

function moveCaretEnd(elm) {
	if(elm.selectionStart != void 0) {
		elm.selectionStart = elm.value.length;
		elm.selectionEnd = elm.value.length;
	} else if(elm.createTextRange != void 0) {
		elm.focus();
		var range = elm.createTextRange();
		range.collapse(false);
		range.select();
	}
}

elm.chatbar.addEventListener("keydown", function(e) {
	var keyCode = e.keyCode;
	// scroll through chat history that the client sent
	if(keyCode == 38) { // up
		// history modified
		if(chatWriteHistoryIdx > -1 && elm.chatbar.value != chatWriteHistory[chatWriteHistory.length - chatWriteHistoryIdx - 1]) {
			chatWriteHistory[chatWriteHistory.length - chatWriteHistoryIdx - 1] = elm.chatbar.value;
		}
		if(chatWriteHistoryIdx == -1 && elm.chatbar.value) {
			chatWriteTmpBuffer = elm.chatbar.value;
		}
		chatWriteHistoryIdx++;
		if(chatWriteHistoryIdx >= chatWriteHistory.length) chatWriteHistoryIdx = chatWriteHistory.length - 1;
		var upVal = chatWriteHistory[chatWriteHistory.length - chatWriteHistoryIdx - 1];
		if(!upVal) return;
		elm.chatbar.value = upVal;
		// pressing up will move the cursor all the way to the left by default
		e.preventDefault();
		moveCaretEnd(elm.chatbar);
	} else if(keyCode == 40) { // down
		// history modified
		if(chatWriteHistoryIdx > -1 && elm.chatbar.value != chatWriteHistory[chatWriteHistory.length - chatWriteHistoryIdx - 1]) {
			chatWriteHistory[chatWriteHistory.length - chatWriteHistoryIdx - 1] = elm.chatbar.value;
		}
		chatWriteHistoryIdx--;
		if(chatWriteHistoryIdx < -1) {
			chatWriteHistoryIdx = -1;
			return;
		}
		var str = "";
		if(chatWriteHistoryIdx != -1) {
			str = chatWriteHistory[chatWriteHistory.length - chatWriteHistoryIdx - 1];
		} else {
			if(chatWriteTmpBuffer) {
				str = chatWriteTmpBuffer;
				e.preventDefault();
				moveCaretEnd(elm.chatbar);
			}
		}
		elm.chatbar.value = str;
		e.preventDefault();
		moveCaretEnd(elm.chatbar);
	}
});

elm.chat_close.addEventListener("click", function() {
	w.emit("chatClose");
	elm.chat_window.style.display = "none";
	elm.chat_open.style.display = "";
	chatOpen = false;
});

elm.chat_open.addEventListener("click", function() {
	w.emit("chatOpen");
	elm.chat_window.style.display = "";
	elm.chat_open.style.display = "none";
	chatOpen = true;
	if(selectedChatTab == 0) {
		chatPageUnread = 0;
		updateUnread();
		if(!initPageTabOpen) {
			initPageTabOpen = true;
			elm.page_chatfield.scrollTop = elm.page_chatfield.scrollHeight;
		}
	} else {
		chatGlobalUnread = 0;
		updateUnread();
		if(!initGlobalTabOpen) {
			initGlobalTabOpen = true;
			elm.global_chatfield.scrollTop = elm.global_chatfield.scrollHeight;
		}
	}
	var chatWidth = chat_window.offsetWidth - 2;
	var chatHeight = chat_window.offsetHeight - 2;
	var screenRatio = window.devicePixelRatio;
	if(!screenRatio) screenRatio = 1;
	var virtWidth = owotWidth / screenRatio;
	if(chatWidth > virtWidth) {
		resizeChat(virtWidth - 2, chatHeight);
	}
});

elm.chat_page_tab.addEventListener("click", function() {
	elm.chat_page_tab.classList.add("chat_tab_selected");
	elm.chat_global_tab.classList.remove("chat_tab_selected");

	elm.global_chatfield.style.display = "none";
	elm.page_chatfield.style.display = "";
	selectedChatTab = 0;
	chatPageUnread = 0;
	updateUnread();
	if(!initPageTabOpen) {
		initPageTabOpen = true;
		elm.page_chatfield.scrollTop = elm.page_chatfield.scrollHeight;
	}
});

elm.chat_global_tab.addEventListener("click", function() {
	elm.chat_global_tab.classList.add("chat_tab_selected");
	elm.chat_page_tab.classList.remove("chat_tab_selected");

	elm.global_chatfield.style.display = "";
	elm.page_chatfield.style.display = "none";
	selectedChatTab = 1;
	chatGlobalUnread = 0;
	updateUnread();
	if(!initGlobalTabOpen) {
		initGlobalTabOpen = true;
		elm.global_chatfield.scrollTop = elm.global_chatfield.scrollHeight;
	}
});

function resizable_chat() {
	var state = 0;
	var isDown = false;
	var downX = 0;
	var downY = 0;
	var elmX = 0;
	var elmY = 0;
	var chatWidth = 0;
	var chatHeight = 0;
	chat_window.addEventListener("mousemove", function(e) {
		if(isDown) return;
		var posX = e.pageX - chat_window.offsetLeft;
		var posY = e.pageY - chat_window.offsetTop;
		var top = (posY) <= 4;
		var left = (posX) <= 3;
		var right = (chat_window.offsetWidth - posX) <= 4;
		var bottom = (chat_window.offsetHeight - posY) <= 5;
		var cursor = "";
		if(left || right) cursor = "ew-resize";
		if(top || bottom) cursor = "ns-resize";
		if((top && left) || (right && bottom)) cursor = "nwse-resize";
		if((bottom && left) || (top && right)) cursor = "nesw-resize";
		chat_window.style.cursor = cursor;
		state = bottom << 3 | right << 2 | left << 1 | top;
	});
	chat_window.addEventListener("mousedown", function(e) {
		downX = e.pageX;
		downY = e.pageY;
		if(state) {
			// subtract 2 for the borders
			chatWidth = chat_window.offsetWidth - 2;
			chatHeight = chat_window.offsetHeight - 2;
			elmX = chat_window.offsetLeft;
			elmY = chat_window.offsetTop;
			isDown = true;
			chatResizing = true;
		}
	});
	document.addEventListener("mouseup", function() {
		isDown = false;
		chatResizing = false;
	});
	document.addEventListener("mousemove", function(e) {
		if(!isDown) return;
		var offX = e.pageX - downX;
		var offY = e.pageY - downY;
		var resize_bottom = state >> 3 & 1;
		var resize_right = state >> 2 & 1;
		var resize_left = state >> 1 & 1;
		var resize_top = state & 1;

		var width_delta = 0;
		var height_delta = 0;
		var abs_top = chat_window.offsetTop;
		var abs_left = chat_window.offsetLeft;
		var snap_bottom = chat_window.style.bottom == "0px";
		var snap_right = chat_window.style.right == "0px";

		if(resize_top) {
			height_delta = -offY;
		} else if(resize_bottom) {
			height_delta = offY;
		}
		if(resize_left) {
			width_delta = -offX;
		} else if(resize_right) {
			width_delta = offX;
		}
		var res = resizeChat(chatWidth + width_delta, chatHeight + height_delta);
		if(resize_top && !snap_bottom) {
			chat_window.style.top = (elmY + (chatHeight - res[1])) + "px";
		}
		if(resize_bottom && snap_bottom) {
			chat_window.style.bottom = "";
			chat_window.style.top = abs_top + "px";
		}
		if(resize_right && snap_right) {
			chat_window.style.right = "";
			chat_window.style.left = abs_left + "px";
		}
		if(resize_left && !snap_right) {
			chat_window.style.left = (elmX + (chatWidth - res[0])) + "px";
		}
	});
}

function evaluateChatfield(chatfield) {
	var field;
	if(chatfield == "page") {
		field = elm.page_chatfield;
	} else if(chatfield == "global") {
		field = elm.global_chatfield;
	} else {
		field = getChatfield();
	}
	return field;
}

/*
	[type]:
	* "user"	  :: registered non-renamed nick
	* "anon_nick" :: unregistered nick
	* "anon"	  :: unregistered
	* "user_nick" :: registered renamed nick
*/
function addChat(chatfield, id, type, nickname, message, realUsername, op, admin, staff, color, date, dataObj) {
	if(!dataObj) dataObj = {};
	if(!nickname) nickname = "";
	if(!message) message = "";
	if(!realUsername) realUsername = "";
	if(!color) color = assignColor(nickname);
	var dateStr = "";
	if(date) dateStr = convertToDate(date);
	var field = evaluateChatfield(chatfield);
	var pm = dataObj.privateMessage;
	var isGreen = false;

	if(chatLimitCombChars) {
		message = w.split(message);
		for(var i = 0; i < message.length; i++) {
			message[i] = message[i].slice(0, 5);
		}
		message = message.join("");
	}

	if(chatGreentext && message[0] == ">" && !(":;_-".includes(message[1]))) { // exception to some emoticons
		message = message.substr(1);
		isGreen = true;
	}

	if(!op) {
		message = html_tag_esc(message);
		nickname = html_tag_esc(nickname);
	}

	// do not give the tag to [ Server ]
	var hasTagDom = (op || admin || staff || dataObj.rankName) && !(!id && op);

	var tagDom;
	var nickTitle = [];

	if(type == "user" || type == "user_nick") {
		nickTitle.push("ID " + id);
	}

	if(hasTagDom) {
		tagDom = document.createElement("span");
		if(dataObj.rankName) {
			tagDom.innerHTML = "(" + dataObj.rankName + ")";
			tagDom.style.color = dataObj.rankColor;
			tagDom.style.fontWeight = "bold";
			nickTitle.push(dataObj.rankName);
		} else if(op) {
			tagDom.innerHTML = "(OP)";
			tagDom.style.color = "#0033cc";
			tagDom.style.fontWeight = "bold";
			nickTitle.push("Operator");
		} else if(admin) {
			tagDom.innerHTML = "(A)";
			tagDom.style.color = "#FF0000";
			tagDom.style.fontWeight = "bold";
			nickTitle.push("Administrator");
		} else if(staff) {
			tagDom.innerHTML = "(M)";
			tagDom.style.color = "#009933";
			tagDom.style.fontWeight = "bold";
			nickTitle.push("Staff");
		}
		tagDom.innerHTML += "&nbsp;";
	}

	var idTag = "";

	var nickDom = document.createElement("a");
	nickDom.style.textDecoration = "underline";

	if(type == "user") {
		nickDom.style.color = color;
		nickDom.style.fontWeight = "bold";
		nickDom.style.pointerEvents = "default";
		if(state.userModel.is_operator) idTag = "[" + id + "]";
	}
	if(type == "anon_nick") {
		idTag = "[*" + id + "]"
	}
	if(type == "anon") {
		idTag = "[" + id + "]"
	}
	if(type == "user_nick") {
		nickDom.style.color = color;
		nickTitle.push("Username \"" + realUsername + "\"");
		if(state.userModel.is_operator) idTag = "[*" + id + "]";
	}

	if(state.userModel.is_operator) {
		idTag = "<span style=\"color: black; font-weight: normal;\">" + idTag + "</span>"
	}

	if(idTag && type != "anon") idTag += "&nbsp;"; // space between id and name

	if(id == 0) {
		idTag = "";
		nickname = "<span style=\"background-color: #e2e2e2;\">" + nickname + "</span>";
	}

	nickname = idTag + nickname;

	if(dateStr) nickTitle.push("(" + dateStr + ")");

	nickDom.innerHTML = nickname + (pm == "to_me" ? "" : ":");
	if(nickTitle.length) nickDom.title = nickTitle.join("; ");

	var pmDom = null;
	if(pm) {
		pmDom = document.createElement("div");
		pmDom.style.display = "inline";
		if(pm == "to_me") {
			pmDom.innerText = " -> Me:";
		} else if(pm == "from_me") {
			pmDom.innerText = "Me -> ";
		}
	}

	if(isGreen) {
		message = "<span style=\"color: #789922\">&gt;" + message + "</span>";
	}

	var msgDom = document.createElement("span");
	msgDom.innerHTML = "&nbsp;" + message;

	var maxScroll = field.scrollHeight - field.clientHeight;
	var scroll = field.scrollTop;
	var doScrollBottom = false;
	if(maxScroll - scroll < 20) { // if scrolled at least 20 pixels above bottom
		doScrollBottom = true;
	}

	var chatGroup = document.createElement("div");
	if(!pm && hasTagDom) chatGroup.appendChild(tagDom);
	if(pmDom) {
		if(pm == "to_me") {
			if(hasTagDom) chatGroup.appendChild(tagDom);
			chatGroup.appendChild(nickDom);
			chatGroup.appendChild(pmDom);
		} else if(pm == "from_me") {
			chatGroup.appendChild(pmDom);
			if(hasTagDom) chatGroup.appendChild(tagDom);
			chatGroup.appendChild(nickDom);
		}
	} else {
		chatGroup.appendChild(nickDom);
	}
	chatGroup.appendChild(msgDom);

	field.appendChild(chatGroup);

	maxScroll = field.scrollHeight - field.clientHeight;
	if(doScrollBottom) {
		field.scrollTop = maxScroll;
	}
	chatRecords.push({
		id: id, date: date, field: field,
		element: chatGroup
	});
}

function removeChatByIdAndDate(id, date) {
	if(!acceptChatDeletions) return;
	for(var i = 0; i < chatRecords.length; i++) {
		var r = chatRecords[i];
		if(r.id == id && r.date == date) {
			var elm = r.element;
			elm.remove();
		}
	}
}

function addUnreadChatBar(chatfield, message, checkSituation) {
	var field = evaluateChatfield(chatfield);
	if(checkSituation) {
		var maxScroll = field.scrollHeight - field.clientHeight;
		var scroll = field.scrollTop;
		var remScroll = maxScroll - scroll;
		if(chatfield == "page") {
			if(chatPageUnreadBar || selectedChatTab == 0) return;
		}
		if(chatfield == "global") {
			if(chatGlobalUnreadBar || selectedChatTab == 1) return;
		}
	}
	var msg = "New messages";
	if(message) msg = message;
	var bar = document.createElement("div");
	var barText = document.createElement("span");
	bar.className = "unread_bar";
	barText.className = "unread_bar_msg";
	barText.innerText = msg;
	bar.appendChild(barText);
	field.appendChild(bar);
	return bar;
}

function getChatfield() {
	if(selectedChatTab == 0) {
		return elm.page_chatfield;
	} else if(selectedChatTab == 1) {
		return elm.global_chatfield;
	}
}

function updateUserCount() {
	var count = w.userCount;
	if(count == void 0) {
		elm.usr_online.innerText = "";
		return;
	}
	var unit = "user";
	var units = "users";
	var current_unit;
	if(count == 1) {
		current_unit = unit;
	} else {
		current_unit = units;
	}
	elm.usr_online.innerText = count + " " + current_unit + " online";
}

function chatType(registered, nickname, realUsername) {
	var nickMatches = (nickname + "").toUpperCase() == (realUsername + "").toUpperCase();
	if(realUsername == "[ Server ]") return "user";
	var type = "";
	if(registered && nickMatches) type = "user";
	if(registered && !nickMatches) type = "user_nick";
	if(!registered && !nickname) type = "anon";
	if(!registered && nickname) type = "anon_nick";
	return type;
}
		</script>
		<script>
var YourWorld = {
	Color: window.localStorage ? +localStorage.getItem("color") : 0,
	Nickname: state.userModel.username
};

var owot, owotCtx, textInput;
var linkElm, linkDiv;
var colorInput;
var colorShortcuts;
function init_dom() {
	owot = document.getElementById("owot");
	owot.style.display = "block";
	owot.style.cursor = defaultCursor;
	owotCtx = owot.getContext("2d");
	textInput = document.getElementById("textInput");
	textInput.value = "";
	linkElm = elm.link_element;
	linkDiv = elm.link_div;
	updateCoordDisplay();
	defineElements({
		owot: owot,
		textInput: textInput
	});
}
function getWndWidth() {
	return document.body.clientWidth || window.innerWidth;
}
function getWndHeight() {
	return document.body.clientHeight || window.innerHeight;
}
function decimal(percentage) {
	return percentage / 100;
}
function normFontSize(size) {
	return Math.floor(size / 0.1) * 0.1;
}
function deviceRatio() {
	var ratio = window.devicePixelRatio;
	if(!ratio) ratio = 1;
	return ratio;
}

var enums = {};
function makeEnum(vars) {
	var enums = {};
	for(var i = 0; i < vars.length; i++) {
		enums[vars[i]] = i;
	}
	return enums;
}

enums.edit = makeEnum(["tileY", "tileX", "charY", "charX", "time", "char", "id", "color"]);
enums.position = makeEnum(["tileX", "tileY", "charX", "charY"]);

var ws_path = createWsPath();

var nextObjId              = 1; // Next edit ID
var owotWidth              = getWndWidth();
var owotHeight             = getWndHeight();
var js_alert_active        = false; // JS alert window is open
var worldFocused           = false;
var chatResizing           = false;
var tiles                  = {}; // All loaded tiles
var images                 = {}; // { name: [data RGBA, width, height] }
var keysPressed            = {};
var previousErase          = 0;
var verticalEnterPos       = [0, 0]; // position to go when pressing enter (tileX, charX)
var lastX                  = verticalEnterPos; // Deprecated; temp compat
var imgPatterns            = {};
var tileCanvasPool         = [];
var textColorOverride      = 0; // public-member-owner bitfield
var writeBuffer            = [];
var highlightFlash         = {};
var highlightCount         = 0;
var coloredChars           = {}; // highlighted chars
var shiftOptState          = { prevX: 0, prevY: 0, x1: 0, y1: 0, x2: 0, y2: 0, prevZoom: -1 };
var backgroundImage        = null;
var backgroundPattern      = null;
var backgroundPatternSize  = [0, 0];
var guestCursorsByTile     = {};
var guestCursors           = {};
var clientGuestCursorPos   = { tileX: 0, tileY: 0, charX: 0, charY: 0, hidden: false, updated: false };
var disconnectTimeout      = null;
var menuOptions            = {};
var undoBuffer             = new CircularBuffer(2048);

// configuration
var positionX              = 0; // client position in pixels
var positionY              = 0;
var coordSizeX             = 4;
var coordSizeY             = 4;
var gridEnabled            = false;
var subgridEnabled         = false; // character-level grid
var linksEnabled           = true;
var linksRendered          = true;
var colorsEnabled          = true;
var backgroundEnabled      = true; // render backgrounds if any
var scrollingEnabled       = true;
var zoomRatio              = deviceRatio(); // browser's default zoom ratio
var ws_path                = createWsPath();
var protectPrecision       = 0; // 0 = tile, 1 = char
var checkTileFetchInterval = 300; // how often to check for unloaded tiles (ms)
var zoom                   = decimal(100); // absolute zoom value (product of zoomRatio and userZoom)
var userZoom               = decimal(100); // user zoom setting (menubar zoom)
var unloadTilesAuto        = true; // automatically unload tiles to free up memory
var useHighlight           = true; // highlight new edits
var highlightLimit         = 10; // max chars to highlight at a time
var ansiBlockFill          = true; // fill certain ansi block characters
var colorizeLinks          = true;
var brBlockFill            = false; // render individual dots in braille characters as rectangles
var tileFetchOffsetX       = 0; // offset added to tile fetching and sending coordinates
var tileFetchOffsetY       = 0;
var ignoreCanvasContext    = true; // ignore canvas context menu when right clicking
var elementSnapApprox      = 10; // snapping margin for draggable elements
var mSpecRendering         = true; // render special properties if a certain combining character is included
var combiningCharsEnabled  = true;
var surrogateCharsEnabled  = true;
var defaultCoordLinkColor  = "#008000";
var defaultURLLinkColor    = "#0000FF";
var defaultHighlightColor  = [0xFF, 0xFF, 0x99];
var secureJSLink           = true; // display warning prompt when clicking on javascript links
var secureLink             = true; // display confirmation when clicking on links in a suspicious setting
var priorityOverwriteChar  = false; // (Experimental) prevents characters from lower protection levels from overflowing to higher levels
var pasteDirRight          = true; // move cursor right when writing
var pasteDirDown           = true; // move cursor down after pressing enter
var defaultCursor          = "text";
var defaultDragCursor      = "move";
var fetchClientMargin      = 200;
var classicTileProcessing  = false; // directly process utf32 only
var unloadedPatternPanning = false;
var cursorRenderingEnabled = true;
var guestCursorsEnabled    = true; // render guest cursors
var showMyGuestCursor      = true; // show my cursor to everyone if the world allows it
var unobstructCursor       = false; // render cursor on top of characters that may block it
var shiftOptimization      = false;
var transparentBackground  = true;
var writeFlushRate         = state.worldModel.write_interval;
var bufferLargeChars       = true; // prevents certain large characters from being cut off by the grid
var cursorOutlineEnabled   = false;
var showCursorCoordinates  = false; // show cursor coords in coordinate bar

var keyConfig = {
	reset: "ESC",
	copyColor: "ALT+C",
	copyCharacterText: "CTRL+C",
	copyCharacterMouse: "CTRL+M",
	sidewaysScroll: "SHIFT",
	tab: "TAB",
	autoSelect: "CTRL",
	autoApply: ["CTRL+S", "ALT+S"],
	autoDeselect: "SHIFT",
	erase: "BACKSPACE+*",
	cellErase: "DELETE+*",
	cursorUp: "UP+*",
	cursorDown: "DOWN+*",
	cursorLeft: "LEFT+*",
	cursorRight: "RIGHT+*",
	copyRegion: ["ALT+G", "CTRL+A"],
	centerTeleport: "HOME",
	undo: "CTRL+Z",
	redo: ["CTRL+Y", "CTRL+SHIFT+Z"]
};

window.addEventListener("load", function() {
	w.emit("clientLoaded");
});

document.addEventListener("visibilitychange", function() {
	if(!document.hidden && zoom > 0.2) {
		w.redraw();
	}
});

defineElements({ // elm[<name>]
	loading: byId("loading"),
	coord_Y: byId("coord_Y"),
	coord_X: byId("coord_X"),
	tile_Y: byId("tile_Y"),
	tile_X: byId("tile_X"),
	char_Y: byId("char_Y"),
	char_X: byId("char_X"),
	chatbar: byId("chatbar"),
	color_input_form_input: byId("color_input_form_input"),
	protect_precision: byId("protect_precision"),
	announce_container: byId("announce_container"),
	tile_choice: byId("tile_choice"),
	char_choice: byId("char_choice"),
	menu_elm: byId("menu"),
	nav_elm: byId("nav"),
	coords: byId("coords"),
	cursor_coords: byId("cursor_coords"),
	cursor_on: byId("cursor_on"),
	cursor_off: byId("cursor_off"),
	chat_window: byId("chat_window"),
	confirm_js: byId("confirm_js"),
	confirm_js_code: byId("confirm_js_code"),
	main_view: byId("main_view"),
	usr_online: byId("usr_online"),
	link_element: byId("link_element"),
	link_div: byId("link_div"),
	protect_selection: byId("protect_selection")
});

function setRGBColorPicker(r, g, b) {
	colorInput.jscolor.fromRGB(r, g, b);
}

function setColorPickerRandom() {
	var r = Math.floor(Math.random() * 256);
	var g = Math.floor(Math.random() * 256);
	var b = Math.floor(Math.random() * 256);
	setRGBColorPicker(r, g, b);
}

function updateColorPicker() {
	var r = (YourWorld.Color >> 16) & 255;
	var g = (YourWorld.Color >> 8) & 255;
	var b = YourWorld.Color & 255;
	setRGBColorPicker(r, g, b);
}

function updateCoordDisplay() {
	var tileCoordX = -positionX / tileW;
	var tileCoordY = -positionY / tileH;
	var centerY = -Math.floor(tileCoordY / coordSizeY);
	var centerX = Math.floor(tileCoordX / coordSizeX);
	elm.coord_Y.innerText = centerY;
	elm.coord_X.innerText = centerX;

	if (showCursorCoordinates) {
		if (cursorCoords === null) {
			elm.cursor_on.style.display = "none";
			elm.cursor_off.style.display = "";
			return;
		}

		elm.cursor_on.style.display = "";
		elm.cursor_off.style.display = "none";
		[elm.tile_X.innerText,
	     elm.tile_Y.innerText,
		 elm.char_X.innerText,
		 elm.char_Y.innerText] = [...cursorCoords];
	}
}

w.on("cursorMove", updateCoordDisplay);
w.on("cursorHide", updateCoordDisplay);

elm.coords.onclick = function() {
	showCursorCoordinates = !showCursorCoordinates;
	if(showCursorCoordinates) {
		elm.cursor_coords.style.display = "";
		updateCoordDisplay();
	} else {
		elm.cursor_coords.style.display = "none";
		updateCoordDisplay();
	}
}

function createColorButton(color) {
	var celm = document.createElement("span");
	var colorInt = resolveColorValue(color);
	var colorValues = int_to_rgb(colorInt);
	celm.className = "color_btn";
	var hex = int_to_hexcode(colorInt);
	celm.style.backgroundColor = hex;
	celm.title = hex.toUpperCase();
	celm.onclick = function() {
		setRGBColorPicker(colorValues[0], colorValues[1], colorValues[2]);
		w.ui.colorModal.submitForm();
	}
	return celm;
}

function addColorShortcuts() {
	var colors = [
		"#000000",
		"#FF0000",
		"#008000",
		"#0000FF",
		"#FFFFFF"
	];
	for(var i = 0; i < colors.length; i++) {
		var col = colors[i];
		colorShortcuts.appendChild(createColorButton(col));
	}
	var rand = document.createElement("span");
	rand.className = "color_btn";
	rand.style.backgroundColor = "#FFFFFF";
	rand.innerText = "?";
	rand.title = "Random color";
	rand.onclick = setColorPickerRandom;
	colorShortcuts.appendChild(rand);
}

init_dom(); // TODO: put this elsewhere

var draggable_element_mousemove = [];
var draggable_element_mouseup = [];
function draggable_element(dragger, dragged, exclusions, onDrag) {
	if(!dragged) {
		dragged = dragger;
	}
	var elmX = 0;
	var elmY = 0;
	var elmHeight = 0;
	var elmWidth = 0;
	var dragging = false;

	var clickX = 0;
	var clickY = 0;
	dragger.addEventListener("mousedown", function(e) {
		if(exclusions) {
			for(var i = 0; i < exclusions.length; i++) {
				if(closest(e.target, exclusions[i])) {
					return;
				}
			}
		}
		if(!closest(e.target, dragger)) return;
		elmX = dragged.offsetLeft;
		elmY = dragged.offsetTop;
		elmWidth = dragged.offsetWidth;
		elmHeight = dragged.offsetHeight;
		dragging = true;
		clickX = e.pageX;
		clickY = e.pageY;
	});
	// when the element is being dragged
	draggable_element_mousemove.push(function(e, arg_pageX, arg_pageY) {
		if(!dragging) return;
		if(onDrag) {
			if(onDrag() == -1) return;
		}
		dragged.style.top = "";
		dragged.style.bottom = "";
		dragged.style.left = "";
		dragged.style.right = "";

		var diffX = arg_pageX - clickX;
		var diffY = arg_pageY - clickY;

		var newY = elmY + diffY;
		var newX = elmX + diffX;

		dragged.style.top = newY + "px";
		dragged.style.left = newX + "px";
		if(newX <= elementSnapApprox) {
			dragged.style.left = "0px";
		}
		if(newX + elmWidth >= getWndWidth() - elementSnapApprox) {
			dragged.style.left = "";
			dragged.style.right = "0px";
		}
		if(newY <= elementSnapApprox) {
			dragged.style.top = "0px";
		}
		if(newY + elmHeight >= getWndHeight() - elementSnapApprox) {
			dragged.style.top = "";
			dragged.style.bottom = "0px";
		}
	});
	// when the element is released
	draggable_element_mouseup.push(function() {
		dragging = false;
	});
}

function resizeChat(width, height) {
	// default: 400 x 300
	if(width < 350) width = 350;
	if(height < 57) height = 57;
	elm.chat_window.style.width = width + "px";
	elm.chat_window.style.height = height + "px";
	return [width, height];
}

draggable_element(elm.chat_window, null, [
	elm.chatbar, elm.chatsend, elm.chat_close, elm.chat_page_tab, elm.chat_global_tab, elm.page_chatfield, elm.global_chatfield
], function() {
	if(chatResizing) {
		return -1;
	}
});
draggable_element(elm.confirm_js, null, [
	elm.confirm_js_code
]);
resizable_chat();

function getStoredNickname() {
	var nick = YourWorld.Nickname;
	if(window.localStorage && localStorage.getItem) {
		nick = localStorage.getItem("nickname");
	}
	if(!nick) nick = YourWorld.Nickname;
	YourWorld.Nickname = nick;
}
function storeNickname() {
	if(window.localStorage && localStorage.setItem) {
		localStorage.setItem("nickname", YourWorld.Nickname);
	}
}

function getStoredConfig() {
	if(!window.localStorage || !localStorage.getItem) return;
	var conf = localStorage.getItem("config");
	if(!conf) return;
	conf = JSON.parse(conf);
	cursorOutlineEnabled = conf.cursorOutline;
}
function storeConfig() {
	if(!window.localStorage || !localStorage.setItem) return;
	var conf = {
		cursorOutline: cursorOutlineEnabled
	};
	localStorage.setItem("config", JSON.stringify(conf));
}

function loadBackgroundData(cb, timeout_cb) {
	if(!backgroundEnabled || !state.background) {
		return cb();
	}
	var backPath = state.background.path;
	var backImgElm = new Image();
	var error = false;
	var timeout = false;
	var loadTimeout = setTimeout(function() {
		timeout = true;
		cb();
	}, 300);
	backImgElm.src = backPath;
	backImgElm.onload = function() {
		clearTimeout(loadTimeout);
		if(error) {
			if(!timeout) cb();
			return;
		}
		backgroundImage = backImgElm;
		backgroundPattern = owotCtx.createPattern(backImgElm, "repeat");
		backgroundPatternSize = [backImgElm.width, backImgElm.height];
		if(timeout) {
			// if it eventually loads after timing out
			if(timeout_cb) timeout_cb();
		} else {
			cb();
		}
	}
	backImgElm.onerror = function() {
		error = true;
		backImgElm.onload();
	}
}

function keydown_regionSelect(e) {
	if(!checkKeyPress(e, keyConfig.copyRegion) || regionSelectionsActive()) return;
	if(Modal.isOpen) return;
	if(!worldFocused) return;
	e.preventDefault();
	w.regionSelect.startSelection();
}
document.addEventListener("keydown", keydown_regionSelect);

function handleRegionSelection(coordA, coordB, regWidth, regHeight) {
	var tileX = coordA[0];
	var tileY = coordA[1];
	var charX = coordA[2];
	var charY = coordA[3];
	var reg = "";
	var colors = [];
	var links = [];
	var protections = [];
	for(var y = 0; y < regHeight; y++) {
		if(y != 0) {
			reg += "\n";
		}
		for(var x = 0; x < regWidth; x++) {
			var charInfo = getCharInfo(tileX, tileY, charX, charY);
			var char = charInfo.char;
			char = char.replace(/\r|\n|\x1b/g, " ");
			reg += char;
			colors.push(charInfo.color);
			var tile = Tile.get(tileX, tileY);
			var containsLink = false;
			if(tile && tile.properties && tile.properties.cell_props) {
				if(tile.properties.cell_props[charY] && tile.properties.cell_props[charY][charX]) {
					var link = tile.properties.cell_props[charY][charX];
					if(link.link) {
						link = link.link;
						containsLink = true;
						if(link.type == "url") {
							links.push("$u" + "\"" + escapeQuote(link.url) + "\"");
						} else if(link.type == "coord") {
							links.push("$c" + "[" + link.link_tileX + "," + link.link_tileY + "]");
						}
					}
				}
			}
			protections.push(charInfo.protection);
			if(!containsLink) {
				links.push(null);
			}
			charX++;
			if(charX >= tileC) {
				charX = 0;
				tileX++;
			}
		}
		tileX = coordA[0];
		charX = coordA[2];
		charY++;
		if(charY >= tileR) {
			charY = 0;
			tileY++;
		}
	}
	w.ui.selectionModal.open(reg, colors, links, protections, [coordA, coordB]);
	w.emit("regionSelected", {
		a: coordA,
		b: coordB
	});
}

var defaultSizes = {
	// in pixels
	cellW: 10,
	cellH: 18,
	// assigned later
	tileW: null,
	tileH: null,
	// in characters
	tileC: 16, // columns (width)
	tileR: 8 // rows (height)
}
if(state.worldModel.square_chars) defaultSizes.cellW = 18;
if(state.worldModel.half_chars) defaultSizes.cellH = 20;
if(state.worldModel.tileCols) defaultSizes.tileC = state.worldModel.tileCols;
if(state.worldModel.tileRows) defaultSizes.tileR = state.worldModel.tileRows;

var cellWidthPad, tileW, tileH, cellW, cellH, font, specialCharFont, tileC, tileR, tileArea;
var tileWidth, tileHeight; // exact tile dimensions for determining rendering size of tiles
var dTileW, dTileH; // locked tile sizes for background image generation

var fontTemplate = "$px 'Courier New', monospace";
var specialCharFontTemplate = "$px consolas, monospace";

function updateScaleConsts() {
	defaultSizes.tileW = defaultSizes.cellW * defaultSizes.tileC;
	defaultSizes.tileH = defaultSizes.cellH * defaultSizes.tileR;
	dTileW = defaultSizes.tileW;
	dTileH = defaultSizes.tileH;
	cellWidthPad = Math.floor((defaultSizes.cellW - 10) / 2); // X text offset if the cell is wider

	tileW = defaultSizes.tileW * zoom;
	tileH = defaultSizes.tileH * zoom;
	cellW = defaultSizes.cellW * zoom;
	cellH = defaultSizes.cellH * zoom;

	tileWidth = Math.ceil(tileW);
	tileHeight = Math.ceil(tileH);

	var fontSize = normFontSize(16 * zoom);

	font = fontTemplate.replace("$", fontSize);
	specialCharFont = specialCharFontTemplate.replace("$", fontSize);

	textRenderCanvas.width = tileWidth + 5;
	textRenderCanvas.height = tileHeight + 5;
	textRenderCtx.font = font;

	tileC = defaultSizes.tileC;
	tileR = defaultSizes.tileR;
	tileArea = tileC * tileR;
}

var textRenderCanvas;
var textRenderCtx;
function setupTextRenderCtx() {
	if(!textRenderCanvas) {
		textRenderCanvas = document.createElement("canvas");
	} else {
		textRenderCanvas.remove();
		textRenderCanvas = document.createElement("canvas");
	}
	if(transparentBackground) {
		textRenderCtx = textRenderCanvas.getContext("2d");
	} else {
		textRenderCtx = textRenderCanvas.getContext("2d", {
			alpha: false
		});
	}
}

setupTextRenderCtx();
updateScaleConsts();

function reloadRenderer() {
	if(tileCanvasPool.length) {
		removeAllTilesFromPools();
		deleteAllPools();
		w.render(true);
	}
}

// set absolute zoom
function doZoom(percentage) {
	if(percentage < 3) percentage = 3;
	if(percentage > 1000) percentage = 1000;
	percentage = decimal(percentage);
	zoom = percentage;

	if(zoom < 0.20) {
		shiftOptimization = true;
	}
	updateScaleConsts();

	if(tileWidth * tileHeight > 100000000) {
		throw "Memory leak";
	}
	textRenderCanvas.width = tileWidth + 5;
	textRenderCanvas.height = tileHeight + 5;
	textRenderCtx.font = font;

	// change size of invisible link
	linkDiv.style.width = (cellW / zoomRatio) + "px";
	linkDiv.style.height = (cellH / zoomRatio) + "px";

	// rerender everything
	reloadRenderer();
}

// set user zoom
function changeZoom(percentage) {
	positionX /= zoom;
	positionY /= zoom;
	userZoom = percentage / 100;
	if(userZoom < 0.2) userZoom = 0.2;
	if(userZoom > 10) userZoom = 10;
	doZoom(userZoom * deviceRatio() * 100);
	positionX *= zoom;
	positionY *= zoom;
	positionX = Math.trunc(positionX); // remove decimals
	positionY = Math.trunc(positionY);
	w.render();
	setZoombarValue();
}

function setZoombarValue() {
	// zoombar is logarithmic. work in reverse.
	zoombar.value = fromLogZoom(userZoom) * 100;
}

function fromLogZoom(val) {
	if(val <= 1) {
		val = Math.pow(2, -1 / val); 
	} else {
		val = 1 - Math.pow(2, -val);
	}
	return val;
}

function toLogZoom(val) {
	if(val <= 0.5) {
		val = -1 / Math.log2(val);
	} else {
		val = -Math.log2(1 - val);
	}
	return val;
}

function browserZoomAdjust(initial) {
	zoomRatio = deviceRatio();
	var absZoom = zoomRatio * userZoom;
	if(zoom == absZoom && !initial) return false; // if no zoom change is detected, do nothing
	positionX /= zoom;
	positionY /= zoom;
	adjust_scaling_DOM(zoomRatio);
	doZoom(absZoom * 100);
	positionX *= zoom;
	positionY *= zoom;
	positionX = Math.trunc(positionX);
	positionY = Math.trunc(positionY);
	return true;
}

function createTilePool() {
	var pCanv = document.createElement("canvas");
	var pDims = getPoolDimensions(tileWidth, tileHeight);
	var pWidth = pDims[0] * tileWidth;
	var pHeight = pDims[1] * tileHeight;
	pCanv.width = pWidth;
	pCanv.height = pHeight;
	var pCtx = pCanv.getContext("2d");
	var pMap = {};
	var pool = {
		canv: pCanv,
		ctx: pCtx,
		map: pMap,
		width: pDims[0],
		height: pDims[1],
		size: 0
	};
	tileCanvasPool.push(pool);
	return pool;
}

function allocateTile() {
	var pLocated = false;
	var pObj, pTilePos;
	for(var i = 0; i < tileCanvasPool.length; i++) {
		var pool = tileCanvasPool[i];
		var area = pool.width * pool.height;
		if(pool.size >= area) continue;
		var map = pool.map;
		for(var t = 0; t < area; t++) {
			if(map[t]) continue;
			pLocated = true;
			pObj = pool;
			pTilePos = t;
			break;
		}
		if(pLocated) break;
	}
	if(!pLocated) {
		pObj = createTilePool();
		pTilePos = 0;
	}
	var pMap = pObj.map;
	pObj.size++;
	var mapX = pTilePos % pObj.width;
	var mapY = Math.floor(pTilePos / pObj.width);
	var tileObj = {
		pool: pObj,
		x: mapX,
		y: mapY,
		idx: pTilePos,
		poolX: mapX * tileWidth,
		poolY: mapY * tileHeight
	};
	pMap[pTilePos] = tileObj;
	return tileObj;
}

function deallocateTile(obj) {
	var pool = obj.pool;
	var idx = obj.idx;
	if(pool.map[idx]) {
		delete pool.map[idx];
		pool.size--;
	}
}

function reallocateTile(obj) {
	var pX = obj.poolX;
	var pY = obj.poolY;
	var pool = obj.pool;
	deallocateTile(obj);
	var newObj = allocateTile();
	var newPool = newObj.pool;
	var newPX = newObj.poolX;
	var newPY = newObj.poolY;
	// transfer rendered text data if it has moved to a new spot
	if(pX != newPX || pY != newPY || pool != newPool) {
		newPool.ctx.clearRect(newPX, newPY, tileWidth, tileHeight);
		newPool.ctx.drawImage(pool.canv, pX, pY, tileWidth, tileHeight, newPX, newPY, tileWidth, tileHeight);
	}
	return newObj;
}

function deletePool(pool) {
	var canv = pool.canv;
	canv.width = 0;
	canv.height = 0;
	delete pool.canv;
	for(var t in pool.map) {
		delete pool.map[t];
	}
}

function deleteEmptyPools() {
	for(var i = 0; i < tileCanvasPool.length; i++) {
		var pool = tileCanvasPool[i];
		if(pool.size == 0) {
			deletePool(pool);
			tileCanvasPool.splice(i, 1);
			i--;
		}
	}
}

function deleteAllPools() {
	for(var i = 0; i < tileCanvasPool.length; i++) {
		var pool = tileCanvasPool[i];
		deletePool(pool);
		tileCanvasPool.splice(i, 1);
		i--;
	}
}

var tilePixelCache = {};
function loadTileFromPool(tileX, tileY, doNotCreate) {
	var pos = tileY + "," + tileX;
	if(tilePixelCache[pos]) {
		return tilePixelCache[pos];
	}
	if(doNotCreate) return null;
	var newTile = allocateTile();
	tilePixelCache[pos] = newTile;
	return newTile;
}

function shiftAllTilesInPools() {
	if(tileCanvasPool.length <= 1) return;
	for(var tile in tilePixelCache) {
		tilePixelCache[tile] = reallocateTile(tilePixelCache[tile]);
	}
	deleteEmptyPools();
}

function removeTileFromPool(tileX, tileY) {
	var pos = tileY + "," + tileX;
	if(!tilePixelCache[pos]) return;
	deallocateTile(tilePixelCache[pos]);
	delete tilePixelCache[pos];
}

function removeAllTilesFromPools() {
	for(var tile in tilePixelCache) {
		deallocateTile(tilePixelCache[tile]);
		delete tilePixelCache[tile];
	}
}

var tileProtectAuto = {
	selected: {},
	selectedTile: null,
	xPos: 0,
	yPos: 0,
	charXPos: 0,
	charYPos: 0,
	lastPos: null,
	mode: 0,
	ctrlDown: false,
	shiftDown: false,
	clearSelections: function() {
		for(var i in tileProtectAuto.selected) {
			tiles[i].backgroundColor = "";
			delete tileProtectAuto.selected[i];
		}
	},
	active: false
}

var linkAuto = {
	selected: {},
	ctrlDown: 0,
	shiftDown: 0,
	mode: 0,
	url: "",
	coordTileX: 0,
	coordTileY: 0,
	lastPos: null,
	active: false
}

var autoTotal = 0;
function updateAutoProg() {
	if(autoTotal > 0) {
		auto_prog.style.display = "";
	} else {
		auto_prog.style.display = "none";
	}
	auto_prog.innerText = autoTotal + " remaining";
}

// Fast tile protecting
function mousemove_tileProtectAuto() {
	if(!tileProtectAuto.active) return;
	var tile = Tile.get(currentPosition[0], currentPosition[1]);
	if(!tile) return;
	tileProtectAuto.selectedTile = tile;
	var tileX = currentPosition[0];
	var tileY = currentPosition[1];
	var charX = currentPosition[2];
	var charY = currentPosition[3];
	var lastPos = tileProtectAuto.lastPos;
	tileProtectAuto.xPos = tileX;
	tileProtectAuto.yPos = tileY;
	tileProtectAuto.charXPos = charX;
	tileProtectAuto.charYPos = charY;
	if(tileProtectAuto.ctrlDown) {
		var line = null;
		var absX = tileX * tileC + charX;
		var absY = tileY * tileR + charY;
		if(protectPrecision == 0) {
			absX = tileX;
			absY = tileY;
		}
		if(lastPos && lastPos[4] == protectPrecision) {
			var labsX = lastPos[0] * tileC + lastPos[2];
			var labsY = lastPos[1] * tileR + lastPos[3];
			if(protectPrecision == 0) {
				labsX = lastPos[0];
				labsY = lastPos[1];
			}
			line = lineGen(labsX, labsY, absX, absY, 1000);
		} else {
			line = [[absX, absY]];
		}
		tileProtectAuto.lastPos = [tileX, tileY, charX, charY, protectPrecision];
		var updTiles = {};
		for(var i = 0; i < line.length; i++) {
			var chr = line[i];
			var x = chr[0];
			var y = chr[1];
			var ctileX = Math.floor(x / tileC);
			var ctileY = Math.floor(y / tileR);
			var ccharX = x - ctileX * tileC;
			var ccharY = y - ctileY * tileR;
			if(protectPrecision == 0) {
				ctileX = x;
				ctileY = y;
			}
			var tempTile = Tile.get(ctileX, ctileY);
			var mode = tileProtectAuto.mode;
			if(protectPrecision == 0 && tempTile) {
				tileProtectAuto.selected[ctileY + "," + ctileX] =
					[protectPrecision, mode, tempTile];
			} else if(protectPrecision == 1 && tempTile) {
				tileProtectAuto.selected[ctileY + "," + ctileX + "," + ccharY + "," + ccharX] =
					[protectPrecision, mode, tempTile];
			}
			var colors = ["red", "green", "blue", "teal"];
			var color = colors[mode];
			if(protectPrecision == 0) {
				if(tempTile) tempTile.backgroundColor = color;
			} else if(protectPrecision == 1) {
				uncolorChar(ctileX, ctileY, ccharX, ccharY, "qprot*");
				colorChar(ctileX, ctileY, ccharX, ccharY, "qprot" + mode);
			}
			updTiles[ctileY + "," + ctileX] = 1;
		}
		for(var i in updTiles) {
			var pos = i.split(",");
			var tileX = parseInt(pos[1]);
			var tileY = parseInt(pos[0]);
			w.setTileRedraw(tileX, tileY);
		}
	}
	if(tileProtectAuto.shiftDown) {
		var pos = tileY + "," + tileX;
		if(protectPrecision == 1) {
			pos = tileY + "," + tileX + "," + charY + "," + charX;
		}
		if(tileProtectAuto.selected[pos] !== void 0) {
			var precision = tileProtectAuto.selected[pos][0];
			if(precision == 0) {
				tile.backgroundColor = "";
			} else if(precision == 1) {
				uncolorChar(tileX, tileY, charX, charY, "qprot*");
			}
			delete tileProtectAuto.selected[pos];
			w.setTileRender(tileX, tileY);
		}
	}
}
document.addEventListener("mousemove", mousemove_tileProtectAuto);

function keydown_tileProtectAuto(e) {
	if(!worldFocused) return;
	if(checkKeyPress(e, keyConfig.autoApply)) { // Alt/Ctrl + S to protect tiles
		var selected = tileProtectAuto.selected;
		var types = ["owner-only", "member-only", "public"];
		var keys = Object.keys(selected);
		if(keys.length == 0) return;
		e.preventDefault();
		autoTotal += keys.length;
		updateAutoProg();

		var idx = 0;
		function step() {
			var i = keys[idx];
			idx++;
			var pos = i.split(",").map(Number);
			var precision = selected[i][0];
			var prot = selected[i][1];

			var tileX = pos[1];
			var tileY = pos[0];
			var charX = pos[3];
			var charY = pos[2];

			var position = {
				tileY: tileY,
				tileX: tileX
			};
			if(precision == 1) {
				position.charX = charX;
				position.charY = charY;
			}
			var type;
			if(prot == 3) {
				type = "unprotect";
			} else {
				type = types[prot];
			}
			network.protect(position, type);

			autoTotal--;
			updateAutoProg();
			if(precision == 0) {
				selected[i][2].backgroundColor = "";
				delete selected[i];
				w.setTileRender(tileX, tileY);
			} else if(precision == 1) {
				delete selected[i];
				uncolorChar(tileX, tileY, charX, charY, "qprot*");
				w.setTileRedraw(tileX, tileY);
			}

			if(idx >= keys.length) return;
			step();
		}
		step();
	} else {
		var ctrlState = tileProtectAuto.ctrlDown;
		tileProtectAuto.ctrlDown = checkKeyPress(e, keyConfig.autoSelect);
		tileProtectAuto.shiftDown = checkKeyPress(e, keyConfig.autoDeselect);
		if(!ctrlState && tileProtectAuto.ctrlDown) {
			tileProtectAuto.lastPos = null;
		}
	}
}
document.body.addEventListener("keydown", keydown_tileProtectAuto);

// Fast linking
function mousemove_linkAuto() {
	if(!linkAuto.active) return;
	var tile = Tile.get(currentPosition[0], currentPosition[1]);
	if(!tile) return;
	
	var tileX = currentPosition[0];
	var tileY = currentPosition[1];
	var charX = currentPosition[2];
	var charY = currentPosition[3];
	var lastPos = linkAuto.lastPos;

	if(linkAuto.ctrlDown) {
		var line = null;
		var absX = tileX * tileC + charX;
		var absY = tileY * tileR + charY;
		if(lastPos) {
			var labsX = lastPos[0] * tileC + lastPos[2];
			var labsY = lastPos[1] * tileR + lastPos[3];
			line = lineGen(labsX, labsY, absX, absY, 1000);
		} else {
			line = [[absX, absY]];
		}
		linkAuto.lastPos = [tileX, tileY, charX, charY];
		var updTiles = {};
		for(var i = 0; i < line.length; i++) {
			var chr = line[i];
			var x = chr[0];
			var y = chr[1];
			var ctileX = Math.floor(x / tileC);
			var ctileY = Math.floor(y / tileR);
			var ccharX = x - ctileX * tileC;
			var ccharY = y - ctileY * tileR;

			uncolorChar(ctileX, ctileY, ccharX, ccharY, "qlink*");
			colorChar(ctileX, ctileY, ccharX, ccharY, "qlink" + linkAuto.mode);
			updTiles[ctileY + "," + ctileX] = 1;
			var ar = [ctileX, ctileY, ccharX, ccharY, linkAuto.mode];
			if(linkAuto.mode == 0) {
				ar.push([linkAuto.url])
			} else if(linkAuto.mode == 1) {
				ar.push([linkAuto.coordTileX, linkAuto.coordTileY]);
			}
			linkAuto.selected[ctileY + "," + ctileX + "," + ccharY + "," + ccharX] = ar;
		}
		for(var i in updTiles) {
			var pos = i.split(",");
			var tileX = parseInt(pos[1]);
			var tileY = parseInt(pos[0]);
			w.setTileRedraw(tileX, tileY);
		}
	}
	if(linkAuto.shiftDown) {
		var elm = linkAuto.selected[tileY + "," + tileX + "," + charY + "," + charX];
		if(elm !== void 0) {
			uncolorChar(tileX, tileY, charX, charY, "qlink*");
			w.setTileRedraw(tileX, tileY);
			delete linkAuto.selected[tileY + "," + tileX + "," + charY + "," + charX];
		}
	}
}
document.addEventListener("mousemove", mousemove_linkAuto);

function keydown_linkAuto(e) {
	if(!worldFocused) return;
	if(checkKeyPress(e, keyConfig.autoApply)) { // Alt/Ctrl + S to add links
		var selected = linkAuto.selected;
		var keys = Object.keys(selected);
		if(keys.length == 0) return;
		e.preventDefault();
		autoTotal += keys.length;
		updateAutoProg();

		var idx = 0;
		function step() {
			var i = keys[idx];
			idx++;
			var pos = i.split(",").map(Number);
			var tileX = pos[1];
			var tileY = pos[0];
			var charX = pos[3];
			var charY = pos[2];

			var mode = selected[i][4];
			var linkData = selected[i][5];

			var data = {};
			var link_type;
			if(mode == 0) {
				data.url = w.url_input;
				link_type = "url";
				data.url = linkData[0];
			} else if(mode == 1) {
				link_type = "coord";
				data.x = linkData[0];
				data.y = linkData[1];
			}

			network.link({
				tileY: tileY,
				tileX: tileX,
				charY: charY,
				charX: charX
			}, link_type, data);

			autoTotal--;
			updateAutoProg();
			delete selected[i];
			uncolorChar(tileX, tileY, charX, charY, "qlink*");
			w.setTileRedraw(tileX, tileY);

			if(idx >= keys.length) return;
			step(); // (MOD)
		}
		step();
	} else {
		var ctrlState = linkAuto.ctrlDown;
		linkAuto.ctrlDown = checkKeyPress(e, keyConfig.autoSelect);
		linkAuto.shiftDown = checkKeyPress(e, keyConfig.autoDeselect);
		if(!ctrlState && linkAuto.ctrlDown) {
			linkAuto.lastPos = null;
		}
	}
}
document.body.addEventListener("keydown", keydown_linkAuto);

function onKeyUp(e) {
	var sel = checkKeyPress(e, keyConfig.autoSelect);
	var des = checkKeyPress(e, keyConfig.autoDeselect);
	linkAuto.ctrlDown = sel;
	linkAuto.shiftDown = des;
	tileProtectAuto.ctrlDown = sel;
	tileProtectAuto.shiftDown = des;

	if(checkKeyPress(e, keyConfig.cursorUp)) { // arrow up
		autoArrowKeyMoveStop("up");
	}
	if(checkKeyPress(e, keyConfig.cursorDown)) { // arrow down
		autoArrowKeyMoveStop("down");
	}
	if(checkKeyPress(e, keyConfig.cursorLeft)) { // arrow left
		autoArrowKeyMoveStop("left");
	}
	if(checkKeyPress(e, keyConfig.cursorRight)) { // arrow right
		autoArrowKeyMoveStop("right");
	}
	if(checkKeyPress(e, keyConfig.centerTeleport)) { // home
		w.doGoToCoord(0, 0);
	}
}
document.body.addEventListener("keyup", onKeyUp);

function adjust_scaling_DOM(ratio) {
	var window_width = getWndWidth();
	var window_height = getWndHeight();
	// change variable sizes to the screen-width of the inner browser (same, regardless of zoom)
	owotWidth = Math.round(window_width * ratio);
	owotHeight = Math.round(window_height * ratio);
	// make size of canvas the size of the inner browser screen-size
	elm.owot.width = Math.round(window_width * ratio);
	elm.owot.height = Math.round(window_height * ratio);
	// make the display size the size of the viewport
	elm.owot.style.width = window_width + "px";
	elm.owot.style.height = window_height + "px";
	if(shiftOptimization) {
		shiftOptState.zoom = -1;
	}
}

function event_resize() {
	var ratio = deviceRatio();
	if(!ratio) ratio = 1;
	w.emit("resize", ratio);
	if(!browserZoomAdjust()) {
		adjust_scaling_DOM(ratio);
	}
	w.render();
}
window.addEventListener("resize", event_resize);

browserZoomAdjust(true);

function getChar(tileX, tileY, charX, charY) {
	if(tileX == void 0 && tileY == void 0 && charX == void 0 && charY == void 0) {
		if(!cursorCoords) return -1;
		tileX = cursorCoords[0];
		tileY = cursorCoords[1];
		charX = cursorCoords[2];
		charY = cursorCoords[3];
	}
	var tile = Tile.get(tileX, tileY);
	if(!tile) return " ";
	var content = tile.content;
	return content[charY * tileC + charX];
}

function getCharColor(tileX, tileY, charX, charY) {
	if(tileX == void 0 && tileY == void 0 && charX == void 0 && charY == void 0) {
		if(!cursorCoords) return -1;
		tileX = cursorCoords[0];
		tileY = cursorCoords[1];
		charX = cursorCoords[2];
		charY = cursorCoords[3];
	}
	var tile = Tile.get(tileX, tileY);
	if(!tile) return 0;
	if(!tile.properties.color) return 0;
	return tile.properties.color[charY * tileC + charX];
}

function getCharProtection(tileX, tileY, charX, charY) {
	if(tileX == void 0 && tileY == void 0 && charX == void 0 && charY == void 0) {
		if(!cursorCoords) return -1;
		tileX = cursorCoords[0];
		tileY = cursorCoords[1];
		charX = cursorCoords[2];
		charY = cursorCoords[3];
	}
	var tile = Tile.get(tileX, tileY);
	if(!tile) return state.worldModel.writability;
	var prot = tile.properties.writability;
	if(tile.properties && tile.properties.char) {
		prot = tile.properties.char[charY * tileC + charX];
		// null indicates that it inherits writability from its parent
		if(prot == null) prot = tile.properties.writability;
	}
	if(prot == null) prot = state.worldModel.writability;
	return prot;
}

function getCharInfo(tileX, tileY, charX, charY) {
	if(tileX == void 0 && tileY == void 0 && charX == void 0 && charY == void 0) {
		if(!cursorCoords) return -1;
		tileX = cursorCoords[0];
		tileY = cursorCoords[1];
		charX = cursorCoords[2];
		charY = cursorCoords[3];
	}
	return {
		loaded: isTileLoaded(tileX, tileY),
		char: getChar(tileX, tileY, charX, charY),
		color: getCharColor(tileX, tileY, charX, charY),
		protection: getCharProtection(tileX, tileY, charX, charY)
	};
}

function getCharInfoXY(x, y) {
	var tileX = Math.floor(x / tileC);
	var tileY = Math.floor(y / tileR);
	var charX = x - tileX * tileC;
	var charY = y - tileY * tileR;
	return getCharInfo(tileX, tileY, charX, charY);
}

function getLink(tileX, tileY, charX, charY) {
	if(!Tile.get(tileX, tileY)) return null;
	var tile = Tile.get(tileX, tileY);
	if(!tile) return null;
	var props = tile.properties.cell_props;
	if(!props) return null;
	if(!props[charY]) return null;
	if(!props[charY][charX]) return null;
	if(!props[charY][charX].link) return null;
	return props[charY][charX].link;
}

function getLinkXY(x, y) {
	var tileX = Math.floor(x / tileC);
	var tileY = Math.floor(y / tileR);
	var charX = x - tileX * tileC;
	var charY = y - tileY * tileR;
	return getLink(tileX, tileY, charX, charY);
}

// copy individual chars
function event_keydown_copy_char(e) {
	if(Modal.isOpen) return;
	if(!worldFocused) return;
	if(document.activeElement.tagName == "INPUT" && document.activeElement.type == "text" && document.activeElement != elm.textInput) return;
	var textCursorCopy = checkKeyPress(e, keyConfig.copyCharacterText);
	var mouseCursorCopy = checkKeyPress(e, keyConfig.copyCharacterMouse);
	if(!textCursorCopy && !mouseCursorCopy) return;
	stopPasting();
	// ctrl + c to copy characters where the text cursor is,
	// ctrl + m to copy characters where the mouse cursor is
	var pos_ref = cursorCoords;
	if(mouseCursorCopy) { // copy where mouse cursor is
		pos_ref = currentPosition;
	}
	if(!pos_ref) return;
	var tileX = pos_ref[0];
	var tileY = pos_ref[1];
	var charX = pos_ref[2];
	var charY = pos_ref[3];
	var char = getChar(tileX, tileY, charX, charY);
	char = char.replace(/\r|\n/g, " ");
	w.clipboard.copy(char);
}
document.addEventListener("keydown", event_keydown_copy_char);

// color picker
function event_keydown_copy_color(e) {
	if(!worldFocused) return;
	if(!checkKeyPress(e, keyConfig.copyColor)) return;
	stopPasting();
	// alt + c to use color of text cell (where mouse cursor is) as main color
	var pos = currentPosition;
	if(!pos) return;
	var tileX = pos[0];
	var tileY = pos[1];
	var charX = pos[2];
	var charY = pos[3];
	var color = getCharColor(tileX, tileY, charX, charY);
	w.changeColor(color);
}
document.addEventListener("keydown", event_keydown_copy_color);

// convert color value to rgb24 int
function resolveColorValue(val) {
	if(typeof val == "number") {
		if(!isFinite(val)) return 0;
		if(isNaN(val)) return 0;
		val = Math.trunc(val);
		if(val < 0) return 0;
		if(val > 16777215) return 16777215;
		return val;
	}
	if(typeof val != "string" || !val) return 0;
	var orig = val;
	if(val[0] == "#") val = val.substr(1);
	if(isHexString(val)) {
		if(val.length == 3) {
			return parseInt(val[0] + val[0] + val[1] + val[1] + val[2] + val[2], 16);
		} else if(val.length == 6) {
			return parseInt(val, 16);
		}
	}
	var num = parseInt(val);
	if(!isNaN(num)) {
		num = Math.trunc(num);
		if(num < 0) num = 0;
		if(num > 16777215) num = 16777215;
		return num;
	}
	owotCtx.fillStyle = "#000000";
	owotCtx.fillStyle = orig;
	var fs = owotCtx.fillStyle;
	if(fs[0] == "#" && fs.length == 7) {
		return parseInt(fs.substr(1).slice(0, 6), 16);
	}
	return 0;
}

var cursorCoords = null; // [tileX, tileY, charX, charY]; Coordinates of text cursor. If mouse is deselected, the value is null.
var cursorCoordsCurrent = [0, 0, 0, 0, -1]; // [tileX, tileY, charX, charY]; cursorCoords that don't reset to null.
var currentPosition = [0, 0, 0, 0]; // [tileX, tileY, charX, charY]; Tile and char coordinates where mouse cursor is located.
var currentPositionInitted = false;
var currentMousePosition = [0, 0, 0, 0]; // [x, y, pageX, pageY]; Position of mouse cursor.

var Tile = {};
Tile.set = function(tileX, tileY, data) {
	var str = tileY + "," + tileX;
	if(!(str in tiles)) {
		w.tile.count++;
	}
	tiles[str] = data;
	return data;
}
Tile.delete = function(tileX, tileY) {
	var str = tileY + "," + tileX;
	removeTileFromPool(tileX, tileY);
	w.periodDeletedTiles++;
	if(str in tiles) {
		delete tiles[str];
		w.tile.count--;
	}
}
Tile.get = function(tileX, tileY) {
	var tile = tiles[tileY + "," + tileX];
	return tile;
}
// does this tile exist (or is reserved) in memory?
Tile.exists = function(tileX, tileY) {
	var str = tileY + "," + tileX;
	return str in tiles;
}
// is this tile fully loaded?
Tile.loaded = function(tileX, tileY) {
	return !!Tile.get(tileX, tileY);
}
Tile.visible = function(tileX, tileY) {
	var tilePosX = tileX * tileW + positionX + Math.trunc(owotWidth / 2);
	var tilePosY = tileY * tileH + positionY + Math.trunc(owotHeight / 2);
	// too far left/top. check if the right/bottom edge of tile is also too far left/top
	if((tilePosX < 0 || tilePosY < 0) && (tilePosX + tileW - zoom < 0 || tilePosY + tileH - zoom < 0)) {
		return false;
	}
	// too far right/bottom
	if(tilePosX >= owotWidth || tilePosY >= owotHeight) {
		return false;
	}
	return true;
}

var poolCleanupInterval = setInterval(function() {
	if(w.periodDeletedTiles < 50) return;
	w.periodDeletedTiles = 0;
	shiftAllTilesInPools();
}, 1000 * 10);

// deprecated
var textLayerCtx = owotCtx;

function createWsPath() {
	var search = window.location.search;
	if(!search) search = "";
	return "ws" + (window.location.protocol == "https:" ? "s" : "") + "://" + window.location.host + state.worldModel.pathname + "/ws/" + search;
}

function checkTextColorOverride() {
	var public = 4;
	var member = 2;
	var owner = 1;
	// if custom text color is set to a zone, use that color instead of default
	if(styles.public_text != "#000" && styles.public_text != "#000000") {
		textColorOverride |= public;
	} else {
		textColorOverride &= textColorOverride ^ public;
	}
	if(styles.member_text != "#000" && styles.member_text != "#000000") {
		textColorOverride |= member;
	} else {
		textColorOverride &= textColorOverride ^ member;
	}
	if(styles.owner_text != "#000" && styles.owner_text != "#000000") {
		textColorOverride |= owner;
	} else {
		textColorOverride &= textColorOverride ^ owner;
	}
}
var styles = null;

var menuStyle;
function menu_color(color) {
	if(color.toLowerCase() == "#e5e5ff") {
		if(window.menuStyle) {
			window.menuStyle.remove();
			window.menuStyle = null;
		}
		return;
	}
	// change menu color
	if(!window.menuStyle) {
		menuStyle = document.createElement("style");
		document.head.appendChild(menuStyle);
	}
	var rgb = int_to_rgb(resolveColorValue(color));
	var value = Math.max(rgb[0], rgb[1], rgb[2]);
	var bDelta = 25;
	var hDelta = 35;
	var tColor = "#CCCCCC";
	if(value > 128) {
		bDelta = -25;
		hDelta = -35;
		tColor = "#000000";
	}
	var bRgb = [
		Math.max(0, rgb[0] + bDelta),
		Math.max(0, rgb[1] + bDelta),
		Math.max(0, rgb[2] + bDelta)
	];
	var hRgb = [
		Math.min(255, rgb[0] + hDelta),
		Math.min(255, rgb[1] + hDelta),
		Math.min(255, rgb[2] + hDelta)
	];
	var bColor = int_to_hexcode(rgb_to_int(bRgb[0], bRgb[1], bRgb[2]));
	var hColor = int_to_hexcode(rgb_to_int(hRgb[0], hRgb[1], hRgb[2]));
	menuStyle.innerHTML = "#menu.hover, #nav {" +
			"background: " + color + ";" +
			"border-color: " + bColor + ";" +
			"color: " + tColor + ";" +
		"}\n" +
			"#nav li {" +
			"border-top-color: " + bColor + ";" +
		"}\n" +
		"#nav li.hover {" +
			"background-color: " + hColor + ";" +
		"}\n" +
		"#coords {" +
			"background-color: " + bColor + ";" +
			"color: " + tColor + ";" +
		"}";
}

function defaultStyles() {
	return {
		owner: "#ddd",
		member: "#eee",
		public: "#fff",
		cursor: "#ff0",
		guestCursor: "#ffa",
		text: "#000",
		menu: "#e5e5ff",
		public_text: "#000",
		member_text: "#000",
		owner_text: "#000"
	};
}

function manageCoordHash() {
	if(!Permissions.can_go_to_coord(state.userModel, state.worldModel)) return;
	try {
		var coord = window.location.hash.match(/#x:-?\d+,y:-?\d+$/);
		if(coord) {
			coord = window.location.hash.split(/#x:|,y:/).slice(1).map(function(a) {
				return parseInt(a, 10);
			});
			w.doGoToCoord(coord[1], coord[0]);
		}
	} catch(e) {
		console.log(e);
	}
}

// type: "style" or "props"
// callback: function(style, error)
function getWorldProps(world, type, cb) {
	if(!type) type = "style";
	var propUrl;
	if(type == "style") {
		propUrl = "/world_style/";
	} else if(type == "props") {
		propUrl = "/world_props/";
	} else {
		console.error("Invalid type: " + type);
		return cb(null, true);
	}
	if(window.location.search) {
		propUrl += window.location.search + "&world=" + world;
	} else {
		propUrl += "?world=" + world;
	}
	ajaxRequest({
		type: "GET",
		url: propUrl,
		done: function(data) {
			try {
				data = JSON.parse(data);
			} catch(e) {
				return cb(null, true);
			}
			cb(data, false);
		},
		error: function() {
			cb(null, true);
		}
	});
}

function stopLinkUI() {
	if(!lastLinkHover) return;
	if(!w.isLinking) return;
	w.isLinking = false;
	linkAuto.active = false;
	elm.owot.style.cursor = defaultCursor;
	var tileX = lastLinkHover[0];
	var tileY = lastLinkHover[1];
	var charX = lastLinkHover[2];
	var charY = lastLinkHover[3];
	// remove highlight
	uncolorChar(tileX, tileY, charX, charY, "link");
	w.setTileRedraw(tileX, tileY);
}

function removeTileProtectHighlight() {
	if(!lastTileHover) return;
	var precision = lastTileHover[0];
	var tileX = lastTileHover[1];
	var tileY = lastTileHover[2];
	var charX = lastTileHover[3];
	var charY = lastTileHover[4];

	if(Tile.get(tileX, tileY)) {
		if(precision == 0) {
			Tile.get(tileX, tileY).backgroundColor = "";
		} else if(precision == 1) {
			uncolorChar(tileX, tileY, charX, charY, "prot");
		}
	}
	w.setTileRedraw(tileX, tileY);
}

function stopTileUI() {
	if(!lastTileHover) return;
	if(!w.isProtecting) return;
	elm.protect_precision.style.display = "none";
	w.isProtecting = false;
	tileProtectAuto.active = false;
	tileProtectAuto.lastPos = null;
	elm.owot.style.cursor = defaultCursor;
	removeTileProtectHighlight();
}

function doLink() {
	if(!lastLinkHover) return;
	stopLinkUI();
	var tileX = lastLinkHover[0];
	var tileY = lastLinkHover[1];
	var charX = lastLinkHover[2];
	var charY = lastLinkHover[3];
	var data = {};
	var link_type;
	if(w.link_input_type == 0) {
		data.url = w.url_input;
		link_type = "url";
	} else if(w.link_input_type == 1) {
		data.x = w.coord_input_x;
		data.y = w.coord_input_y;
		link_type = "coord";
	}
	network.link({
		tileY: tileY,
		tileX: tileX,
		charY: charY,
		charX: charX
	}, link_type, data);
}

function doProtect() {
	if(!lastTileHover) return;
	stopTileUI();
	var tileX = lastTileHover[1];
	var tileY = lastTileHover[2];
	var types = ["public", "member-only", "owner-only"];
	var position = {
		tileY: tileY,
		tileX: tileX
	};
	var action;
	if(w.protect_type == null) {
		action = "unprotect";
	} else {
		action = types[w.protect_type];
	}
	if(protectPrecision == 1) {
		position.charX = lastTileHover[3];
		position.charY = lastTileHover[4];
	}
	network.protect(position, action);
}

var dragStartX = 0;
var dragStartY = 0;
// the offset before clicking to drag
var dragPosX = 0;
var dragPosY = 0;
var isDragging = false;
var hasDragged = false;
var draggingEnabled = true;
function event_mousedown(e, arg_pageX, arg_pageY) {
	currentMousePosition[0] = e.pageX;
	currentMousePosition[1] = e.pageY;
	var target = e.target;
	if(closest(target, getChatfield()) || target == elm.chatbar || target == elm.confirm_js_code) {
		worldFocused = false;
	} else {
		worldFocused = true;
	}

	var pageX = Math.trunc(e.pageX * zoomRatio);
	var pageY = Math.trunc(e.pageY * zoomRatio);
	if(arg_pageX != void 0) pageX = arg_pageX;
	if(arg_pageY != void 0) pageY = arg_pageY;
	if(target != elm.owot && target != linkDiv) {
		return;
	}
	if(draggingEnabled) {
		dragStartX = pageX;
		dragStartY = pageY;
		dragPosX = positionX;
		dragPosY = positionY;
		isDragging = true;
	}
	stopPasting();
	if(w.isLinking) {
		doLink();
	}
	if(!w.protectSelect.isSelecting && w.isProtecting) {
		doProtect();
	}
	var foundActiveSelection = false;
	for(var i = 0; i < regionSelections.length; i++) {
		var reg = regionSelections[i];
		if(reg.isSelecting) {
			reg.regionCoordA = currentPosition;
			reg.show();
			reg.setSelection(reg.regionCoordA, reg.regionCoordA);
			foundActiveSelection = true;
		}
	}
	if(foundActiveSelection) return;
	var pos = getTileCoordsFromMouseCoords(pageX, pageY);
	w.emit("mouseDown", {
		tileX: pos[0],
		tileY: pos[1],
		charX: pos[2],
		charY: pos[3],
		pageX: pageX,
		pageY: pageY
	});
	elm.owot.style.cursor = defaultDragCursor;
	w.menu.hideNow();
}
document.addEventListener("mousedown", event_mousedown);

function event_touchstart(e) {
	var pos = touch_pagePos(e);
	touchPosX = pos[0];
	touchPosY = pos[1];
	event_mousemove(e, touchPosX, touchPosY);
	if(w.isProtecting) {
		var cp = currentPosition;
		lastTileHover = [protectPrecision, cp[0], cp[1], cp[2], cp[3]];
	}
	if(w.isLinking) {
		lastLinkHover = currentPosition;
	}
	event_mousedown(e, pos[0], pos[1]);
}
document.addEventListener("touchstart", event_touchstart, { passive: false });

// change cursor position
function renderCursor(coords) {
	var newTileX = coords[0];
	var newTileY = coords[1];
	var tile = Tile.get(newTileX, newTileY);
	if(!tile) return false;
	var writability = tile.properties.writability;
	var thisTile = {
		writability: writability,
		char: tile.properties.char
	}
	var tileX = 0;
	var tileY = 0;
	if(cursorCoords) {
		tileX = cursorCoords[0];
		tileY = cursorCoords[1];
	}
	var selCharX = coords[2];
	var selCharY = coords[3];
	if(!Permissions.can_edit_tile(state.userModel, state.worldModel, thisTile, selCharX, selCharY)) {
		removeCursor();
		return false;
	}

	if(cursorCoords) {
		cursorCoords = null;
		w.setTileRender(tileX, tileY);
	} else {
		w.emit("cursorShow", {
			tileX: coords[0],
			tileY: coords[1],
			charX: coords[2],
			charY: coords[3]
		});
	}
	cursorCoords = coords.slice(0);
	cursorCoordsCurrent = coords.slice(0);
	w.setTileRender(coords[0], coords[1]);

	var pixelX = (coords[0] * tileW) + (coords[2] * cellW) + positionX + Math.trunc(owotWidth / 2);
	var pixelY = (coords[1] * tileH) + (coords[3] * cellH) + positionY + Math.trunc(owotHeight / 2);
	
	var diff = null;
	// keep record of old positions to check if they changed
	var posXCompare = positionX;
	var posYCompare = positionY;

	if(pixelX < 0) { // cursor too far left
		diff = Math.abs(pixelX);
		positionX += diff;
	}
	if(pixelX + cellW >= owotWidth) { // cursor too far right
		diff = owotWidth - pixelX;
		positionX -= cellW - diff;
	}
	if(pixelY < 0) { // cursor too far up
		diff = Math.abs(pixelY);
		positionY += diff;
	}
	if(pixelY + cellH >= owotHeight) { // cursor too far down
		diff = owotHeight - pixelY;
		positionY -= cellH - diff;
	}

	if(diff != null && (posXCompare != positionX || posYCompare != positionY)) w.render();
	if(cursorCoords) w.emit("cursorMove", {
		tileX: cursorCoords[0],
		tileY: cursorCoords[1],
		charX: cursorCoords[2],
		charY: cursorCoords[3]
	});
}

function removeCursor() {
	if(!cursorCoords) return;
	var remTileX = cursorCoords[0];
	var remTileY = cursorCoords[1];
	var cursorPos = {
		tileX: cursorCoords[0],
		tileY: cursorCoords[1],
		charX: cursorCoords[2],
		charY: cursorCoords[3]
	};
	cursorCoords = null;
	w.setTileRender(remTileX, remTileY);
	w.emit("cursorHide", cursorPos);
}

function stopDragging() {
	isDragging = false;
	hasDragged = false;
	elm.owot.style.cursor = defaultCursor;
}

var cursorEnabled = true;
function event_mouseup(e, arg_pageX, arg_pageY) {
	var pageX = Math.trunc(e.pageX * zoomRatio);
	var pageY = Math.trunc(e.pageY * zoomRatio);
	if(arg_pageX != void 0) pageX = arg_pageX;
	if(arg_pageY != void 0) pageY = arg_pageY;
	var canShowMobileKeyboard = !hasDragged;
	stopDragging();

	for(var i = 0; i < draggable_element_mouseup.length; i++) {
		draggable_element_mouseup[i](e, pageX, pageY);
	}

	if(e.target != elm.owot && e.target != linkDiv) return;

	if(e.which == 3) { // right click
		if(ignoreCanvasContext) {
			ignoreCanvasContext = false;
			elm.owot.style.pointerEvents = "none";
			setTimeout(function() {
				ignoreCanvasContext = true;
				elm.owot.style.pointerEvents = "";
			}, 1);
		}
		return;
	}

	var foundActiveSelection = false;
	for(var i = 0; i < regionSelections.length; i++) {
		var reg = regionSelections[i];
		if(reg.isSelecting) {
			reg.regionCoordB = currentPosition;
			reg.handleSelection();
			foundActiveSelection = true;
		}
	}
	if(foundActiveSelection) return;

	if(closest(e.target, elm.main_view) && canShowMobileKeyboard) {
		elm.textInput.focus();
	}

	// set cursor
	var pos = getTileCoordsFromMouseCoords(pageX, pageY);
	w.emit("mouseUp", {
		tileX: pos[0],
		tileY: pos[1],
		charX: pos[2],
		charY: pos[3],
		pageX: pageX,
		pageY: pageY
	});
	if(cursorEnabled && Tile.get(pos[0], pos[1]) !== void 0) {
		verticalEnterPos[0] = pos[0];
		verticalEnterPos[1] = pos[2];
		// change position of the cursor and get results
		if(renderCursor(pos) == false) {
			// cursor should be removed if on area where user cannot write
			if(cursorCoords) {
				removeCursor();
			}
		}
	}
}

document.addEventListener("mouseup", event_mouseup);
function event_touchend(e) {
	event_mouseup(e, touchPosX, touchPosY);
}
document.addEventListener("touchend", event_touchend);
function event_mouseleave(e) {
	event_mousemove(e);
	w.emit("mouseLeave", e);
}
document.addEventListener("mouseleave", event_mouseleave);
function event_mouseenter(e) {
	event_mousemove(e);
	w.emit("mouseEnter", e);
}
document.addEventListener("mouseenter", event_mouseenter);

function is_link(tileX, tileY, charX, charY) {
	if(!Tile.get(tileX, tileY)) return;
	var tile = Tile.get(tileX, tileY);
	if(!tile) return;
	var props = tile.properties.cell_props;
	if(!props) return false;
	if(!props[charY]) return false;
	if(!props[charY][charX]) return false;
	if(!props[charY][charX].link) return false;
	return [props[charY][charX].link];
}

function flushWrites() {
	if(w.socket.socket.readyState != WebSocket.OPEN) return;
	network.write(writeBuffer.splice(0, 512));
}

var writeInterval;
function setWriteInterval() {
	clearInterval(writeInterval);
	writeInterval = setInterval(function() {
		if(!writeBuffer.length) return;
		try {
			flushWrites();
			sendCursorPosition();
		} catch(e) {
			console.log(e);
		}
	}, writeFlushRate);
}
setWriteInterval();

function moveCursor(direction, preserveVertPos, amount) {
	if(!cursorCoords) return;
	if(amount == null) amount = 1;
	// [tileX, tileY, charX, charY]
	var pos = cursorCoords.slice(0);
	if(direction == "up") {
		pos[3] -= amount;
	} else if(direction == "down") {
		pos[3] += amount;
	} else if(direction == "left") {
		pos[2] -= amount;
	} else if(direction == "right") {
		pos[2] += amount;
	}
	if(pos[2] < 0) {
		pos[0] += Math.floor(pos[2] / tileC);
		pos[2] = tileC + pos[2] % tileC;
	} else if(pos[2] >= tileC) {
		pos[0] += Math.floor(pos[2] / tileC);
		pos[2] %= tileC;
	}
	if(pos[3] < 0) {
		pos[1] += Math.floor(pos[3] / tileR);
		pos[3] = tileR + pos[3] % tileR;
	} else if(pos[3] >= tileR) {
		pos[1] += Math.floor(pos[3] / tileR);
		pos[3] %= tileR;
	}
	if(!preserveVertPos) {
		verticalEnterPos[0] = pos[0];
		verticalEnterPos[1] = pos[2];
	}
	return renderCursor(pos);
}

// place a character
function writeCharTo(char, charColor, tileX, tileY, charX, charY, noUndo, undoOffset) {
	if(!Tile.get(tileX, tileY)) {
		Tile.set(tileX, tileY, blankTile());
	}
	var tile = Tile.get(tileX, tileY);
	
	var cell_props = tile.properties.cell_props;
	if(!cell_props) cell_props = {};
	var color = tile.properties.color;
	if(!color) color = new Array(tileArea).fill(0);

	var hasChanged = false;
	var prevColor = 0;
	var prevChar = "";
	var prevLink = getLink(tileX, tileY, charX, charY);

	// delete link locally
	if(cell_props[charY]) {
		if(cell_props[charY][charX]) {
			delete cell_props[charY][charX];
			hasChanged = true;
		}
	}
	// change color
	if(Permissions.can_color_text(state.userModel, state.worldModel)) {
		prevColor = color[charY * tileC + charX];
		color[charY * tileC + charX] = charColor;
		if(prevColor != charColor) hasChanged = true;
		tile.properties.color = color; // if the color array doesn't already exist in the tile
	}

	// update cell properties (link positions)
	tile.properties.cell_props = cell_props;

	// set char locally
	var con = tile.content;
	prevChar = con[charY * tileC + charX]
	con[charY * tileC + charX] = char;
	if(prevChar != char) hasChanged = true;
	w.setTileRedraw(tileX, tileY);
	if(bufferLargeChars) {
		if(charY == 0) w.setTileRedraw(tileX, tileY - 1);
		if(charX == tileC - 1) w.setTileRedraw(tileX + 1, tileY);
		if(charY == 0 && charX == tileC - 1) w.setTileRedraw(tileX + 1, tileY - 1);
	}

	if(hasChanged && (!noUndo || noUndo == -1)) {
		if(noUndo != -1) {
			undoBuffer.trim();
		}
		undoBuffer.push([tileX, tileY, charX, charY, prevChar, prevColor, prevLink, undoOffset]);
	}

	var editArray = [tileY, tileX, charY, charX, getDate(), char, nextObjId];
	if(tileFetchOffsetX || tileFetchOffsetY) {
		editArray[0] += tileFetchOffsetY;
		editArray[1] += tileFetchOffsetX;
	}
	if(charColor && Permissions.can_color_text(state.userModel, state.worldModel)) {
		editArray.push(charColor);
	}
	tellEdit.push(editArray); // track local changes
	writeBuffer.push(editArray); // send edits to server
	nextObjId++;
}

function undoWrite() {
	var edit = undoBuffer.pop();
	if(!edit) return;
	var tileX = edit[0];
	var tileY = edit[1];
	var charX = edit[2];
	var charY = edit[3];
	var char = edit[4];
	var color = edit[5];
	var link = edit[6];
	var offset = edit[7] || 0;
	writeCharTo(char, color, tileX, tileY, charX, charY, -1, offset);
	if(link) {
		if(link.type == "url" && Permissions.can_urllink(state.userModel, state.worldModel)) {
			linkQueue.push(["url", tileX, tileY, charX, charY, link.url]);
		} else if(link.type == "coord" && Permissions.can_coordlink(state.userModel, state.worldModel)) {
			linkQueue.push(["coord", tileX, tileY, charX, charY, link.link_tileX, link.link_tileY]);
		}
	}
	renderCursor([edit[0], edit[1], edit[2], edit[3]]);
	moveCursor("right", false, offset);
	undoBuffer.pop();
}

function redoWrite() {
	var edit = undoBuffer.unpop();
	if(!edit) return;
	undoBuffer.pop();
	var offset = edit[7] || 0;
	writeCharTo(edit[4], edit[5], edit[0], edit[1], edit[2], edit[3], -1, offset);
	renderCursor([edit[0], edit[1], edit[2], edit[3]]);
	moveCursor("right", false, -offset + 1);
}

function writeCharToXY(char, charColor, x, y) {
	writeCharTo(char, charColor,
		Math.floor(x / tileC),
		Math.floor(y / tileR),
		x - Math.floor(x / tileC) * tileC,
		y - Math.floor(y / tileR) * tileR);
}

// type a character
function writeChar(char, doNotMoveCursor, tempColor, noNewline, undoCursorOffset) {
	char += "";
	var charColor = tempColor || YourWorld.Color;
	if(tempColor == 0) charColor = 0;
	var cursor = cursorCoords;
	if(!cursor && (char == "\n" || char == "\r") && !noNewline) {
		cursor = cursorCoordsCurrent;
	}
	var skipChar = false;
	if(char == "") {
		skipChar = true;
	} else {
		char = w.split(char);
		char = char[0];
		if(char == void 0) return;
	}
	if(!cursor) return; // cursor is not visible
	var tileX = cursor[0];
	var tileY = cursor[1];
	var charX = cursor[2];
	var charY = cursor[3];
	var newLine = (char == "\n" || char == "\r") && !noNewline;
	if(!doNotMoveCursor) {
		var pos = propagatePosition({
			tileX: cursor[0],
			tileY: cursor[1],
			charX: cursor[2],
			charY: cursor[3]
		}, char, noNewline);
		renderCursor([
			pos.tileX, pos.tileY,
			pos.charX, pos.charY
		]);
		// yield to unloaded tile
		if(cursorCoords) {
			var compare = cursor.slice(0);
			if(cursorCoords[0] == compare[0] && cursorCoords[1] == compare[1] &&
			   cursorCoords[2] == compare[2] && cursorCoords[3] == compare[3]) {
				return null;
			}
		}
	}
	if(!newLine && !skipChar) {
		var data = {
			char: char,
			color: charColor,
			tileX: tileX,
			tileY: tileY,
			charX: charX,
			charY: charY
		};

		w.emit("writeBefore", data);
		writeCharTo(data.char, data.color, data.tileX, data.tileY, data.charX, data.charY, false, undoCursorOffset);
		w.emit("write", data);
	}
}

function coordinateAdd(tileX1, tileY1, charX1, charY1, tileX2, tileY2, charX2, charY2) {
	return [
		tileX1 + tileX2 + Math.floor((charX1 + charX2) / tileC),
		tileY1 + tileY2 + Math.floor((charY1 + charY2) / tileR),
		(charX1 + charX2) % tileC,
		(charY1 + charY2) % tileR
	];
}

function propagatePosition(coords, char, noEnter, noVertPos) {
	// coords: {tileX, tileY, charX, charY}
	// char: <string>
	var newline = char == "\n" || char == "\r";
	if(newline && !noEnter) {
		if(pasteDirDown) {
			coords.charY++;
			if(coords.charY >= tileR) {
				coords.charY = 0;
				coords.tileY++;
			}
		} else {
			coords.charY--;
			if(coords.charY < 0) {
				coords.charY = tileY - 1;
				coords.tileY--;
			}
		}
		if(noVertPos) {
			coords.tileX = 0;
			coords.charX = 0;
		} else {
			coords.tileX = verticalEnterPos[0];
			coords.charX = verticalEnterPos[1];
		}
	} else {
		if(pasteDirRight) {
			coords.charX++;
			if(coords.charX >= tileC) {
				coords.charX = 0;
				coords.tileX++;
			}
		} else {
			coords.charX--;
			if(coords.charX < 0) {
				coords.charX = tileC - 1;
				coords.tileX--;
			}
		}
	}
	return coords;
}

function textcode_parser(value, coords, defaultColor) {
	if(typeof value == "string") value = w.split(value);
	var hex = "ABCDEF";
	var pasteColor = defaultColor;
	if(!pasteColor) pasteColor = 0;
	var index = 0;
	var off = {
		tileX: 0, tileY: 0,
		charX: 0, charY: 0
	};
	if(coords) {
		off.tileX = coords.tileX;
		off.tileY = coords.tileY;
		off.charX = coords.charX;
		off.charY = coords.charY;
	}
	var pos = {
		tileX: 0, tileY: 0,
		charX: 0, charY: 0
	};
	var next = function() {
		if(index >= value.length) return -1;
		var chr = value[index];
		var doWriteChar = true;
		var newline = true;
		if(chr == "\x1b") {
			doWriteChar = false;
			var hCode = value[index + 1];
			if(hCode == "$") { // contains links
				index += 2;
				var lType = value[index];
				index++;
				if(lType == "c") { // coord
					var strPoint = index;
					var buf = "";
					var mode = 0;
					while(true) {
						if(value[strPoint] == "[" && mode == 0) {
							mode = 1;
							if(++strPoint >= value.length) break;
							continue;
						}
						if(value[strPoint] == "]" && mode == 1) {
							strPoint++;
							break;
						}
						if(mode == 1) {
							buf += value[strPoint];
							if(++strPoint >= value.length) break;
							continue;
						}
						if(++strPoint >= value.length) break;
					}
					index = strPoint;
					buf = buf.split(",");
					var coordTileX = parseFloat(buf[0].trim());
					var coordTileY = parseFloat(buf[1].trim());
					var charPos = coordinateAdd(pos.tileX, pos.tileY, pos.charX, pos.charY,
						off.tileX, off.tileY, off.charX, off.charY);
					return {
						type: "link",
						linkType: "coord",
						tileX: charPos[0],
						tileY: charPos[1],
						charX: charPos[2],
						charY: charPos[3],
						coord_tileX: coordTileX,
						coord_tileY: coordTileY
					};
				} else if(lType == "u") { // urllink
					var strPoint = index;
					var buf = "";
					var quotMode = 0;
					while(true) {
						if(value[strPoint] == "\"" && quotMode == 0) {
							quotMode = 1;
							if(++strPoint >= value.length) break;
							continue;
						}
						if(value[strPoint] == "\"" && quotMode == 1) {
							strPoint++;
							break;
						}
						if(quotMode == 1) {
							if(value[strPoint] == "\\") {
								quotMode = 2;
								if(++strPoint >= value.length) break;
								continue;
							}
							buf += value[strPoint];
						}
						if(quotMode == 2) {
							buf += value[strPoint];
							quotMode = 1;
							if(++strPoint >= value.length) break;
							continue;
						}
						if(++strPoint >= value.length) break;
					}
					index = strPoint;
					var charPos = coordinateAdd(pos.tileX, pos.tileY, pos.charX, pos.charY,
						off.tileX, off.tileY, off.charX, off.charY);
					return {
						type: "link",
						linkType: "url",
						tileX: charPos[0],
						tileY: charPos[1],
						charX: charPos[2],
						charY: charPos[3],
						url: buf
					};
				}
			} else if(hCode == "P") { // contains area protections
				index += 2;
				var protType = parseInt(value[index]);
				index++;
				if(isNaN(protType)) protType = 0;
				if(!(protType >= 0 && protType <= 2)) protType = 0;
				var charPos = coordinateAdd(pos.tileX, pos.tileY, pos.charX, pos.charY,
					off.tileX, off.tileY, off.charX, off.charY);
				return {
					type: "protect",
					protType: protType,
					tileX: charPos[0],
					tileY: charPos[1],
					charX: charPos[2],
					charY: charPos[3]
				};
			} else if(hCode == "*") { // skip character
				index++;
				chr = "";
				doWriteChar = true;
			} else if(hCode == "x" || hCode == "X" || (hCode >= "A" && hCode <= "F")) { // colored paste
				var cCol = "";
				if(hCode == "x") {
					cCol = "000000";
					index += 2;
				} else if(hCode == "X") {
					// -1 does not overwrite color
					cCol = "-1";
					index += 2;
				} else {
					var code = hex.indexOf(hCode);
					if(code > -1) {
						cCol = value.slice(index + 2, index + 2 + code + 1).join("");
						index += code + 1;
					}
					index += 2;
				}
				pasteColor = parseInt(cCol, 16);
				return {
					type: "yield"
				};
			} else {
				index += 2;
				doWriteChar = true;
				if(hCode == "\n") { // paste newline character itself
					chr = "\n";
					newline = false;
				} else if(hCode == "\r") { // paste carriage return character itself
					chr = "\r";
					newline = false;
				} else if(hCode == "\x1b") { // paste ESC character itself
					chr = "\x1b";
				} else {
					chr = hCode;
				}
			}
		} else {
			index++;
		}
		var charPos = coordinateAdd(pos.tileX, pos.tileY, pos.charX, pos.charY,
			off.tileX, off.tileY, off.charX, off.charY);
		propagatePosition(pos, chr, false, true);
		return {
			type: "char",
			char: chr,
			color: pasteColor,
			writable: doWriteChar,
			newline: newline, // if false, interpret newline characters as characters
			tileX: charPos[0],
			tileY: charPos[1],
			charX: charPos[2],
			charY: charPos[3]
		};
	}
	return {
		next: next,
		nextItem: function() {
			while(true) {
				var item = next();
				if(item == -1) return -1;
				if(item.type == "yield") continue;
				return item;
			}
		}
	};
}

function stabilizeTextInput() {
	elm.textInput.selectionEnd = elm.textInput.value.length;
	elm.textInput.selectionStart = elm.textInput.selectionEnd;
}

elm.textInput.addEventListener("keydown", stabilizeTextInput);

var write_busy = false; // currently pasting
var pasteInterval;
var linkQueue = [];
var char_input_check = setInterval(function() {
	if(Modal.isOpen) return;
	if(write_busy) return;
	if(state.worldModel.char_rate[0] == 0 && !state.userModel.is_member) {
		elm.textInput.value = "";
		return;
	}
	var value = elm.textInput.value;
	var hasErased = getDate() - previousErase < 1000;
	if(!value) {
		if(hasErased) {
			elm.textInput.value = "\x7F";
		}
		return;
	}
	if(value == "\x7F") {
		if(!hasErased) {
			elm.textInput.value = "";
		}
		return;
	}
	stabilizeTextInput();
	value = w.split(value.replace(/\r\n/g, "\n").replace(/\x7F/g, ""));
	if(value.length == 1) {
		writeChar(value[0]);
		elm.textInput.value = "";
		return;
	}
	clearInterval(pasteInterval);
	var pastePerm = Permissions.can_paste(state.userModel, state.worldModel);
	var requestNextItem = true;
	if(!cursorCoords) {
		elm.textInput.value = "";
		return;
	}
	var parser = textcode_parser(value, {
		tileX: cursorCoords[0],
		tileY: cursorCoords[1],
		charX: cursorCoords[2],
		charY: cursorCoords[3]
	}, YourWorld.Color);
	elm.textInput.value = "";
	var item;
	var charCount = 0;
	var pasteFunc = function() {
		if(requestNextItem) {
			item = parser.nextItem();
		} else {
			requestNextItem = true;
		}
		if(item == -1)  {
			return -1;
		}
		if(item.type == "char") {
			if(item.writable) {
				if(item.char == "\x7F") {
					return true;
				}
				var res = writeChar(item.char, false, item.color, !item.newline);
				if(res === null) {
					// pause until tile loads
					requestNextItem = false;
					return false;
				}
				charCount++;
			}
		} else if(item.type == "link") {
			if(item.linkType == "url" && Permissions.can_urllink(state.userModel, state.worldModel)) {
				linkQueue.push(["url", item.tileX, item.tileY, item.charX, item.charY, item.url]);
			} else if(item.linkType == "coord" && Permissions.can_coordlink(state.userModel, state.worldModel)) {
				linkQueue.push(["coord", item.tileX, item.tileY, item.charX, item.charY, item.coord_tileX, item.coord_tileY]);
			}
		} else if(item.type == "protect") {
			var protType = item.protType;
			var canProtect = true;
			if(protType <= 1) { // public, member
				if(!Permissions.can_protect_tiles(state.userModel, state.worldModel)) canProtect = false;
			}
			if(protType == 2) { // owner
				if(!Permissions.can_admin(state.userModel, state.worldModel)) protType = 1; // member
			}
			if(canProtect) {
				network.protect({
					tileY: item.tileY,
					tileX: item.tileX,
					charY: item.charY,
					charX: item.charX
				}, ["public", "member-only", "owner-only"][protType]);
			}
		}
		return true;
	};
	if(!pastePerm) {
		while(true) {
			var res = pasteFunc();
			if(!res || res == -1 || charCount >= 4) break;
		}
		elm.textInput.value = "";
		return;
	}
	write_busy = true;
	var rate = state.worldModel.char_rate;
	var base = rate[1];
	if(base > 60 * 1000) base = 60 * 1000;
	var speed = Math.floor(1000 / base * rate[0]) - 1;
	if(speed < 1) speed = 1;
	if(speed > 280) speed = 280;
	if(state.userModel.is_member || state.userModel.is_owner) speed = 280;
	pasteInterval = setInterval(function() {
		var res = pasteFunc();
		if(res == -1) {
			clearInterval(pasteInterval);
			write_busy = false;
			elm.textInput.value = "";
		}
	}, Math.floor(1000 / speed));
}, 10);

function stopPasting() {
	if(write_busy) elm.textInput.value = "";
	clearInterval(pasteInterval);
	write_busy = false;
}

var autoArrowKeyMoveInterval = null;
var autoArrowKeyMoveActive = false;
var autoArrowKeyMoveState = {
	up: false,
	down: false,
	left: false,
	right: false,
	x_t: 0,
	y_t: 0,
	prog_x: 0,
	prog_y: 0
};
function autoArrowKeyMoveStart(dir) {
	if(!autoArrowKeyMoveActive) {
		autoArrowKeyMoveActive = true;
		autoArrowKeyMoveInterval = setInterval(function() {
			if(cursorCoords) {
				clearInterval(autoArrowKeyMoveInterval);
				autoArrowKeyMoveActive = false;
				autoArrowKeyMoveState.y_t = 0;
				autoArrowKeyMoveState.prog_y = 0;
				autoArrowKeyMoveState.x_t = 0;
				autoArrowKeyMoveState.prog_x = 0;
				return;
			}
			var date = getDate();
			var s_up = autoArrowKeyMoveState.up;
			var s_down = autoArrowKeyMoveState.down;
			var s_left = autoArrowKeyMoveState.left;
			var s_right = autoArrowKeyMoveState.right;
			var x_t = autoArrowKeyMoveState.x_t;
			var y_t = autoArrowKeyMoveState.y_t;
			if(x_t) {
				var diff = (date - x_t) / (1000 / 240);
				if(s_right && !s_left) {
					var addDiff = diff - autoArrowKeyMoveState.prog_x;
					autoArrowKeyMoveState.prog_x = diff;
					positionX -= addDiff;
					w.render();
				}
				if(s_left && !s_right) {
					var addDiff = diff - autoArrowKeyMoveState.prog_x;
					autoArrowKeyMoveState.prog_x = diff;
					positionX += addDiff;
					w.render();
				}
			}
			if(y_t) {
				var diff = (date - y_t) / (1000 / 240);
				if(s_up && !s_down) {
					var addDiff = diff - autoArrowKeyMoveState.prog_y;
					autoArrowKeyMoveState.prog_y = diff;
					positionY += addDiff;
					w.render();
				}
				if(s_down && !s_up) {
					var addDiff = diff - autoArrowKeyMoveState.prog_y;
					autoArrowKeyMoveState.prog_y = diff;
					positionY -= addDiff;
					w.render();
				}
			}
		}, 10);
	}
	switch(dir) {
		case "up":
			autoArrowKeyMoveState.up = true;
			if(autoArrowKeyMoveState.y_t == 0) autoArrowKeyMoveState.y_t = getDate();
			break;
		case "down":
			autoArrowKeyMoveState.down = true;
			if(autoArrowKeyMoveState.y_t == 0) autoArrowKeyMoveState.y_t = getDate();
			break;
		case "left":
			autoArrowKeyMoveState.left = true;
			if(autoArrowKeyMoveState.x_t == 0) autoArrowKeyMoveState.x_t = getDate();
			break;
		case "right":
			autoArrowKeyMoveState.right = true;
			if(autoArrowKeyMoveState.x_t == 0) autoArrowKeyMoveState.x_t = getDate();
			break;
	}
}
function autoArrowKeyMoveStop(dir) {
	switch(dir) {
		case "up":
			autoArrowKeyMoveState.up = false;
			autoArrowKeyMoveState.y_t = 0;
			autoArrowKeyMoveState.prog_y = 0;
			if(autoArrowKeyMoveState.down) autoArrowKeyMoveState.y_t = getDate();
			break;
		case "down":
			autoArrowKeyMoveState.down = false;
			autoArrowKeyMoveState.y_t = 0;
			autoArrowKeyMoveState.prog_y = 0;
			if(autoArrowKeyMoveState.up) autoArrowKeyMoveState.y_t = getDate();
			break;
		case "left":
			autoArrowKeyMoveState.left = false;
			autoArrowKeyMoveState.x_t = 0;
			autoArrowKeyMoveState.prog_x = 0;
			if(autoArrowKeyMoveState.right) autoArrowKeyMoveState.x_t = getDate();
			break;
		case "right":
			autoArrowKeyMoveState.right = false;
			autoArrowKeyMoveState.x_t = 0;
			autoArrowKeyMoveState.prog_x = 0;
			if(autoArrowKeyMoveState.left) autoArrowKeyMoveState.x_t = getDate();
			break;
	}
	if(!autoArrowKeyMoveState.up && !autoArrowKeyMoveState.down && !autoArrowKeyMoveState.left && !autoArrowKeyMoveState.right) {
		clearInterval(autoArrowKeyMoveInterval);
		autoArrowKeyMoveActive = false;
	}
}

function event_keydown(e) {
	var actElm = document.activeElement;
	if(!worldFocused) return;
	if(Modal.isOpen) {
		if(checkKeyPress(e, keyConfig.reset)) {
			Modal.closeAll();
		}
		return;
	}
	if(actElm == elm.chatbar) return;
	if(actElm == elm.confirm_js_code) return;
	if(actElm.tagName == "INPUT" && actElm.type == "text" && actElm != elm.textInput) return;
	if(actElm != elm.textInput) elm.textInput.focus();
	stopPasting();
	if(checkKeyPress(e, keyConfig.cursorUp)) { // arrow up
		moveCursor("up");
		if(!cursorCoords) autoArrowKeyMoveStart("up");
	}
	if(checkKeyPress(e, keyConfig.cursorDown)) { // arrow down
		moveCursor("down");
		if(!cursorCoords) autoArrowKeyMoveStart("down");
	}
	if(checkKeyPress(e, keyConfig.cursorLeft)) { // arrow left
		moveCursor("left");
		if(!cursorCoords) autoArrowKeyMoveStart("left");
	}
	if(checkKeyPress(e, keyConfig.cursorRight)) { // arrow right
		moveCursor("right");
		if(!cursorCoords) autoArrowKeyMoveStart("right");
	}
	if(checkKeyPress(e, keyConfig.reset)) { // esc
		w.emit("esc");
		stopLinkUI();
		stopTileUI();
		for(var i = 0; i < regionSelections.length; i++) {
			regionSelections[i].stopSelectionUI();
		}
		removeCursor();
		tileProtectAuto.active = false;
		tileProtectAuto.lastPos = null;
		linkAuto.active = false;
	}
	if(checkKeyPress(e, "CTRL+ENTER")) {
		writeChar("\n");
	}
	if(checkKeyPress(e, keyConfig.erase)) { // erase character
		if(state.worldModel.char_rate[0] > 0) {
			moveCursor("left", true);
			writeChar(" ", true, null, false, 1);
			previousErase = getDate();
		}
	}
	if(checkKeyPress(e, keyConfig.cellErase)) {
		if(state.worldModel.char_rate[0] > 0) {
			writeChar(" ", true);
		}
	}
	if(checkKeyPress(e, keyConfig.tab)) { // tab
		if(state.worldModel.char_rate[0] > 0) {
			for(var i = 0; i < 4; i++) writeChar(" ");
			e.preventDefault();
		}
	}
	if(checkKeyPress(e, keyConfig.undo)) {
		undoWrite();
		e.preventDefault();
	}
	if(checkKeyPress(e, keyConfig.redo)) {
		redoWrite();
		e.preventDefault();
	}
	w.emit("keyDown", e);
}
document.addEventListener("keydown", event_keydown);

function event_keyup(e) {
	w.emit("keyUp", e);
}
document.addEventListener("keyup", event_keyup);

function getTileCoordsFromMouseCoords(x, y) {
	var tileX = 0;
	var tileY = 0;
	var charX = 0;
	var charY = 0;
	var mpX = x - positionX - Math.trunc(owotWidth / 2);
	var mpY = y - positionY - Math.trunc(owotHeight / 2);
	// add global cell position
	charX = Math.floor(mpX / cellW);
	charY = Math.floor(mpY / cellH);
	// add tile position
	tileX = Math.floor(charX / tileC);
	tileY = Math.floor(charY / tileR);
	// add in-tile cell position
	charX = charX - (Math.floor(charX / tileC) * tileC);
	charY = charY - (Math.floor(charY / tileR) * tileR);
	return [tileX, tileY, charX, charY];
}

function getTileScreenPosition(tileX, tileY) {
	var offsetX = tileX * tileW + Math.trunc(owotWidth / 2) + Math.floor(positionX);
	var offsetY = tileY * tileH + Math.trunc(owotHeight / 2) + Math.floor(positionY);
	return [offsetX, offsetY];
}

function getVisibleTileRange(margin) {
	if(!margin) margin = 0;
	var A = getTileCoordsFromMouseCoords(0 - margin, 0 - margin);
	var B = getTileCoordsFromMouseCoords(owotWidth - 1 + margin, owotHeight - 1 + margin);
	var startX = clipIntMax(A[0]);
	var startY = clipIntMax(A[1]);
	var endX = clipIntMax(B[0]);
	var endY = clipIntMax(B[1]);
	if(startX > endX || startY > endY || (B[0] - A[0] + 1) > 100000 || (B[1] - A[1] + 1) > 100000) {
		throw "Invalid ranges";
	}
	return [[startX, startY], [endX, endY]];
}

function getVisibleTiles(margin) {
	if(!margin) margin = 0;
	var A = getTileCoordsFromMouseCoords(0 - margin, 0 - margin);
	var B = getTileCoordsFromMouseCoords(owotWidth - 1 + margin, owotHeight - 1 + margin);
	return getRange(A[0], A[1], B[0], B[1]);
}

function getWidth(margin) {
	if(!margin) margin = 0;
	var A = getTileCoordsFromMouseCoords(0 - margin, 0);
	var B = getTileCoordsFromMouseCoords(owotWidth - 1 + margin, 0);
	return B[0] - A[0] + 1;
}

function getHeight(margin) {
	if(!margin) margin = 0;
	var A = getTileCoordsFromMouseCoords(0, 0 - margin);
	var B = getTileCoordsFromMouseCoords(0, owotHeight - 1 + margin);
	return B[1] - A[1] + 1;
}

function getArea(margin) {
	if(!margin) margin = 0;
	var A = getTileCoordsFromMouseCoords(0 - margin, 0 - margin);
	var B = getTileCoordsFromMouseCoords(owotWidth - 1 + margin, owotHeight - 1 + margin);
	return (B[0] - A[0] + 1) * (B[1] - A[1] + 1);
}

function tileAndCharsToWindowCoords(tileX, tileY, charX, charY) {
	var x = tileX * tileW;
	var y = tileY * tileH;
	x += charX * cellW;
	y += charY * cellH;
	x += positionX;
	y += positionY;
	x += Math.trunc(owotWidth / 2);
	y += Math.trunc(owotHeight / 2);
	return [Math.trunc(x / zoomRatio), Math.trunc(y / zoomRatio)];
}

function alertJS(data) {
	js_alert_active = true;
	elm.confirm_js.style.display = "";
	elm.confirm_js_code.innerText = data;
	run_js_confirm.onclick = function() {
		confirmRunJSLink(data);
		return false;
	}
	confirm_js_cancel.onclick = closeJSAlert;
	confirm_js_cancel_x.onclick = closeJSAlert;
}

function closeJSAlert() {
	if(!js_alert_active) return;
	js_alert_active = false;
	elm.confirm_js.style.display = "none";
}

function executeJS(code) {
	var jsCode = new Function(code);
	return jsCode();
}

function confirmRunJSLink(data) {
	var preview = data;
	if(preview.length > 256) {
		preview = preview.slice(0, 256) + " [...]";
	}
	var doRun = confirm("Confirm that you will be running this script.\nPress cancel to NOT run it.\n\"" + preview + "\"");
	if(!doRun) return closeJSAlert();
	executeJS(data);
	closeJSAlert();
}

function runJSLink(data) {
	if(secureJSLink) {
		alertJS(data);
	} else {
		executeJS(data);
	}
}

var linkParams = {
	protocol: "",
	url: "",
	host: "",
	coord: false
};
linkDiv.style.width = (cellW / zoomRatio) + "px";
linkDiv.style.height = (cellH / zoomRatio) + "px";
linkElm.style.top = "-1000px";
linkElm.style.left = "-1000px";
linkElm.ondragstart = function() {
	return false;
}
linkElm.onclick = function(e) {
	if(linkParams.coord) {
		coord_link_click(e);
		return;
	}
	var linkEvent = url_link_click(e);
	var prot = linkParams.protocol;
	var url = linkParams.url;
	if(prot == "javascript") {
		runJSLink(url);
		return false;
	} else if(prot == "com") {
		w.broadcastCommand(url);
		return false;
	} else if(prot == "comu") {
		w.broadcastCommand(url, true);
		return false;
	}
	if(secureLink && !e.ctrlKey) {
		var lTileX = currentSelectedLinkCoords[0];
		var lTileY = currentSelectedLinkCoords[1];
		var lCharX = currentSelectedLinkCoords[2];
		var lCharY = currentSelectedLinkCoords[3];
		var charInfo = getCharInfo(lTileX, lTileY, lCharX, lCharY);
		var isMain = state.worldModel.name == "" || state.worldModel.name.toLowerCase() == "main";
		var isCenter = (-20 <= lTileX && 20 >= lTileX) && (-20 <= lTileY && 20 >= lTileY);
		var badChar = isMain && charInfo.char == "\u2588";
		if(((isMain && isCenter && charInfo.protection == 0) || badChar) && !isSafeHostname(linkParams.host)) {
			var acpt = confirm("Are you sure you want to visit this link?\n" + url);
			if(!acpt) {
				return false;
			}
		}
	}
	if(linkEvent && linkEvent[0]) {
		return linkEvent[0];
	}
}
var currentSelectedLink = null;
var currentSelectedLinkCoords = null; // [tileX, tileY, charX, charY]

function coord_link_click(evt) {
	if(!currentSelectedLink) return;
	w.doGoToCoord(currentSelectedLink.link_tileY, currentSelectedLink.link_tileX);
}
function url_link_click(evt) {
	if(!currentSelectedLink) return;
	var returnValue = [undefined];
	w.emit("linkClick", {
		url: currentSelectedLink.url,
		tileX: currentSelectedLinkCoords[0],
		tileY: currentSelectedLinkCoords[1],
		charX: currentSelectedLinkCoords[2],
		charY: currentSelectedLinkCoords[3],
		elm: linkElm,
		evt: evt,
		returnValue: returnValue
	});
	return returnValue[0];
}

function updateHoveredLink(mouseX, mouseY, evt, safe) {
	if(mouseX == void 0 && mouseY == void 0) {
		mouseX = currentMousePosition[0];
		mouseY = currentMousePosition[1];
	}
	var coords = getTileCoordsFromMouseCoords(mouseX, mouseY);
	var tileX = coords[0];
	var tileY = coords[1];
	var charX = coords[2];
	var charY = coords[3];
	if(evt) {
		if(!closest(evt.target, elm.main_view) && evt.target != linkDiv) return;
	}
	var link = getLink(tileX, tileY, charX, charY);
	if(safe) {
		if(!link) return;
		if(link.type != "coord") return;
	}
	if(link && linksEnabled && !regionSelectionsActive()) {
		currentSelectedLink = link;
		currentSelectedLinkCoords = coords;
		var pos = tileAndCharsToWindowCoords(tileX, tileY, charX, charY);
		elm.owot.style.cursor = "pointer";
		linkElm.style.left = pos[0] + "px";
		linkElm.style.top = pos[1] + "px";
		linkElm.hidden = false;
		linkElm.target = "_blank";
		linkElm.href = "";
		linkElm.rel = "";
		linkElm.title = "";
		if(link.type == "url") {
			linkParams.coord = false;
			var URL_Link = link.url;
			linkElm.href = URL_Link;
			linkElm.rel = "noopener noreferrer";
			var linkProtocol = linkElm.protocol;
			linkParams.host = "";
			if(linkProtocol == "javascript:") {
				linkElm.target = "";
				linkParams.protocol = "javascript";
				var url = URL_Link.slice(linkProtocol.length);
				linkParams.url = url;
			} else if(linkProtocol == "com:") {
				linkElm.target = "";
				linkParams.protocol = "com";
				var url = URL_Link.slice(linkProtocol.length);
				linkParams.url = url;
				linkElm.title = "com:" + url;
			} else if(linkProtocol == "comu:") {
				linkElm.target = "";
				linkParams.protocol = "comu";
				var url = URL_Link.slice(linkProtocol.length);
				linkParams.url = url;
				linkElm.title = "comu:" + url;
			} else {
				linkParams.protocol = "";
				linkElm.rel = "noopener noreferrer";
				linkParams.url = URL_Link;
				linkParams.host = getBasicHostname(linkElm.host);
			}
			if(!linkElm.title) linkElm.title = "Link to URL " + linkElm.href;
		} else if(link.type == "coord") {
			linkParams.coord = true;
			linkParams.protocol = "";
			linkElm.target = "";
			linkElm.href = "javascript:void(0);";
			linkElm.target = "";
			var pos = link.link_tileX + "," + link.link_tileY;
			linkElm.title = "Link to coordinates " + pos;
		}
	} else {
		currentSelectedLink = null;
		currentSelectedLinkCoords = null;
		if(!linkElm.hidden) elm.owot.style.cursor = defaultCursor;
		linkElm.style.top = "-1000px";
		linkElm.style.left = "-1000px";
		linkElm.hidden = true;
	}
}

var touchPosX = 0;
var touchPosY = 0;
function event_mousemove(e, arg_pageX, arg_pageY) {
	currentMousePosition[0] = e.pageX;
	currentMousePosition[1] = e.pageY;
	var pageX = e.pageX * zoomRatio;
	var pageY = e.pageY * zoomRatio;
	if(arg_pageX != void 0) pageX = arg_pageX;
	if(arg_pageY != void 0) pageY = arg_pageY;
	var coords = getTileCoordsFromMouseCoords(pageX, pageY);
	currentPosition = coords;
	currentPositionInitted = true;
	var tileX = coords[0];
	var tileY = coords[1];
	var charX = coords[2];
	var charY = coords[3];
	w.emit("mouseMove", {
		tileX: tileX,
		tileY: tileY,
		charX: charX,
		charY: charY,
		pageX: pageX,
		pageY: pageY
	});
	for(var i = 0; i < draggable_element_mousemove.length; i++) {
		draggable_element_mousemove[i](e, e.pageX, e.pageY);
	}
	updateHoveredLink(pageX, pageY, e);

	var canvasTarget = e.target == elm.owot;

	// region selecting
	for(var i = 0; i < regionSelections.length; i++) {
		var reg = regionSelections[i];
		if(!reg.isSelecting) continue;
		if(reg.lastSelectionHover) {
			var tileX = reg.lastSelectionHover[0];
			var tileY = reg.lastSelectionHover[1];
			var charX = reg.lastSelectionHover[2];
			var charY = reg.lastSelectionHover[3];
			if(reg.lastSelectionTiled) {
				if(Tile.get(tileX, tileY)) {
					Tile.get(tileX, tileY).backgroundColor = "";
				}
			} else {
				uncolorChar(tileX, tileY, charX, charY, "reg");
			}
			w.setTileRedraw(tileX, tileY);
		}
		reg.lastSelectionHover = currentPosition;
		reg.lastSelectionTiled = reg.tiled;
		var newTileX = currentPosition[0];
		var newTileY = currentPosition[1];
		var newCharX = currentPosition[2];
		var newCharY = currentPosition[3];
		if(canvasTarget && Tile.get(newTileX, newTileY)) {
			if(reg.tiled) {
				Tile.get(newTileX, newTileY).backgroundColor = reg.charColor;
			} else {
				colorClasses.reg = reg.charColor;
				colorChar(newTileX, newTileY, newCharX, newCharY, "reg");
			}
			// re-render tile
			w.setTileRedraw(newTileX, newTileY);
		}
		reg.regionCoordB = currentPosition;
		if(reg.regionCoordA && reg.regionCoordB) reg.setSelection(reg.regionCoordA, reg.regionCoordB);
	}

	// url/coordinate linking
	if(w.isLinking) {
		if(lastLinkHover) {
			var tileX = lastLinkHover[0];
			var tileY = lastLinkHover[1];
			var charX = lastLinkHover[2];
			var charY = lastLinkHover[3];
			uncolorChar(tileX, tileY, charX, charY, "link");
			w.setTileRedraw(tileX, tileY);
		}
		lastLinkHover = currentPosition;
		var newTileX = currentPosition[0];
		var newTileY = currentPosition[1];
		var newCharX = currentPosition[2];
		var newCharY = currentPosition[3];
		if(Tile.get(newTileX, newTileY)) {
			colorChar(newTileX, newTileY, newCharX, newCharY, "link");
			// re-render tile
			w.setTileRedraw(newTileX, newTileY);
		}
	}

	// tile protection
	if(!w.protectSelect.isSelecting && w.isProtecting) {
		if(lastTileHover) {
			var precision = lastTileHover[0];
			var tileX = lastTileHover[1];
			var tileY = lastTileHover[2];
			var charX = lastTileHover[3];
			var charY = lastTileHover[4];
			if(precision == 0) {
				if(Tile.get(tileX, tileY) && !tileProtectAuto.selected[tileY + "," + tileX]) {
					Tile.get(tileX, tileY).backgroundColor = "";
				}
			} else if(precision == 1) {
				uncolorChar(tileX, tileY, charX, charY, "prot");
				w.setTileRedraw(tileX, tileY);
			}
			w.setTileRedraw(tileX, tileY);
		}
		var cp = currentPosition;
		lastTileHover = [protectPrecision, cp[0], cp[1], cp[2], cp[3]];
		var newTileX = currentPosition[0];
		var newTileY = currentPosition[1];
		var newCharX = currentPosition[2];
		var newCharY = currentPosition[3];
		if(canvasTarget) {
			if(protectPrecision == 0) {
				if(Tile.get(newTileX, newTileY) && !tileProtectAuto.selected[newTileY + "," + newTileX]) {
					Tile.get(newTileX, newTileY).backgroundColor = w.protect_bg;
					w.setTileRender(newTileX, newTileY);
				}
			} else if(protectPrecision == 1) {
				if(Tile.get(newTileX, newTileY)) {
					colorClasses.prot = w.protect_bg;
					colorChar(newTileX, newTileY, newCharX, newCharY, "prot");
					w.setTileRedraw(newTileX, newTileY);
				}
			}
		}
	}

	if(!isDragging || regionSelectionsActive()) return;

	positionX = dragPosX + (pageX - dragStartX);
	positionY = dragPosY + (pageY - dragStartY);
	hasDragged = true;
	w.render();
}
document.addEventListener("mousemove", event_mousemove);
function event_touchmove(e) {
	var pos = touch_pagePos(e);
	touchPosX = pos[0];
	touchPosY = pos[1];
	if(closest(e.target, elm.main_view) || Modal.isOpen) {
		e.preventDefault();
	}
	event_mousemove(e, pos[0], pos[1]);
}
document.addEventListener("touchmove", event_touchmove, { passive: false });

// get position from touch event
function touch_pagePos(e) {
	var first_touch = e.touches[0];
	return [Math.trunc(first_touch.pageX * zoomRatio), Math.trunc(first_touch.pageY * zoomRatio)];
}

function event_wheel(e) {
	if(Modal.isOpen) return;
	if(!scrollingEnabled) return; // return if disabled
	// if focused on chat, don't scroll world
	if(closest(e.target, getChatfield())) return;
	if(closest(e.target, elm.confirm_js)) return;
	if(e.ctrlKey) return; // don't scroll if ctrl is down (zooming)
	var deltaX = Math.trunc(e.deltaX);
	var deltaY = Math.trunc(e.deltaY);
	if(e.deltaMode && deltaY) { // not zero (default)?
		deltaX = 0;
		deltaY = (deltaY / Math.abs(deltaY)) * 100;
	}
	if(checkKeyPress(e, keyConfig.sidewaysScroll)) { // if shift, scroll sideways
		deltaX = deltaY;
		deltaY = 0;
	}
	positionY -= deltaY;
	positionX -= deltaX;
	w.emit("scroll", {
		deltaX: -deltaX,
		deltaY: -deltaY
	});
	w.render();
}
document.addEventListener("wheel", event_wheel);

function convertKeyCode(key) {
	switch(key) {
		case "ESC": return "Escape";
		case "TAB": return "Tab";
		case "SPACE": return " ";
		case "PAGEUP": return "PageUp";
		case "PAGEDOWN": return "PageDown";
		case "UP": return "ArrowUp";
		case "DOWN": return "ArrowDown";
		case "LEFT": return "ArrowLeft";
		case "RIGHT": return "ArrowRight";
		case "CAPS": return "CapsLock";
		case "END": return "End";
		case "HOME": return "Home";
		case "INSERT": return "Insert";
		case "DELETE": return "Delete";
		case "PLUS": return "+";
		case "MINUS": return "-";
		case "ENTER": return "Enter";
		case "BACKSPACE": return "Backspace";
		case "COMMAND": return "Meta";
	}
	return key;
}

function checkKeyPress(e, combination) {
	// if combination arg is an array of combinations
	if(typeof combination == "object") {
		var res = false;
		for(var i = 0; i < combination.length; i++) {
			res = res || checkKeyPress(e, combination[i]);
		}
		return res;
	}
	combination = combination.split("+");
	var map = {
		ctrl: false,
		shift: false,
		alt: false,
		any: false, // does not check for ctrl/shift/alt
		key: ""
	};
	for(var i = 0; i < combination.length; i++) {
		var key = combination[i];
		switch(key) {
			case "CTRL": map.ctrl = true; break;
			case "SHIFT": map.shift = true; break;
			case "ALT": map.alt = true; break;
			case "*": map.any = true; break;
			default: map.key = convertKeyCode(key);
		}
	}
	if(!map.any) {
		if(map.ctrl != e.ctrlKey) return false;
		if(map.shift != e.shiftKey) return false;
		if(map.alt != e.altKey) return false;
	}
	if(e.keyCode == 37) e.key = "ArrowLeft";
	if(e.keyCode == 38) e.key = "ArrowUp";
	if(e.keyCode == 39) e.key = "ArrowRight";
	if(e.keyCode == 40) e.key = "ArrowDown";
	var eKey = e.key;
	// key must not be Ctrl/Shift/Alt because it's already stored in a boolean
	if(eKey == "Control") eKey = "";
	if(eKey == "Shift") eKey = "";
	if(eKey == "Alt") eKey = "";
	if(eKey != void 0) if(map.key.toUpperCase() != eKey.toUpperCase()) return false;
	return true;
}

// complex checking of key patterns
// e.g. Ctrl + A + B
function checkKeyPatterns(combination) {
	// if combination arg is an array of combinations
	if(typeof combination == "object") {
		var res = false;
		for(var i = 0; i < combination.length; i++) {
			res = res || checkKeyPatterns(e, combination[i]);
		}
		return res;
	}
	combination = combination.split("+");
	var keyMap = {};
	for(var i = 0; i < combination.length; i++) {
		var key = combination[i];
		switch(key) {
			case "CTRL": keyMap.Ctrl = 1; break;
			case "SHIFT": keyMap.Shift = 1; break;
			case "ALT": keyMap.Alt = 1; break;
			default: keyMap[convertKeyCode(key)] = 1;
		}
	}
	for(var k in keyMap) {
		if(!keydownTable[k]) return false;
	}
	for(var k in keydownTable) {
		if(!keyMap[k]) return false;
	}
	return true;
}

var fetchInterval;
var timesConnected = 0;
function createSocket() {
	socket = new ReconnectingWebSocket(ws_path);
	w.socket = socket;
	timesConnected++;

	socket.binaryType = "arraybuffer";
	socket.onmessage = function(msg) {
		var data = JSON.parse(msg.data);
		var kind = data.kind;
		if(ws_functions[kind]) {
			ws_functions[kind](data);
		}
	}

	socket.onopen = function(msg) {
		console.log("Connected socket");
		clearAllGuestCursors();
		for(var tile in tiles) {
			if(tiles[tile] == null) {
				delete tiles[tile];
				w.tile.count--;
			}
		}
		w.fetchUnloadedTiles();
		clearInterval(fetchInterval);
		fetchInterval = setInterval(function() {
			w.fetchUnloadedTiles();
		}, checkTileFetchInterval);
		if(timesConnected == 1) {
			if(Permissions.can_chat(state.userModel, state.worldModel)) {
				network.chathistory();
			}
		}
		timesConnected++;
		if(w.receivingBroadcasts) {
			w.broadcastReceive(true);
		}
		w.doAnnounce("", "err_connect");
		w.doAnnounce("", "err_access");
		w.doAnnounce("", "err_limit");
		clearTimeout(disconnectTimeout);
		disconnectTimeout = null;
	}

	socket.onclose = function() {
		console.log("Socket has closed. Reconnecting...");
		for(var i in network.callbacks) {
			var cb = network.callbacks[i];
			if(typeof cb == "function") {
				cb(null, true);
			}
		}
		if(!disconnectTimeout) {
			disconnectTimeout = setTimeout(function() {
				w.doAnnounce("Connection lost. Please wait until the client reconnects.", "err_connect");
			}, 1000 * 2);
		}
	}

	socket.onerror = function(err) {
		console.log("Socket error:", err);
	}
}

function cullRanges(map, width, height) {
	var completelyFilled = true;
	for(var i = 0; i < map.length; i++) {
		if(!map[i]) {
			completelyFilled = false;
			break;
		}
	}
	if(completelyFilled) return [];
	var ranges = [];
	var iterNum = 0;
	var lastStartX = 0;
	var lastStartY = 0;
	while(true) {
		var startX = lastStartX;
		var startY = lastStartY;
		var startFound = false;
		var boundX = width - 1;
		var boundY = height - 1;
		var wLen = 0;
		var hLen = 1;
		for(var i = startY * width + startX; i < width * height; i++) {
			if(!map[i]) {
				startX = i % width;
				startY = Math.floor(i / width);
				startFound = true;
				break;
			}
		}
		if(!startFound) break;
		for(var i = startX; i <= boundX; i++) {
			if(map[startY * width + i]) break;
			wLen++;
		}
		// first row is skipped
		for(var y = startY + 1; y <= boundY; y++) {
			var invRow = false;
			for(var i = startX; i <= startX + wLen - 1; i++) {
				if(map[y * width + i]) {
					invRow = true;
					break;
				}
			}
			if(invRow) {
				break;
			} else {
				hLen++;
			}
		}
		var endX = startX + wLen - 1;
		var endY = startY + hLen - 1;
		for(var y = startY; y <= endY; y++) {
			for(var x = startX; x <= endX; x++) {
				map[y * width + x] = true;
			}
		}
		lastStartX = startX;
		lastStartY = startY;
		ranges.push([startX, startY, endX, endY]);
		iterNum++;
		if(iterNum > width * height) break;
	}
	var totalArea = 0;
	for(var i = 0; i < ranges.length; i++) {
		var range = ranges[i];
		var width = Math.abs(range[2] - range[0]) + 1;
		var height = Math.abs(range[3] - range[1]) + 1;
		if(width * height > 50 * 50) {
			if(width > 50 && height > 50) {
				range[2] -= width - 50; // reduce width
				range[3] -= height - 50; // reduce height
				width = 50;
				height = 50;
			} else if(width > 50) {
				range[2] -= width - 50;
				width = 50;
			} else if(height > 50) {
				range[3] -= height - 50;
				height = 50;
			}
		}
		totalArea += width * height;
		if(totalArea > 5000) {
			ranges = ranges.slice(0, i);
			break;
		}
	}
	if(ranges.length > 50) ranges = ranges.slice(0, 50);
	return ranges;
}

// fetches only unloaded tiles
function getAndFetchTiles() {
	var viewWidth = getWidth(fetchClientMargin);
	var viewHeight = getHeight(fetchClientMargin);
	var viewArea = viewWidth * viewHeight;
	if(!viewArea) return;

	var visibleRange = getVisibleTileRange(fetchClientMargin);
	var startX = visibleRange[0][0];
	var startY = visibleRange[0][1];
	var endX = visibleRange[1][0];
	var endY = visibleRange[1][1];
	var map = [];
	for(var y = startY; y <= endY; y++) {
		for(var x = startX; x <= endX; x++) {
			map.push(Tile.exists(x, y));
		}
	}
	var ranges = cullRanges(map, viewWidth, viewHeight);

	var toFetch = [];
	for(var i = 0; i < ranges.length; i++) {
		var range = ranges[i];
		var bounds = {
			minX: range[0] + startX + tileFetchOffsetX,
			minY: range[1] + startY + tileFetchOffsetY,
			maxX: range[2] + startX + tileFetchOffsetX,
			maxY: range[3] + startY + tileFetchOffsetY
		};
		toFetch.push(bounds);
		bounds.minX = clipIntMax(bounds.minX);
		bounds.minY = clipIntMax(bounds.minY);
		bounds.maxX = clipIntMax(bounds.maxX);
		bounds.maxY = clipIntMax(bounds.maxY);
		for(var y = bounds.minY; y <= bounds.maxY; y++) {
			for(var x = bounds.minX; x <= bounds.maxX; x++) {
				Tile.set(x, y, null);
			}
		}
	}
	if(toFetch.length > 0) {
		network.fetch(toFetch);
	}
}

// clears all tiles outside the viewport (to free up memory)
function clearTiles(all) {
	var coordinates;
	var visible = {};
	if(!all) {
		coordinates = getVisibleTiles();
		// reference to tile coordinates (EG: "5,6")
		visible = {};
		for(var i = 0; i < coordinates.length; i++) {
			visible[coordinates[i][1] + "," + coordinates[i][0]] = 1;
		}
	}
	for(var i in tiles) {
		if(!(i in visible) || all) {
			var pos = getPos(i);
			Tile.delete(pos[1], pos[0]);
		}
	}
}

function clearVisibleTiles() {
	var visibleRange = getVisibleTileRange(fetchClientMargin);
	var startX = visibleRange[0][0];
	var startY = visibleRange[0][1];
	var endX = visibleRange[1][0];
	var endY = visibleRange[1][1];
	for(var y = startY; y <= endY; y++) {
		for(var x = startX; x <= endX; x++) {
			Tile.delete(x, y);
		}
	}
}

function highlight(positions, unlimited, color) {
	var r = defaultHighlightColor[0];
	var g = defaultHighlightColor[1];
	var b = defaultHighlightColor[2];
	if(!color) color = [r, g, b];
	for(var i = 0; i < positions.length; i++) {
		var tileX = positions[i][0];
		var tileY = positions[i][1];
		var charX = positions[i][2];
		var charY = positions[i][3];
		if(highlightCount > highlightLimit && !unlimited) return;
		if(!highlightFlash[tileY + "," + tileX]) {
			highlightFlash[tileY + "," + tileX] = {};
		}
		if(!highlightFlash[tileY + "," + tileX][charY]) {
			highlightFlash[tileY + "," + tileX][charY] = {};
		}
		if(!highlightFlash[tileY + "," + tileX][charY][charX]) {
			highlightFlash[tileY + "," + tileX][charY][charX] = [getDate(), color, color.slice(0)];
			highlightCount++;
		}
	}
}

var flashAnimateInterval = setInterval(function() {
	if(!highlightCount) return;
	var tileGroup = {}; // tiles to re-render after highlight
	var flashDuration = 500;
	for(var tile in highlightFlash) {
		for(var charY in highlightFlash[tile]) {
			for(var charX in highlightFlash[tile][charY]) {
				var data = highlightFlash[tile][charY][charX];
				var time = data[0];
				var diff = getDate() - time;
				// duration of 500 milliseconds
				if(diff >= flashDuration) {
					delete highlightFlash[tile][charY][charX];
					if(!Object.keys(highlightFlash[tile][charY]).length) {
						delete highlightFlash[tile][charY];
					}
					if(!Object.keys(highlightFlash[tile]).length) {
						delete highlightFlash[tile];
					}
					highlightCount--;
				} else {
					var pos = easeOutQuad(diff, 0, 1, flashDuration);
					var flashColor = highlightFlash[tile][charY][charX][2];
					var r = flashColor[0];
					var g = flashColor[1];
					var b = flashColor[2];
					var flashRGB = highlightFlash[tile][charY][charX][1];
					flashRGB[0] = r + (255 - r) * pos;
					flashRGB[1] = g + (255 - g) * pos;
					flashRGB[2] = b + (255 - b) * pos;
				}
				// mark tile to re-render
				tileGroup[tile] = 1;
			}
		}
	}
	// re-render tiles
	for(var i in tileGroup) {
		var pos = getPos(i);
		w.setTileRender(pos[1], pos[0]);
	}
}, 1000 / 60);

function blankTile() {
	var newTile = {
		content: new Array(tileArea).fill(" "),
		properties: {
			cell_props: {},
			writability: null,
			color: null
		}
	}
	newTile.properties.color = new Array(tileArea).fill(0);
	return newTile;
}

var colorClasses = {
	qprot0: "#DDD", // owner
	qprot1: "#EEE", // member
	qprot2: "#FFF", // public
	qprot3: "#FFF", // default
	qlink0: "#0000FF", // url
	qlink1: "#008000", // coord
	link: "#AAF",
	prot: "#000",
	reg: "#00F",
	err: "#BBC"
};

function colorChar(tileX, tileY, charX, charY, colorClass) {
	var container = coloredChars[tileY + "," + tileX];
	if(!container) {
		container = {};
		coloredChars[tileY + "," + tileX] = container;
	}
	if(!container[charY]) {
		container[charY] = {};
	}
	var list = container[charY][charX];
	if(!list) {
		container[charY][charX] = colorClass;
		return;
	}
	if(typeof list == "string") {
		if(list == colorClass) return;
		container[charY][charX] = [list, colorClass]; // transform string into array
		return;
	}
	var cidx = list.indexOf(colorClass);
	if(cidx > -1) {
		list.splice(cidx, 1);
	}
	list.push(colorClass);
}

function uncolorChar(tileX, tileY, charX, charY, colorClass) {
	var container = coloredChars[tileY + "," + tileX];
	if(!container) return false;
	if(!container[charY]) return false;
	var cell = container[charY][charX];
	if(!cell) return false;
	if(colorClass == void 0 || !colorClass) {
		delete container[charY][charX];
		return true;
	}
	var wildcard = colorClass[colorClass.length - 1] == "*";
	if(wildcard) {
		colorClass = colorClass.slice(0, -1);
	}
	if(typeof cell == "string") {
		if(wildcard) {
			if(cell.startsWith(colorClass)) {
				delete container[charY][charX];
			}
		} else if(cell == colorClass) {
			delete container[charY][charX];
		}
	} else {
		if(wildcard) {
			for(var i = 0; i < cell.length; i++) {
				if(cell[i].startsWith(colorClass)) {
					cell.splice(i, 1);
					i--;
				}
			}
		} else {
			var cidx = cell.indexOf(colorClass);
			if(cidx == -1) return false;
			cell.splice(cidx, 1);
		}
		if(!cell.length) {
			delete container[charY][charX];
		} else if(cell.length == 1) {
			container[charY][charX] = cell[0]; // transform array back to string
			return true;
		}
	}
	if(Object.keys(container[charY]).length == 0) {
		delete container[charY];
	}
	if(Object.keys(container).length == 0) {
		delete coloredChars[tileY + "," + tileX];
	}
	return true;
}

var isTileLoaded = Tile.loaded;
var isTileVisible = Tile.visible;

var brOrder = [1, 8, 2, 16, 4, 32, 64, 128];
var base64table = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

/*
	Writability format (tiles and chars):
		null: Writability of parent tile
		0: public
		1: members
		2: owners
*/
function decodeCharProt(str) {
	var res = new Array(tileArea).fill(0);
	var encoding = str.charAt(0);
	str = str.substr(1);
	if(encoding == "@") {
		for(var i = 0; i < str.length; i++) {
			var code = base64table.indexOf(str.charAt(i));
			var char1 = Math.trunc(code / (4*4) % 4);
			var char2 = Math.trunc(code / (4) % 4);
			var char3 = Math.trunc(code / (1) % 4);
			res[i*3 + 0] = char1;
			if(i*3 + 1 > tileArea - 1) break;
			res[i*3 + 1] = char2;
			if(i*3 + 2 > tileArea - 1) break;
			res[i*3 + 2] = char3;
		}
	} else if(encoding == "#") {
		var temp = str.split(",");
		for(var i = 0; i < temp.length; i++) {
			res[i] = parseInt(temp[i], 10);
		}
	} else if(encoding == "x") {
		for(var i = 0; i < str.length / 2; i++) {
			var code = parseInt(str.charAt(i * 2) + str.charAt(i * 2 + 1), 16);
			res[i] = code;
		}
	}
	// convert from base64-format to writability-format
	for(var c = 0; c < res.length; c++) {
		switch(res[c]) {
			case 0: res[c] = null; continue;
			case 1: res[c] = 0; continue;
			case 2: res[c] = 1; continue;
			case 3: res[c] = 2; continue;
		}
	}
	return res;
}
function encodeCharProt(array, encoding) {
	/*
		encodings:
			0: base64 - only 4 possible values
			1: number values
			2: hex values, values 0-255 only
	*/
	var arrayCom = array.slice(0);
	// convert array from writability-format to base64-format
	for(var c = 0; c < arrayCom.length; c++) {
		switch(arrayCom[c]) {
			case null: arrayCom[c] = 0; continue;
			case 0: arrayCom[c] = 1; continue;
			case 1: arrayCom[c] = 2; continue;
			case 2: arrayCom[c] = 3; continue;
		}
	}
	var str = "";
	if(!encoding) {
		str = "@";
		var bytes = Math.ceil(tileArea / 3);
		for(var i = 0; i < bytes; i++) {
			var idx = i * 3;
			var char1 = ((4*4)*arrayCom[idx + 0]);
			var char2 = ((4)*arrayCom[idx + 1]);
			var char3 = ((1)*arrayCom[idx + 2]);
			if(idx + 1 > tileArea - 1) char2 = 0;
			if(idx + 2 > tileArea - 1) char3 = 0;
			var code = char1 + char2 + char3;
			str += base64table.charAt(code);
		}
	} else if(encoding == 1) {
		str = "#" + arrayCom.join(",");
	} else if(encoding == 2) {
		str = "x";
		for(var i = 0; i < tileArea; i++) {
			var chr = arrayCom[i];
			str += chr.toString(16).padStart(2, 0).toUpperCase();
		}
	}
	return str;
}

function fillBlockChar(charCode, textRender, x, y) {
	if((charCode & 0x1FB00) != 0x1FB00 && (charCode & 0x2500) != 0x2500) return false; // symbols for legacy computing
	var transform = [0, 1]; // (left, right, up, down = 0, 1, 2, 3), percentage
	switch(charCode) { // 1/8 blocks
		case 0x2580: transform = [2, 4/8]; break;
		case 0x2581: transform = [3, 1/8]; break;
		case 0x2582: transform = [3, 2/8]; break;
		case 0x2583: transform = [3, 3/8]; break;
		case 0x2584: transform = [3, 4/8]; break;
		case 0x2585: transform = [3, 5/8]; break;
		case 0x2586: transform = [3, 6/8]; break;
		case 0x2587: transform = [3, 7/8]; break;
		case 0x2588: transform = [0, 8/8]; break; // full block
		case 0x2589: transform = [0, 7/8]; break;
		case 0x258A: transform = [0, 6/8]; break;
		case 0x258B: transform = [0, 5/8]; break;
		case 0x258C: transform = [0, 4/8]; break;
		case 0x258D: transform = [0, 3/8]; break;
		case 0x258E: transform = [0, 2/8]; break;
		case 0x258F: transform = [0, 1/8]; break;
		case 0x2590: transform = [1, 4/8]; break;
		case 0x2594: transform = [2, 1/8]; break;
		case 0x2595: transform = [1, 1/8]; break;
		case 0x1FB82: transform = [2, 2/8]; break;
		case 0x1FB83: transform = [2, 3/8]; break;
		case 0x1FB84: transform = [2, 5/8]; break;
		case 0x1FB85: transform = [2, 6/8]; break;
		case 0x1FB86: transform = [2, 7/8]; break;
		case 0x1FB87: transform = [1, 2/8]; break;
		case 0x1FB88: transform = [1, 3/8]; break;
		case 0x1FB89: transform = [1, 5/8]; break;
		case 0x1FB8A: transform = [1, 6/8]; break;
		case 0x1FB8B: transform = [1, 7/8]; break;
		default:
			if(charCode >= 0x2596 && charCode <= 0x259F) { // 2x2 blocks
				var pattern = [2, 1, 8, 11, 9, 14, 13, 4, 6, 7][charCode - 0x2596];
				if(pattern & 8) textRender.fillRect(x, y, cellW / 2, cellH / 2);
				if(pattern & 4) textRender.fillRect(x + cellW / 2, y, cellW / 2, cellH / 2);
				if(pattern & 2) textRender.fillRect(x, y + cellH / 2, cellW / 2, cellH / 2);
				if(pattern & 1) textRender.fillRect(x + cellW / 2, y + cellH / 2, cellW / 2, cellH / 2);
				return true;
			} else if(charCode >= 0x1FB00 && charCode <= 0x1FB3B) { // 2x3 blocks
				var code = 0;
				if(charCode >= 0x1FB00 && charCode <= 0x1FB13) code = charCode - 0x1FB00 + 1;
				if(charCode >= 0x1FB14 && charCode <= 0x1FB27) code = charCode - 0x1FB00 + 2;
				if(charCode >= 0x1FB28 && charCode <= 0x1FB3B) code = charCode - 0x1FB00 + 3;
				for(var i = 0; i < 6; i++) {
					if(!(code >> i & 1)) continue;
					textRender.fillRect(x + (cellW / 2) * (i & 1), y + (cellH / 3) * (i >> 1), cellW / 2, cellH / 3);
				}
				return true;
			} else {
				return false;
			}
	}
	var dir = transform[0];
	var frac = transform[1];

	var sx = x;
	var sy = y;
	var ex = sx + cellW;
	var ey = sy + cellH;

	switch(dir) {
		case 0: ex -= cellW - (cellW * frac); break;
		case 1: sx += cellW - (cellW * frac); break;
		case 2: ey -= cellH - (cellH * frac); break;
		case 3: sy += cellH - (cellH * frac); break;
	}
	if(zoom != 1 && ex - sx > 1 && ey - sy > 1) {
		sx = Math.round(sx);
		sy = Math.round(sy);
		ex = Math.round(ex);
		ey = Math.round(ey);
	}

	textRender.fillRect(sx, sy, ex - sx, ey - sy);
	return true;
}

// TODO: simplify args
function renderChar(textRender, x, y, str, content, colors, writability, props, offsetX, offsetY, charOverflowMode) {
	// adjust baseline
	var textYOffset = cellH - (5 * zoom);

	var fontX = x * cellW + offsetX;
	var fontY = y * cellH + offsetY;

	var char = content[y * tileC + x];
	if(!char) char = " ";
	var cCode = char.codePointAt(0);
	var isSpecial = char.codePointAt(1) !== void 0; // contains combining chars? (not compatible with Courier New)
	if(charOverflowMode) {
		if(cCode < 1024) return;
		if(cCode == 0xFDFD) return;
		if(cCode >= 0x12427 && cCode <= 0x1242B) return;
	}

	// fill background if defined
	if(coloredChars[str] && coloredChars[str][y] && coloredChars[str][y][x]) {
		var color = coloredChars[str][y][x];
		if(Array.isArray(color)) {
			color = color[color.length - 1];
		}
		color = colorClasses[color];
		textRender.fillStyle = color;
		textRender.fillRect(fontX, fontY, cellW, cellH);
	}

	var color = colors ? colors[y * tileC + x] : 0;
	// initialize link color to default text color in case there's no link to color
	var linkColor = styles.text;
	if(textColorOverride) {
		if(writability == 0 && textColorOverride & 4) linkColor = styles.public_text;
		if(writability == 1 && textColorOverride & 2) linkColor = styles.member_text;
		if(writability == 2 && textColorOverride & 1) linkColor = styles.owner_text;
	}

	var isLink = false;

	// check if this char is a link
	if(linksRendered && props[y] && props[y][x]) {
		var link = props[y][x].link;
		if(link) {
			isLink = true;
			if(link.type == "url") {
				linkColor = defaultURLLinkColor;
			} else if(link.type == "coord") {
				linkColor = defaultCoordLinkColor;
			}
		}
	}

	// if text has no color, use default text color. otherwise, colorize it
	if(color == 0 || !colorsEnabled || (isLink && !colorizeLinks)) {
		textRender.fillStyle = linkColor;
	} else {
		textRender.fillStyle = "rgb(" + (color >> 16 & 255) + "," + (color >> 8 & 255) + "," + (color & 255) + ")";
	}

	// x padding of text if the char width is > 10
	var XPadding = cellWidthPad * zoom;

	// underline link
	if(isLink) {
		textRender.fillRect(fontX, fontY + textYOffset + zoom, cellW, zoom);
	}

	// don't render whitespaces
	if(cCode == 0x0020 || cCode == 0x00A0) return;

	if(brBlockFill && (cCode & 0x2800) == 0x2800) { // render braille chars as rectangles
		var dimX = cellW / 2;
		var dimY = cellH / 4;
		for(var b = 0; b < 8; b++) {
			if((cCode & brOrder[b]) == 0) continue;
			textRender.fillRect(fontX + (b % 2) * dimX, fontY + ((b / 2) | 0) * dimY, dimX, dimY);
		}
	} else if(ansiBlockFill && fillBlockChar(cCode, textRender, fontX, fontY)) {
		return;
	} else { // character rendering
		if(isSpecial) textRender.font = specialCharFont;
		textRender.fillText(char, Math.round(fontX + XPadding), Math.round(fontY + textYOffset));
		if(isSpecial) textRender.font = font;
	}
}

function drawGrid(renderCtx, gridColor, offsetX, offsetY) {
	if(subgridEnabled && zoom >= 0.3) {
		var b = 0xB9;
		if(zoom < 0.5) {
			b += (0xFF - b) * (0.5 - zoom) * 2;
		}
		b = Math.floor(b);
		renderCtx.strokeStyle = "rgb(" + b + ", " + b + ", " + b + ")";
		var dashSize = 1
		renderCtx.setLineDash([dashSize]);
		renderCtx.lineWidth = dashSize;
		for(var x = 1; x < tileC; x++) {
			for(var y = 1; y < tileR; y++) {
				renderCtx.beginPath();
				renderCtx.moveTo(0, Math.floor(y * cellH) + 0.5);
				renderCtx.lineTo(tileW, Math.floor(y * cellH) + 0.5);
				renderCtx.stroke();
			}
			renderCtx.beginPath();
			renderCtx.moveTo(Math.floor(x * cellW) + 0.5, 0);
			renderCtx.lineTo(Math.floor(x * cellW) + 0.5, tileH);
			renderCtx.stroke();
		}
	}
	renderCtx.fillStyle = gridColor;
	renderCtx.fillRect(Math.floor(offsetX), Math.floor(offsetY), tileWidth, 1);
	renderCtx.fillRect(Math.floor(offsetX), Math.floor(offsetY), 1, tileHeight);
}

function drawObstructedCursor(renderCtx, content, curX, curY, offsetX, offsetY) {
	var idx = curY * tileC + curX;
	// if the char is a full block, force the cursor over it.
	if(content) {
		if(content[idx] == "\u2588") {
			renderCtx.fillStyle = styles.cursor;
			renderCtx.fillRect(offsetX + curX * cellW, offsetY + curY * cellH, cellW, cellH);
		}
	}
}

function renderTileBackground(renderCtx, offsetX, offsetY, tile, tileX, tileY, cursorVisibility) {
	var computed_writability = tile.properties.writability;
	if(computed_writability == null) computed_writability = state.worldModel.writability;
	
	if(!tile.backgroundColor) {
        if(computed_writability == -1) owotCtx.fillStyle = "#CCC";
		if(computed_writability == 0) renderCtx.fillStyle = styles.public;
		if(computed_writability == 1) renderCtx.fillStyle = styles.member;
		if(computed_writability == 2) renderCtx.fillStyle = styles.owner;
	} else {
		renderCtx.fillStyle = tile.backgroundColor;
	}
	var backColor = renderCtx.fillStyle;

	var clamp, clampW, clampH;
	if(transparentBackground) {
		clamp = getTileScreenPosition(tileX + 1, tileY + 1);
		clampW = Math.floor(clamp[0]) - offsetX;
		clampH = Math.floor(clamp[1]) - offsetY;
	} else {
		// in opaque mode, the offsets are always (0, 0) within the text-render tile
		// in transparent mode, backgrounds are placed directly on the main canvas
		clampW = tileWidth;
		clampH = tileHeight;
	}

	// fill tile background color
	renderCtx.fillRect(offsetX, offsetY, clampW, clampH);

	// render char protections
	if(tile.properties.char && !tile.backgroundColor) {
		for(var p = 0; p < tileArea; p++) {
			var code = tile.properties.char[p]; // writability
			var cX = p % tileC;
			var cY = Math.floor(p / tileC);
			if(code != null) {
                if(code == -1) owotCtx.fillStyle = "#CCC";
				if(code == 0) renderCtx.fillStyle = styles.public;
				if(code == 1) renderCtx.fillStyle = styles.member;
				if(code == 2) renderCtx.fillStyle = styles.owner;
				if(cellW >= 1 && cellH >= 1) {
					// clamp to next position in axis
					var tmpCellW = clampW / tileC;
					var tmpCellH = clampH / tileR;
					var sx = Math.floor(cX * tmpCellW);
					var sy = Math.floor(cY * tmpCellH);
					var x2 = Math.floor((cX + 1) * tmpCellW);
					var y2 = Math.floor((cY + 1) * tmpCellH);
					renderCtx.fillRect(offsetX + sx, offsetY + sy, x2 - sx, y2 - sy);
				} else {
					renderCtx.fillRect(offsetX + cX * cellW, offsetY + cY * cellH, cellW, cellH);
				}
			}
		}
	}

	if(guestCursorsEnabled) {
		renderGuestCursors(renderCtx, offsetX, offsetY, tile, tileX, tileY);
	}

	// render cursor
	if(cursorVisibility) {
		var charX = cursorCoords[2];
		var charY = cursorCoords[3];
		renderCtx.fillStyle = styles.cursor;
		renderCtx.fillRect(offsetX + charX * cellW, offsetY + charY * cellH, cellW, cellH);
	}

	var highlight = highlightFlash[tileY + "," + tileX];
	if(highlight) { // highlighted edits
		for(var y = 0; y < tileR; y++) {
			for(var x = 0; x < tileC; x++) {
				if(highlight[y]) {
					if(highlight[y][x] !== void 0) {
						var flashRGB = highlight[y][x][1];
						renderCtx.fillStyle = "rgb(" + flashRGB[0] + "," + flashRGB[1] + "," + flashRGB[2] + ")";
						renderCtx.fillRect(offsetX + x * cellW, offsetY + y * cellH, cellW, cellH);
					}
				}
			}
		}
	}
	return backColor;
}

function renderTileBackgroundImage(renderCtx, tileX, tileY, ctxOffX, ctxOffY) {
	var startX = tileX * tileWidth;
	var startY = tileY * tileHeight;
	
	var backRatioW = tileWidth / dTileW;
	var backRatioH = tileHeight / dTileH;

	var imgWidth = backgroundPatternSize[0];
	var imgHeight = backgroundPatternSize[1];

	var repeat = w.backgroundInfo.rmod;
	var offX = w.backgroundInfo.x;
	var offY = w.backgroundInfo.y;
	var patWidth = w.backgroundInfo.w;
	var patHeight = w.backgroundInfo.h;
	var alpha = w.backgroundInfo.alpha;

	if(!patWidth) patWidth = imgWidth;
	if(!patHeight) patHeight = imgHeight;

	startX += offX * backRatioW;
	startY += offY * backRatioH;

	backRatioW *= patWidth / imgWidth;
	backRatioH *= patHeight / imgHeight;

	/*
		0: repeat
		1: center
		2: singular
	*/
	if(repeat == 0) {
		if(!window.DOMMatrix || !backgroundPattern) return false;
		backgroundPattern.setTransform(new DOMMatrix([backRatioW, 0, 0, backRatioH, -startX, -startY]));
		renderCtx.fillStyle = backgroundPattern;
		renderCtx.globalAlpha = alpha;
		renderCtx.fillRect(ctxOffX, ctxOffY, tileWidth, tileHeight);
		renderCtx.globalAlpha = 1;
		return true;
	} else if(repeat == 1 || repeat == 2) {
		if(!backgroundImage) return false;
		if(repeat == 1) {
			startX += Math.floor(imgWidth / 2) * backRatioW;
			startY += Math.floor(imgHeight / 2) * backRatioH;
		}
		renderCtx.globalAlpha = alpha;
		renderCtx.drawImage(backgroundImage, -startX + ctxOffX, -startY + ctxOffY, imgWidth * backRatioW, imgHeight * backRatioH);
		renderCtx.globalAlpha = 1;
		return true;
	}
	return false;
}

function clearTile(tileX, tileY) {
	if(!Tile.visible(tileX, tileY)) return;
	var tileScreenPos = getTileScreenPosition(tileX, tileY);
	var offsetX = Math.floor(tileScreenPos[0]);
	var offsetY = Math.floor(tileScreenPos[1]);
	owotCtx.clearRect(offsetX, offsetY, tileWidth, tileHeight);
}

function renderContent(textRenderCtx, tileX, tileY, offsetX, offsetY, bounds, charOverflowMode) {
	var str = tileY + "," + tileX;
	var tile = Tile.get(tileX, tileY);
	if(!tile) return;
	var content = tile.content;
	var colors = tile.properties.color;
	var props = tile.properties.cell_props || {};
	var writability = tile.writability;
	if(priorityOverwriteChar && tile.properties.char) { // TODO: doesn't work right
		for(var lev = 0; lev < 3; lev++) {
			for(var c = 0; c < tileArea; c++) {
				var code = tile.properties.char[c]; // writability
				if(code == null) code = tile.properties.writability;
				if(code == null) code = state.worldModel.writability;
				if(code != lev) continue;
				var cX = c % tileC;
				var cY = Math.floor(c / tileC);
				textRenderCtx.clearRect(cX * cellW, cY * cellH, cellW, cellH);
				renderChar(textRenderCtx, cX, cY, str, content, colors, code, props, offsetX, offsetY);
			}
		}
	} else {
		var x1 = 0;
		var y1 = 0;
		var x2 = tileC - 1;
		var y2 = tileR - 1;
		if(bounds) {
			x1 = bounds[0];
			y1 = bounds[1];
			x2 = bounds[2];
			y2 = bounds[3];
		}
		for(var y = y1; y <= y2; y++) {
			for(var x = x1; x <= x2; x++) {
				var protValue = writability;
				if(tile.properties.char) {
					protValue = tile.properties.char[y * tileC + x];
				}
				if(protValue == null) protValue = tile.properties.writability;
				if(protValue == null) protValue = state.worldModel.writability;
				renderChar(textRenderCtx, x, y, str, content, colors, protValue, props, offsetX, offsetY, charOverflowMode);
			}
		}
	}
};
            
function lockChar(tx, ty, cx, cy) {
    const tile = tiles[`${ty},${tx}`];
    let charProtArr = tile.properties.char;

    if(!charProtArr) {
        charProtArr = new Array(128).fill(0);
    };

    charProtArr[cy*16+cx] = -1;

    tile.properties.char = charProtArr;
    renderTile(tx, ty, 1);
};

function renderTile(tileX, tileY, redraw) {
	if(!Tile.loaded(tileX, tileY)) return;
	var tileScreenPos = getTileScreenPosition(tileX, tileY);
	var offsetX = Math.floor(tileScreenPos[0]);
	var offsetY = Math.floor(tileScreenPos[1]);

	var tile = Tile.get(tileX, tileY);
	if(redraw) {
		tile.redraw = true;
	}
	if(!Tile.visible(tileX, tileY)) return;

	var clamp = getTileScreenPosition(tileX + 1, tileY + 1);
	var clampW = Math.floor(clamp[0]) - offsetX;
	var clampH = Math.floor(clamp[1]) - offsetY;

	var cursorVisibility = cursorRenderingEnabled && cursorCoords && cursorCoords[0] == tileX && cursorCoords[1] == tileY;

	var gridColor = "#000000";
	if(transparentBackground) {
		var backColor = renderTileBackground(owotCtx, offsetX, offsetY, tile, tileX, tileY, cursorVisibility);
		if(gridEnabled) {
			gridColor = int_to_hexcode(0xFFFFFF - resolveColorValue(backColor));
		}
	} else {
		var backgroundUpdated = false;
		var hasHighlightFlash = highlightFlash[tileY + "," + tileX];
		if(hasHighlightFlash) {
			backgroundUpdated = true;
			tile.tp_highlight = true;
		} else {
			if(tile.tp_highlight) {
				backgroundUpdated = true;
				delete tile.tp_highlight;
			}
		}
		if(cursorVisibility) {
			backgroundUpdated = true;
			tile.tp_cursor = true;
		} else if(tile.tp_cursor) {
			backgroundUpdated = true;
			delete tile.tp_cursor;
		}
		if(backgroundUpdated) {
			tile.redraw = true;
		}
	}

	// render text data from cache
	var tilePool = loadTileFromPool(tileX, tileY, true);
	if(tilePool && !tile.redraw) {
		var pCanv = tilePool.pool.canv;
		var pX = tilePool.poolX;
		var pY = tilePool.poolY;
		owotCtx.drawImage(pCanv, pX, pY, clampW, clampH, offsetX, offsetY, clampW, clampH);
		if(w.events.tilerendered) w.emit("tileRendered", {
			tileX: tileX, tileY: tileY,
			startX: offsetX, startY: offsetY,
			endX: offsetX + clampW - 1, endY: offsetY + clampH - 1
		});
		if(cursorRenderingEnabled && cursorCoords && cursorCoords[0] == tileX && cursorCoords[1] == tileY) {
			if(unobstructCursor) {
				drawObstructedCursor(owotCtx, tile.content, cursorCoords[2], cursorCoords[3], offsetX, offsetY);
			}
			if(cursorOutlineEnabled) {
				renderCursorOutline(owotCtx, offsetX, offsetY, tileX, tileY);
			}
		}
		return;
	}
	if(tile.redraw) {
		delete tile.redraw;
	}

	tilePool = loadTileFromPool(tileX, tileY);
	var poolCtx = tilePool.pool.ctx;
	var poolCanv = tilePool.pool.canv;
	var poolX = tilePool.poolX;
	var poolY = tilePool.poolY;

	if(transparentBackground) {
		textRenderCtx.clearRect(0, 0, textRenderCanvas.width, textRenderCanvas.width);
	} else {
		renderTileBackground(textRenderCtx, 0, 0, tile, tileX, tileY, cursorVisibility);
	}

	if(backgroundEnabled) {
		renderTileBackgroundImage(textRenderCtx, tileX, tileY, 0, 0);
	}

	// temp compat
	if(typeof tile.content == "string") {
		tile.content = w.split(tile.content);
	}

	if(!bufferLargeChars || priorityOverwriteChar) {
		renderContent(textRenderCtx, tileX, tileY, 0, 0);
	} else {
		renderContent(textRenderCtx, tileX - 1, tileY, tileW * -1, 0, [tileC - 1, 0, tileC - 1, tileR - 1], true); // left
		renderContent(textRenderCtx, tileX, tileY, 0, 0); // main
		renderContent(textRenderCtx, tileX - 1, tileY + 1, tileW * -1, tileH * 1, [tileC - 1, 0, tileC - 1, 0], true); // bottom-left corner
		renderContent(textRenderCtx, tileX, tileY + 1, 0, tileH * 1, [0, 0, tileC - 1, 0], true); // bottom
	}

	if(gridEnabled) {
		drawGrid(textRenderCtx, gridColor, 0, 0);
	}

	// add image to tile pool
	poolCtx.clearRect(poolX, poolY, tileWidth, tileHeight);
	poolCtx.drawImage(textRenderCanvas, 0, 0, tileWidth, tileHeight, poolX, poolY, tileWidth, tileHeight);

	// add image to main canvas
	owotCtx.drawImage(textRenderCanvas, 0, 0, clampW, clampH, offsetX, offsetY, clampW, clampH);

	if(cursorRenderingEnabled && cursorCoords && cursorCoords[0] == tileX && cursorCoords[1] == tileY) {
		if(unobstructCursor) {
			drawObstructedCursor(owotCtx, tile.content, cursorCoords[2], cursorCoords[3], offsetX, offsetY);
		}
		if(cursorOutlineEnabled) {
			renderCursorOutline(owotCtx, offsetX, offsetY, tileX, tileY);
		}
	}

	if(w.events.tilerendered) w.emit("tileRendered", {
		tileX: tileX, tileY: tileY,
		startX: offsetX, startY: offsetY,
		endX: offsetX + clampW - 1, endY: offsetY + clampH - 1
	});
}

function renderTiles(redraw) {
	w.emit("beforeTilesRendered");
	updateCoordDisplay();
	if(unloadedPatternPanning) {
		elm.owot.style.backgroundPosition = positionX + "px " + positionY + "px";
	}
	var optShifted = false;
	var canOptimizeShift = shiftOptimization && zoom <= 0.5 && shiftOptState.zoom == zoom;
	if(!canOptimizeShift) {
		owotCtx.clearRect(0, 0, owotWidth, owotHeight);
	} else {
		owotCtx.drawImage(owot, Math.floor(positionX) - shiftOptState.prevX, Math.floor(positionY) - shiftOptState.prevY);
		optShifted = true;
	}
	if(redraw) w.setRedraw();
	// render all visible tiles
	var visibleRange = getVisibleTileRange(1.0);
	var startX = visibleRange[0][0];
	var startY = visibleRange[0][1];
	var endX = visibleRange[1][0];
	var endY = visibleRange[1][1];
	for(var y = startY; y <= endY; y++) {
		for(var x = startX; x <= endX; x++) {
			var tile = Tile.get(x, y);
			var shouldRender = false;
			if(tile) {
				shouldRender = tile.redraw || tile.rerender;
			}
			if(optShifted && !shouldRender) {
				if(!(shiftOptState.x1 < x && x < shiftOptState.x2 && shiftOptState.y1 < y && y < shiftOptState.y2)) {
					renderTile(x, y);
				}
			} else {
				renderTile(x, y);
			}
			if(optShifted && !Tile.loaded(x, y)) {
				clearTile(x, y);
			}
		}
	}
	if(shiftOptimization) {
		shiftOptState.prevX = Math.floor(positionX);
		shiftOptState.prevY = Math.floor(positionY);
		shiftOptState.x1 = startX;
		shiftOptState.y1 = startY;
		shiftOptState.x2 = endX;
		shiftOptState.y2 = endY;
		shiftOptState.zoom = zoom;
	}
	w.emit("tilesRendered");
}

// re-render only tiles that have changed to the screen
function renderTilesSelective() {
	var visibleRange = getVisibleTileRange(1.0);
	var startX = visibleRange[0][0];
	var startY = visibleRange[0][1];
	var endX = visibleRange[1][0];
	var endY = visibleRange[1][1];
	for(var y = startY; y <= endY; y++) {
		for(var x = startX; x <= endX; x++) {
			var tile = Tile.get(x, y);
			if(!tile) continue;
			if(tile.rerender) {
				delete tile.rerender;
				renderTile(x, y);
				continue;
			}
			if(!tile.redraw) continue;
			renderTile(x, y);
		}
	}
}

function renderGuestCursors(renderCtx, offsetX, offsetY, tile, tileX, tileY) {
	var tilePos = tileY + "," + tileX;
	var list = guestCursorsByTile[tilePos];
	for(var channel in list) {
		var cursor = list[channel];
		var charX = cursor.charX;
		var charY = cursor.charY;
		renderCtx.fillStyle = styles.guestCursor;
		renderCtx.fillRect(offsetX + charX * cellW, offsetY + charY * cellH, cellW, cellH);
	}
}

function clearAllGuestCursors() {
	for(var i in guestCursorsByTile) {
		var pos = i.split(",");
		var tileX = parseInt(pos[1]);
		var tileY = parseInt(pos[0]);
		for(var x in guestCursorsByTile[i]) {
			delete guestCursors[x];
			delete guestCursorsByTile[i][x];
		}
		w.setTileRedraw(tileX, tileY);
	}
}

function renderCursorOutline(renderCtx, offsetX, offsetY) {
	if(!cursorCoords) return;
	var color = YourWorld.Color;
	var tileX = cursorCoords[0];
	var tileY = cursorCoords[1];
	var charX = cursorCoords[2];
	var charY = cursorCoords[3];
	renderCtx.strokeStyle = "rgb(" + (color >> 16 & 255) + "," + (color >> 8 & 255) + "," + (color & 255) + ")";
	renderCtx.lineWidth = 2;
	renderCtx.beginPath();
	renderCtx.rect(offsetX + charX * cellW + 1, offsetY + charY * cellH + 1, cellW - 2, cellH - 2);
	renderCtx.stroke();
}

function renderLoop() {
	if(w.hasUpdated) {
		renderTiles();
		updateHoveredLink(null, null, null, true);
	} else if(w.hasSelectiveUpdated) {
		renderTilesSelective();
	}
	w.hasUpdated = false;
	w.hasSelectiveUpdated = false;
	w.emit("frame"); // emitted after update flags are reset
	if(!writeBuffer.length) sendCursorPosition();
	requestAnimationFrame(renderLoop);
}

function protectPrecisionOption(option) {
	protectPrecision = option;
	removeTileProtectHighlight();
	var tileChoiceColor = "";
	var charChoiceColor = "";
	if(option == 0) { // tile
		tileChoiceColor = "#FF6600";
		if(w.protectSelect) w.protectSelect.tiled = true;
	} else if(option == 1) { // char
		charChoiceColor = "#FF6600";
		if(w.protectSelect) w.protectSelect.tiled = false;
	}
	elm.tile_choice.style.backgroundColor = tileChoiceColor;
	elm.char_choice.style.backgroundColor = charChoiceColor;
}
protectPrecisionOption(protectPrecision);

function protectSelectionStart(start, end, width, height) {
	var tileX1 = start[0];
	var tileY1 = start[1];
	var charX1 = start[2];
	var charY1 = start[3];
	var tileX2 = end[0];
	var tileY2 = end[1];
	var charX2 = end[2];
	var charY2 = end[3];
	var tileList = [];
	var charList = {};
	if(protectPrecision == 0) {
		// only tiles
		for(var y = tileY1; y <= tileY2; y++) {
			for(var x = tileX1; x <= tileX2; x++) {
				tileList.push([x, y]);
				autoTotal++;
			}
		}
	} else if(protectPrecision == 1) {
		var tx1 = tileX1;
		var ty1 = tileY1;
		var tx2 = tileX2;
		var ty2 = tileY2;
		if(charX1) tx1++;
		if(charY1) ty1++;
		if(charX2 < 15) tx2--;
		if(charY2 < 7) ty2--;
		// full tiles
		for(var y = ty1; y <= ty2; y++) {
			for(var x = tx1; x <= tx2; x++) {
				tileList.push([x, y]);
				autoTotal++;
			}
		}
		var tw = tx2 - tx1 + 1;
		var th = ty2 - ty1 + 1;

		var tx = tileX1;
		var ty = tileY1;
		var cx = charX1;
		var cy = charY1;
		for(var y = 0; y < height; y++) {
			for(var x = 0; x < width; x++) {
				// skip over gap
				if(tw && ty >= ty1 && ty <= ty2 && tx >= tx1 && tx <= tx2) {
					tx = tx2 + 1;
					x += tw * 16 - 1;
					continue;
				}
				var pos = ty + "," + tx;
				if(!charList[pos]) charList[pos] = [];
				charList[pos].push([cx, cy]);
				autoTotal++;
				cx++;
				if(cx >= 16) {
					cx = 0;
					tx++;
				}
			}
			cy++;
			if(cy >= 8) {
				cy = 0;
				ty++;
			}
			tx = tileX1;
			cx = charX1;
		}
	}

	var types = ["public", "member-only", "owner-only"];
	var protType;
	if(w.protect_type == null) {
		protType = "unprotect";
	} else {
		protType = types[w.protect_type];
	}

	updateAutoProg();
	var keys = Object.keys(charList);
	var keyIdx = -1;
	var keyPos = [];
	var itemIdx = 0;
	// character-precision
	cprot: while(true) { // (MOD)
		var list = charList[keys[keyIdx]];
		if(keyIdx == -1 || itemIdx >= list.length) {
			itemIdx = 0;
			keyIdx++;
			if(keyIdx >= keys.length) {
				break cprot; // (MOD)
			}
			keyPos = keys[keyIdx].split(",").reverse().map(Number);
			continue;
		}
		var item = list[itemIdx];
		var tileX = keyPos[0];
		var tileY = keyPos[1];
		var charX = item[0];
		var charY = item[1];
		network.protect({
			tileX: tileX, tileY: tileY,
			charX: charX, charY: charY
		}, protType);
		autoTotal--;
		updateAutoProg();
		itemIdx++;
	} // (MOD)

	// full tiles
	var tidx = 0;
	tprot: while(true) { // (MOD)
		if(tidx >= tileList.length) {
			break tprot; // (MOD)
		}
		var pos = tileList[tidx];
		var tileX = pos[0];
		var tileY = pos[1];
		network.protect({
			tileX: tileX,
			tileY: tileY
		}, protType);
		tidx++;
		autoTotal--;
		updateAutoProg();
	} // (MOD)
	w.protectSelect.startSelection();
}

function protectSelectionCancel() {
	elm.protect_selection.style.color = "";
}

function protectSelection() {
	if(w.protectSelect.isSelecting) {
		elm.protect_selection.style.color = "";
		w.protectSelect.stopSelectionUI();
	} else {
		elm.protect_selection.style.color = "#F3DB65";
		w.protectSelect.startSelection();
	}
}

var menu;
function buildMenu() {
	menu = new Menu(elm.menu_elm, elm.nav_elm);
	w.menu = menu;
	
	// (MOD)
	menu.addOption("About...", function() {
		alert("OfflineOWOT Build 4\n=================\nThis is a single-page client that simulates the OWOT server. Changes do not save when you refresh unless you export your world.");
	});

	menuOptions.showCoords = menu.addCheckboxOption("Show coordinates", function() {
		return elm.coords.style.display = "";
	}, function() {
		return elm.coords.style.display = "none";
	});
	menuOptions.changeColor = menu.addOption("Change color", w.color);
	menuOptions.goToCoords = menu.addOption("Go to coordinates", w.goToCoord);
	menuOptions.coordLink = menu.addOption("Create link to coordinates", w.coordLink);
	menuOptions.urlLink = menu.addOption("Create link to URL", w.urlLink);
	menuOptions.ownerArea = menu.addOption("Make an area owner-only", function() {
		return w.doProtect("owner-only");
	});
	menuOptions.memberArea = menu.addOption("Make an area member-only", function() {
		return w.doProtect("member-only");
	});
	menuOptions.publicArea = menu.addOption("Make an area public", function() {
		return w.doProtect("public");
	});
	menuOptions.resetArea = menu.addOption("Default area protection", w.doUnprotect);

	menuOptions.grid = menu.addCheckboxOption("Toggle grid", function() {
		gridEnabled = true;
		w.render(true);
		menu.showEntry(menuOptions.subgrid);
	}, function() {
		gridEnabled = false;
		w.render(true);
		menu.hideEntry(menuOptions.subgrid);
	});
	menuOptions.subgrid = menu.addCheckboxOption("Subgrid", function() {
		subgridEnabled = true;
		w.render(true);
	}, function() {
		subgridEnabled = false;
		w.render(true);
	});
	menu.hideEntry(menuOptions.subgrid);
	menuOptions.linksEnabled = menu.addCheckboxOption("Links enabled", function() {
		linksEnabled = true;
	}, function() {
		linksEnabled = false;
	}, true);
	menuOptions.colorsEnabled = menu.addCheckboxOption("Colors enabled", function() {
		w.enableColors();
	}, function() {
		w.disableColors();
	}, true);
	if(state.background) {
		menuOptions.backgroundEnabled = menu.addCheckboxOption("Background", function() {
			backgroundEnabled = true;
			w.render(true);
		}, function() {
			backgroundEnabled = false;
			w.render(true);
		}, true);
	}
	menu.addEntry("<div><input type=\"file\" id=\"import_world\" multiple /> Import world</div>"); // (MOD)
	menu.addOption("Export world", function() { // (MOD)
		exportWorld();
	});
	menu.addOption("Clear world", function() { // (MOD)
		var con = confirm("Are you sure you want to clear this world? This cannot be undone.");
		if (con) {
			tile_database = {};
			clearTiles(true);
			getAndFetchTiles();
		}
	});
	var zoomBar = document.createElement("input");
	zoomBar.onchange = function() {
		var val = this.value;
		val /= 100;
		if(val < 0 || val > 1) val = 0.5;
		val = toLogZoom(val);
		changeZoom(val * 100);
	}
	zoomBar.ondblclick = function() {
		changeZoom(100);
	}
	zoomBar.title = "Zoom";
	zoomBar.type = "range";
	zoomBar.value = 50;
	zoomBar.min = 1;
	zoomBar.max = 100;
	zoomBar.id = "zoombar";
	var zoombarId = menu.addEntry(zoomBar);
	menu.zoombarId = zoombarId;
	menuOptions.zoom = zoombarId;
}

function updateMenuEntryVisiblity() {
	var permColorText = Permissions.can_color_text(state.userModel, state.worldModel);
	var permGoToCoord = Permissions.can_go_to_coord(state.userModel, state.worldModel);
	var permCoordLink = Permissions.can_coordlink(state.userModel, state.worldModel);
	var permUrlLink = Permissions.can_urllink(state.userModel, state.worldModel);
	var permOwnerArea = Permissions.can_admin(state.userModel, state.worldModel);
	var permMemberArea = Permissions.can_protect_tiles(state.userModel, state.worldModel);
	w.menu.setEntryVisibility(menuOptions.changeColor, permColorText);
	w.menu.setEntryVisibility(menuOptions.goToCoords, permGoToCoord);
	w.menu.setEntryVisibility(menuOptions.coordLink, permCoordLink);
	w.menu.setEntryVisibility(menuOptions.urlLink, permUrlLink);
	w.menu.setEntryVisibility(menuOptions.ownerArea, permOwnerArea);
	w.menu.setEntryVisibility(menuOptions.memberArea, permMemberArea);
	w.menu.setEntryVisibility(menuOptions.publicArea, permMemberArea);
	w.menu.setEntryVisibility(menuOptions.resetArea, permMemberArea);
}

var regionSelections = [];
function regionSelectionsActive() {
	for(var i = 0; i < regionSelections.length; i++) {
		if(regionSelections[i].isSelecting) return true;
	}
	return false;
}
function RegionSelection() {
	this.selection = null;
	this.regionSelected = false;
	this.regionCoordA = null;
	this.regionCoordB = null;
	this.isSelecting = false;
	this.charColor = "#9999e6";
	this.color = "rgba(0, 0, 255, 0.1)";
	this.tiled = false;
	this.lastSelectionHover = null; // [tileX, tileY, charX, charY]
	this.lastSelectionTiled = this.tiled;
	this.restartSelection = false;
	this.init = function() {
		var div = document.createElement("div");
		div.className = "region_selection";
		div.style.display = "none";
		div.style.backgroundColor = this.color;
		document.body.appendChild(div);
		this.selection = div;
	}
	this.setSelection = function(start, end) {
		var coordA = start.slice(0);
		var coordB = end.slice(0);
		orderRangeABCoords(coordA, coordB);
		var tileX1 = coordA[0];
		var tileY1 = coordA[1];
		var charX1 = coordA[2];
		var charY1 = coordA[3];
		var tileX2 = coordB[0];
		var tileY2 = coordB[1];
		var charX2 = coordB[2];
		var charY2 = coordB[3];
		if(this.tiled) {
			charX1 = 0;
			charY1 = 0;
			charX2 = tileC - 1;
			charY2 = tileR - 1;
		}
		var pxCoordA = tileAndCharsToWindowCoords(tileX1, tileY1, charX1, charY1);
		var pxCoordB = tileAndCharsToWindowCoords(tileX2, tileY2, charX2, charY2);
		var regWidth = pxCoordB[0] - pxCoordA[0] + Math.trunc(cellW / zoomRatio) - 2;
		var regHeight = pxCoordB[1] - pxCoordA[1] + Math.trunc(cellH / zoomRatio) - 2;
		var sel = this.selection;
		sel.style.width = regWidth + "px";
		sel.style.height = regHeight + "px";
		sel.style.top = pxCoordA[1] + "px";
		sel.style.left = pxCoordA[0] + "px";
	}
	this.show = function() {
		this.selection.style.display = "";
	}
	this.hide = function() {
		this.selection.style.display = "none";
	}
	this.deselect = function(successful) {
		this.regionSelected = false;
		this.regionCoordA = null;
		this.regionCoordB = null;
		this.hide();
		if(!successful) {
			for(var i = 0; i < oncancelEvents.length; i++) {
				var func = oncancelEvents[i];
				func();
			}
		}
	}
	this.stopSelectionUI = function(successful) {
		if(!this.lastSelectionHover) return;
		if(!this.isSelecting) return;
		this.isSelecting = false;
		elm.owot.style.cursor = defaultCursor;
		var tileX = this.lastSelectionHover[0];
		var tileY = this.lastSelectionHover[1];
		var charX = this.lastSelectionHover[2];
		var charY = this.lastSelectionHover[3];
		// remove highlight
		if(this.tiled) {
			if(Tile.get(tileX, tileY)) {
				Tile.get(tileX, tileY).backgroundColor = "";
			}
		} else {
			uncolorChar(tileX, tileY, charX, charY, "reg");
		}
		w.setTileRedraw(tileX, tileY);
		this.deselect(successful);
	}
	var onselectionEvents = [];
	var oncancelEvents = [];
	this.onselection = function(func) {
		onselectionEvents.push(func);
	}
	this.oncancel = function(func) {
		oncancelEvents.push(func);
	}
	this.handleSelection = function() {
		for(var i = 0; i < onselectionEvents.length; i++) {
			var func = onselectionEvents[i];
			this.regionSelected = true;
			if(!this.regionCoordA) continue;
			this.setSelection(this.regionCoordA, this.regionCoordB);
			var coordA = this.regionCoordA.slice(0);
			var coordB = this.regionCoordB.slice(0);
			orderRangeABCoords(coordA, coordB);
			var regWidth = (coordB[0] - coordA[0]) * tileC + coordB[2] - coordA[2] + 1;
			var regHeight = (coordB[1] - coordA[1]) * tileR + coordB[3] - coordA[3] + 1;
			func(coordA, coordB, regWidth, regHeight);
		}
		if(!this.restartSelection) {
			this.stopSelectionUI(true);
		} else {
			// the selection has been immediately restarted after the event has been fired
			this.regionCoordA = null;
			this.regionCoordB = null;
			this.hide();
		}
	}
	this.startSelection = function() {
		if(this.isSelecting) {
			this.restartSelection = true;
		}
		this.isSelecting = true;
		elm.owot.style.cursor = "cell";
	}
	regionSelections.push(this);
	this.destroy = function() {
		for(var i = 0; i < regionSelections.length; i++) {
			if(regionSelections[i] == this) {
				regionSelections.splice(i, 1);
				i--;
			}
		}
	}
	return this;
}

w.on("tilesRendered", function() {
	for(var i = 0; i < regionSelections.length; i++) {
		var reg = regionSelections[i];
		if(reg.regionCoordA && reg.regionCoordB) reg.setSelection(reg.regionCoordA, reg.regionCoordB);
	}
});

w.on("cursorMove", function(pos) {
	setClientGuestCursorPosition(pos.tileX, pos.tileY, pos.charX, pos.charY);
});

w.on("cursorHide", function() {
	setClientGuestCursorPosition(0, 0, 0, 0, true);
});

function setClientGuestCursorPosition(tileX, tileY, charX, charY, hidden) {
	var pos = clientGuestCursorPos;
	var pTileX = pos.tileX;
	var pTileY = pos.tileY;
	var pCharX = pos.charX;
	var pCharY = pos.charY;
	var pHidden = pos.hidden;
	if(tileX == pTileX && tileY == pTileY && charX == pCharX && charY == pCharY && pHidden == hidden) return;
	clientGuestCursorPos = {
		tileX: tileX,
		tileY: tileY,
		charX: charX,
		charY: charY,
		hidden: hidden,
		updated: true
	};
}

function sendCursorPosition() {
	if(!showMyGuestCursor) return;
	if(!Permissions.can_show_cursor(state.userModel, state.worldModel)) return;
	if(!w.socket) return;
	if(w.socket.socket.url.startsWith("wss://www.yourworldoftext.com/")) return;
	var pos = clientGuestCursorPos;
	if(!pos.updated) return;
	pos.updated = false;
	network.cursor(pos.tileX, pos.tileY, pos.charX, pos.charY, pos.hidden);
}

var networkHTTP = {
	fetch: function(x1, y1, x2, y2, opts, callback) {
		if(typeof opts == "function") {
			callback = opts;
		} else if(!opts) {
			opts = {};
		}
		var temp;
		if(x1 > x2) {
			temp = x1;
			x1 = x2;
			x2 = temp;
		}
		if(y1 > y2) {
			temp = y1;
			y1 = y2;
			y2 = temp;
		}
		var data = {
			fetch: 1,
			min_tileX: x1,
			min_tileY: y1,
			max_tileX: x2,
			max_tileY: y2
		};
		if(opts.utf16) data.utf16 = true;
		if(opts.array) data.array = true;
		if(opts.content_only) data.content_only = true;
		if(opts.concat) data.concat = true;
		ajaxRequest({
			type: "GET",
			url: window.location.pathname,
			data: data,
			done: function(data) {
				if(callback) callback(JSON.parse(data));
			},
			error: function() {
				if(callback) callback(null);
			}
		});
	},
	write: function(edits, opts, callback) {
		if(typeof opts == "function") {
			callback = opts;
		} else if(!opts) {
			opts = {};
		}
		var data = {
			edits: JSON.stringify(edits)
		};
		if(opts.public_only) data.public_only = true;
		if(opts.preserve_links) data.preserve_links = true;
		ajaxRequest({
			type: "POST",
			url: window.location.pathname,
			data: data,
			done: function(data) {
				if(callback) callback(JSON.parse(data));
			},
			error: function() {
				if(callback) callback(null);
			}
		});
	},
	urllink: function(tileX, tileY, charX, charY, url, callback) {
		ajaxRequest({
			type: "POST",
			url: "/ajax/urllink/",
			data: {
				world: state.worldModel.name,
				tileX: tileX,
				tileY: tileY,
				charX: charX,
				charY: charY,
				url: url
			},
			done: function(data) {
				if(callback) callback(data);
			},
			error: function() {
				if(callback) callback(null);
			}
		});
	},
	coordlink: function(tileX, tileY, charX, charY, link_tileX, link_tileY, callback) {
		ajaxRequest({
			type: "POST",
			url: "/ajax/coordlink/",
			data: {
				world: state.worldModel.name,
				tileX: tileX,
				tileY: tileY,
				charX: charX,
				charY: charY,
				link_tileX: link_tileX,
				link_tileY: link_tileY
			},
			done: function(data) {
				if(callback) callback(data);
			},
			error: function() {
				if(callback) callback(null);
			}
		});
	},
	protect: function(tileX, tileY, type, callback) {
		// type: unprotect, public, member-only, owner-only
		var data = {
			world: state.worldModel.name,
			tileX: tileX,
			tileY: tileY
		};
		var url = "/ajax/protect/";
		if(type == "unprotect") {
			url = "/ajax/unprotect/";
		} else {
			data.type = type;
		}
		ajaxRequest({
			type: "POST",
			url: url,
			data: data,
			done: function(data) {
				if(callback) callback(data);
			},
			error: function() {
				if(callback) callback(null);
			}
		});
	},
	protectchar: function(tileX, tileY, charX, charY, type, callback) {
		// type: unprotect, public, member-only, owner-only
		var data = {
			world: state.worldModel.name,
			tileX: tileX,
			tileY: tileY,
			charX: charX,
			charY: charY
		};
		var url = "/ajax/protect/char/";
		if(type == "unprotect") {
			url = "/ajax/unprotect/char/";
		} else {
			data.type = type;
		}
		ajaxRequest({
			type: "POST",
			url: url,
			data: data,
			done: function(data) {
				if(callback) callback(data);
			},
			error: function() {
				if(callback) callback(null);
			}
		});
	}
};

var network = {
	latestID: 1,
	callbacks: {},
	http: networkHTTP,
    lock_tile: (tileX, tileY) => {
        socket.send(JSON.stringify({
            kind: "lock_tile",
            tileX,
            tileY
        }));
    },
	protect: function(position, type) {
		// position: {tileX, tileY, [charX, charY]}
		// type: <unprotect, public, member-only, owner-only>
		var isPrecise = "charX" in position && "charY" in position;
		var data = {
			tileX: position.tileX,
			tileY: position.tileY,
			type: type == "unprotect" ? void 0 : type
		};
		if(isPrecise) {
			data.charX = position.charX;
			data.charY = position.charY;
			if(!("tileX" in position || "tileY" in position)) {
				data.tileX = Math.floor(data.charX / tileC);
				data.tileY = Math.floor(data.charY / tileR);
				data.charX = data.charX - Math.floor(data.charX / tileC) * tileC;
				data.charY = data.charY - Math.floor(data.charY / tileR) * tileR;
			}
			data.precise = true;
		}
		var protReq = {
			kind: "protect",
			data: data,
			action: type == "unprotect" ? type : "protect"
		};
		w.socket.send(JSON.stringify(protReq));
	},
	link: function(position, type, args) {
		// position: {tileX, tileY, charX, charY}
		// type: <url, coord>
		// args: {url} or {x, y}
		var data = {
			tileY: position.tileY,
			tileX: position.tileX,
			charY: position.charY,
			charX: position.charX
		};
		if(!("tileX" in position || "tileY" in position)) {
			data.tileX = Math.floor(data.charX / tileC);
			data.tileY = Math.floor(data.charY / tileR);
			data.charX = data.charX - Math.floor(data.charX / tileC) * tileC;
			data.charY = data.charY - Math.floor(data.charY / tileR) * tileR;
		}
		if(type == "url") {
			data.url = args.url;
		} else if(type == "coord") {
			data.link_tileX = args.x;
			data.link_tileY = args.y;
		}
		w.socket.send(JSON.stringify({
			kind: "link",
			data: data,
			type: type
		}));
	},
	cmd: function(data, include_username) {
		w.socket.send(JSON.stringify({
			kind: "cmd",
			data: data, // maximum length of 2048
			include_username: include_username
		}));
	},
	cmd_opt: function() {
		w.socket.send(JSON.stringify({
			kind: "cmd_opt"
		}));
	},
	write: function(edits, opts, callback) {
		if(!opts) opts = {};
		var writeReq = {
			kind: "write",
			edits: edits,
			public_only: opts.public_only,
			preserve_links: opts.preserve_links
		};
		if(callback) {
			var id = network.latestID++;
			writeReq.request = id;
			network.callbacks[id] = callback;
		}
		w.socket.send(JSON.stringify(writeReq));
	},
	chathistory: function() {
		w.socket.send(JSON.stringify({
			kind: "chathistory"
		}));
	},
	fetch: function(fetches, opts, callback) {
		// fetches: [{minX: <x1>, minY: <y1>, maxX: <x2>, maxY: <y2>}...]
		if(!opts) opts = {};
		if(typeof fetches == "object" && !Array.isArray(fetches)) fetches = [fetches];
		var fetchReq = {
			fetchRectangles: fetches,
			kind: "fetch",
			utf16: opts.utf16,
			array: opts.array,
			content_only: opts.content_only,
			concat: opts.concat
		};
		if(callback) {
			var id = network.latestID++;
			fetchReq.request = id;
			network.callbacks[id] = callback;
		}
		w.socket.send(JSON.stringify(fetchReq));
	},
	chat: function(message, location, nickname, color) {
		w.socket.send(JSON.stringify({
			kind: "chat",
			nickname: nickname,
			message: message,
			location: location,
			color: color
		}));
	},
	ping: function(callback) {
		var cb_id = void 0;
		if(callback) {
			cb_id = network.latestID++;
			network.callbacks[cb_id] = callback;
		}
		w.socket.send(JSON.stringify({
			kind: "ping",
			id: cb_id // optional: number
		}));
	},
	clear_tile: function(x, y) {
		w.socket.send(JSON.stringify({
			kind: "clear_tile",
			tileX: x,
			tileY: y,
		}));
	},
	cursor: function(tileX, tileY, charX, charY, hidden) {
		var data = {
			kind: "cursor"
		};
		if(hidden) {
			data.hidden = true;
		} else {
			data.position = {
				tileX: tileX,
				tileY: tileY,
				charX: charX,
				charY: charY
			}
		}
		w.socket.send(JSON.stringify(data));
	}
};

// [tileX, tileY, charX, charY]
var lastLinkHover = null;
// [type, tileX, tileY, (charX, charY)]
var lastTileHover = null;

Object.assign(w, {
	tiles: tiles,
	periodDeletedTiles: 0,
	hasUpdated: true,
	hasSelectiveUpdated: false,
	userCount: -1,
	clientId: -1,
	net: network,
	isLinking: false,
	isProtecting: false,
	url_input: "",
	coord_input_x: 0,
	coord_input_y: 0,
	link_input_type: 0, // 0 = link, 1 = coord,
	protect_type: null, // null = unprotect, 0 = public, 1 = member, 2 = owner
	protect_bg: "",
	nightMode: 0, // 0 = normal, 1 = night, 2 = night with normal background patterns
	input: elm.textInput,
	menu: null,
	ui: {
		announcements: {},
		coordLinkModal: null,
		coordGotoModal: null,
		urlModal: null,
		colorModal: null,
		selectionModal: null
	},
	styles: styles,
	backgroundInfo: {
		x: 0,
		y: 0,
		w: 0,
		h: 0,
		rmod: 0,
		alpha: 1
	},
	tile: {
		count: 0,
		set: Tile.set,
		delete: Tile.delete,
		get: Tile.get,
		cache: tiles,
		exists: Tile.exists,
		loaded: Tile.loaded,
		visible: Tile.visible
	},
	doAnnounce: function(text, announceClass) {
		if(!announceClass) {
			announceClass = "main";
		}
		var an = w.ui.announcements[announceClass];
		if(an) {
			if(text) {
				an.text.innerHTML = text;
				an.bar.style.display = "";
			} else {
				an.bar.style.display = "none";
			}
		} else {
			if(!text) return;
			var anBar = document.createElement("div");
			var anText = document.createElement("span");
			var anClose = document.createElement("span");
			anBar.className = "ui-vis";
			anText.className = "announce_text";
			anText.innerHTML = text;
			anClose.className = "announce_close";
			anClose.onclick = function() {
				anBar.style.display = "none";
			}
			anClose.innerText = "X";
			anBar.appendChild(anText);
			anBar.appendChild(anClose);
			elm.announce_container.appendChild(anBar);
			w.ui.announcements[announceClass] = {
				bar: anBar,
				text: anText,
				close: anClose
			};
		}
	},
	regionSelect: new RegionSelection(),
	protectSelect: new RegionSelection(),
	color: function() {
		w.ui.colorModal.open();
	},
	goToCoord: function() {
		w.ui.coordGotoModal.open();
	},
	doGoToCoord: function(y, x) {
		var maxX = Number.MAX_SAFE_INTEGER / 160 / 4;
		var maxY = Number.MAX_SAFE_INTEGER / 144 / 4;
		if(x > maxX || x < -maxX || y > maxY || y < -maxY) {
			return;
		}
		positionX = Math.floor(-x * tileW * coordSizeX);
		positionY = Math.floor(y * tileH * coordSizeY);
		w.render();
	},
	doUrlLink: function(url) {
		linkAuto.active = true;
		linkAuto.mode = 0;
		linkAuto.url = url;

		if(w.isLinking || w.isProtecting) return;
		w.url_input = url;
		elm.owot.style.cursor = "pointer";
		w.isLinking = true;
		w.link_input_type = 0;
	},
	urlLink: function() {
		w.ui.urlModal.open();
	},
	doCoordLink: function(y, x) {
		linkAuto.active = true;
		linkAuto.mode = 1;
		linkAuto.coordTileY = y;
		linkAuto.coordTileX = x;

		if(w.isLinking || w.isProtecting) return;
		w.coord_input_x = x;
		w.coord_input_y = y;
		elm.owot.style.cursor = "pointer";
		w.isLinking = true;
		w.link_input_type = 1;
	},
	coordLink: function() {
		w.ui.coordLinkModal.open();
	},
	doProtect: function(protectType, unprotect) {
		// show the protection precision menu
		elm.protect_precision.style.display = "";
		tileProtectAuto.active = true;
		if(unprotect) { // default area protection
			tileProtectAuto.mode = 3;
		} else {
			if(protectType == "owner-only") tileProtectAuto.mode = 0;
			if(protectType == "member-only") tileProtectAuto.mode = 1;
			if(protectType == "public") tileProtectAuto.mode = 2;
		}

		if(w.isLinking) return;
		elm.owot.style.cursor = "pointer";
		w.protect_bg = {
			"owner-only": "#ddd",
			"member-only": "#eee",
			"public": "#fff"
		}[protectType];
		w.isProtecting = true;
		if(unprotect) {
			w.protect_type = null;
		} else if(protectType == "owner-only") {
			w.protect_type = 2;
		} else if(protectType == "member-only") {
			w.protect_type = 1;
		} else if(protectType == "public") {
			w.protect_type = 0;
		}
	},
	doUnprotect: function() {
		w.doProtect("public", true);
	},
	typeChar: writeChar,
	getChar: getChar,
	socketChannel: null,
	moveCursor: moveCursor,
	fetchUnloadedTiles: getAndFetchTiles,
	acceptOwnEdits: false,
	receivingBroadcasts: false,
	getTileVisibility: function() {
		var minVisY = (-positionY - Math.trunc(owotHeight / 2)) / tileH;
		var minVisX = (-positionX - Math.trunc(owotWidth / 2)) / tileW;
		var numDown = owotHeight / tileH;
		var numAcross = owotWidth / tileW;
		var maxVisY = minVisY + numDown;
		var maxVisX = minVisX + numAcross;
		var centerY = minVisY + numDown / 2;
		var centerX = minVisX + numAcross / 2;
		return {
			minVisY: minVisY,
			minVisX: minVisX,
			numDown: numDown,
			numAcross: numAcross,
			maxVisY: maxVisY,
			maxVisX: maxVisX,
			centerY: centerY,
			centerX: centerX
		};
	},
	getCenterCoords: function() { // [y, x]
		return [-positionY / tileH, -positionX / tileW];
	},
	chat: {
		send: api_chat_send
	},
	broadcastReceive: function(force) {
		if(w.receivingBroadcasts && !force) return;
		w.receivingBroadcasts = true;
		network.cmd_opt();
	},
	broadcastCommand: function(data, includeUsername) {
		network.cmd(data, includeUsername);
	},
	jquery: function(callback) {
		if(window.jQuery) return;
		var jqueryURL = "/static/lib/jquery-1.7.min.js";
		w.loadScript(jqueryURL, callback);
	},
	redraw: function() {
		renderTiles(true);
	},
	reloadRenderer: function() {
		reloadRenderer();
	},
	setRedraw: function() {
		for(var t in tiles) {
			if(!tiles[t]) continue;
			tiles[t].redraw = true;
		}
	},
	setTileRedraw: function(tileX, tileY) {
		var tile = Tile.get(tileX, tileY);
		if(!tile) return;
		w.hasSelectiveUpdated = true;
		tile.redraw = true;
	},
	setTileRender: function(tileX, tileY) {
		// render tile again on main canvas on next render loop
		var tile = Tile.get(tileX, tileY);
		if(!tile) return;
		w.hasSelectiveUpdated = true;
		tile.rerender = true;
	},
	setTransparency: function(transparent) {
		if(transparent) {
			transparentBackground = true;
			setupTextRenderCtx();
		} else {
			transparentBackground = false;
			setupTextRenderCtx();
		}
		updateScaleConsts();
		w.redraw();
	},
	render: function(redraw) {
		if(redraw) w.setRedraw();
		w.hasUpdated = true;
	},
	changeFont: function(fontData) {
		// change the global font
		fontTemplate = fontData;
		font = fontTemplate.replace("$", normFontSize(16 * zoom));
		textRenderCtx.font = font;
		w.redraw();
	},
	fixFonts: function() {
		var fnt_main = new FontFace("suppl_cour", "url('/static/font/cour.ttf')");
		var fnt_cal = new FontFace("suppl_cal", "url('/static/font/calibri.ttf')");
		var fnt_sym = new FontFace("suppl_sym", "url('/static/font/seguisym.ttf')");
		Promise.all([fnt_main.load(), fnt_cal.load(), fnt_sym.load()]).then(function() {
			document.fonts.add(fnt_main);
			document.fonts.add(fnt_cal);
			document.fonts.add(fnt_sym);
			w.changeFont("$px suppl_cour, suppl_cal, suppl_sym");
		});
	},
	loadFont: function(name, path, cb) {
		var fnt = new FontFace(name, "url(\"" + encodeURI(path) + "\")");
		fnt.load().then(function() {
			document.fonts.add(fnt);
			if(cb) cb(fnt);
		});
	},
	changeSpecialCharFont: function(fontData) {
		specialCharFontTemplate = fontData;
		specialCharFont = specialCharFontTemplate.replace("$", normFontSize(16 * zoom));
		w.redraw();
	},
	enableCombining: function(nr) {
		combiningCharsEnabled = true;
		if(!nr) w.redraw();
	},
	disableCombining: function(nr) {
		combiningCharsEnabled = false;
		if(!nr) w.redraw();
	},
	enableSurrogates: function(nr) {
		surrogateCharsEnabled = true;
		if(!nr) w.redraw();
	},
	disableSurrogates: function(nr) {
		surrogateCharsEnabled = false;
		if(!nr) w.redraw();
	},
	enableColors: function(nr) {
		colorsEnabled = true;
		if(!nr) w.redraw();
	},
	disableColors: function(nr) {
		colorsEnabled = false;
		if(!nr) w.redraw();
	},
	basic: function() {
		w.disableSurrogates(1);
		w.disableCombining(1);
		w.disableColors(1);
		w.redraw();
	},
	restore: function() {
		w.enableSurrogates(1);
		w.enableCombining(1);
		w.enableColors(1);
		w.redraw();
	},
	night: function(ignoreUnloadedPattern) {
		styles.member = "#111";
		styles.owner = "#222";
		styles.public = "#000";
		styles.text = "#FFF";
		w.nightMode = 1;
		if(ignoreUnloadedPattern) {
			w.nightMode = 2;
		} else if(!elm.owot.classList.contains("nightmode")) {
			elm.owot.classList.add("nightmode");
		}
		w.redraw();
	},
	day: function(reloadStyle) {
		w.nightMode = 0;
		if(elm.owot.classList.contains("nightmode")) {
			elm.owot.classList.remove("nightmode");
		}
		if(reloadStyle) {
			getWorldProps(state.worldModel.name, "style", function(style, error) {
				if(!error) {
					styles.member = style.member;
					styles.owner = style.owner;
					styles.public = style.public;
					styles.text = style.text;
				}
				menu_color(styles.menu);
				w.redraw();
			});
		} else {
			var def = defaultStyles();
			styles.member = def.member;
			styles.owner = def.owner;
			styles.public = def.public;
			styles.text = def.text;
			w.redraw();
		}
	},
	rotate: function(speed) {
		if(!speed) speed = 2;
		var rotation = 0;
		var rot = setInterval(function() {
			elm.main_view.style.transform = "perspective(900px) rotateY(" + rotation + "deg)";
			rotation += speed;
			if(rotation >= 360) {
				elm.main_view.style.transform = "";
				clearInterval(rot);
			}
		}, 10);
	},
	hideChat: function() {
		chat_open.style.display = "none";
		elm.chat_window.style.display = "none";
	},
	showChat: function() {
		chat_open.style.display = "";
		if(chatOpen) elm.chat_window.style.display = "";
	},
	disableDragging: function() {
		draggingEnabled = false;
		stopDragging();
	},
	enableDragging: function() {
		draggingEnabled = true;
	},
	disableCursor: function() {
		cursorEnabled = false;
		removeCursor();
	},
	enableCursor: function() {
		cursorEnabled = true;
	},
	disableScrolling: function() {
		scrollingEnabled = false;
	},
	enableScrolling: function() {
		scrollingEnabled = true;
	},
	setMouseCursor: function(cursor) {
		defaultCursor = cursor;
	},
	resetMouseCursor: function() {
		defaultCursor = "text";
	},
	setDragCursor: function(cursor) {
		defaultDragCursor = cursor;
	},
	resetDragCursor: function() {
		defaultDragCursor = "move";
	},
	changeSocket: function(addr) {
		ws_path = addr;
		socket.close();
		createSocket();
		clearTiles(true);
		clearInterval(fetchInterval);
	},
	changeColor: function(color) {
		color = resolveColorValue(color);
		YourWorld.Color = color;
		localStorage.setItem("color", color);
		// update color textbox in "change color" menu
		var rgb = int_to_rgb(color);
		setRGBColorPicker(rgb[0], rgb[1], rgb[2]);
		if(cursorCoords) {
			var cursorTileX = cursorCoords[0];
			var cursorTileY = cursorCoords[1];
			w.setTileRedraw(cursorTileX, cursorTileY);
		}
	},
	fetchUpdates: function(margin) {
		if(!margin) margin = 0;
		var vis = getVisibleTileRange(margin);
		network.fetch({
			minX: vis[0][0],
			minY: vis[0][1],
			maxX: vis[1][0],
			maxY: vis[1][1]
		});
	},
	splitTile: function(str) {
		if(!classicTileProcessing) {
			return w.split(str);
		} else {
			return w.split(str, false, false, true);
		}
	},
	shiftZoombar: function() {
		w.menu.moveEntryLast(w.menu.zoombarId);
	},
	setFlushInterval: function(rate) {
		if(typeof rate != "number" || rate < 0 || isNaN(rate) || !isFinite(rate) || rate > 1000000) rate = 1000;
		writeFlushRate = rate;
		setWriteInterval();
	}
});

elm.owot.oncontextmenu = function() {
	if(ignoreCanvasContext) {
		ignoreCanvasContext = false;
		elm.owot.style.pointerEvents = "none";
		setTimeout(function() {
			ignoreCanvasContext = true;
			elm.owot.style.pointerEvents = "";
		}, 1);
	}
}

window.onhashchange = function(e) {
	manageCoordHash();
}

window.onbeforeunload = function() {
	if(writeBuffer.length) flushWrites();
}

document.onselectstart = function(e) {
	var target = e.target;
	if(closest(target, getChatfield()) || target == elm.chatbar || closest(target, elm.confirm_js_code) || closest(target, elm.announce_text)) {
		return true;
	}
	return Modal.isOpen;
}

w._state = w.state; // deprecated

function makeCoordLinkModal() {
	var modal = new Modal();
	modal.createForm();
	modal.setFormTitle("Enter the coordinates to create a link to. You can then click on a letter to create the link.\n");
	var coordX = modal.addEntry("X", "text", "number").input;
	var coordY = modal.addEntry("Y", "text", "number").input;
	modal.setMaximumSize(360, 300);
	modal.onSubmit(function() {
		w.doCoordLink(parseFloat(coordY.value), parseFloat(coordX.value));
	});
	w.ui.coordLinkModal = modal;
}

function makeCoordGotoModal() {
	var modal = new Modal();
	modal.createForm();
	modal.setFormTitle("Go to coordinates:\n");
	var coordX = modal.addEntry("X", "text", "number").input;
	var coordY = modal.addEntry("Y", "text", "number").input;
	modal.onSubmit(function() {
		w.doGoToCoord(parseFloat(coordY.value), parseFloat(coordX.value));
	});
	w.ui.coordGotoModal = modal;
}

function makeURLModal() {
	var modal = new Modal();
	modal.setMinimumSize(250, 120);
	modal.createForm();
	modal.setFormTitle("\n");
	var urlInput = modal.addEntry("URL", "text").input;
	urlInput.style.width = "175px";
	modal.onSubmit(function() {
		w.doUrlLink(urlInput.value);
	});
	modal.unalignForm();
	w.ui.urlModal = modal;
}

function makeColorModal() {
	var modal = new Modal();
	modal.setMinimumSize(290, 128);
	modal.createForm();
	modal.setFormTitle("\n");
	colorInput = modal.addEntry("Color Code", "color").input;
	modal.onSubmit(function() {
		var color = colorInput.value;
		var this_color = 0;
		if(color) {
			this_color = parseInt(color, 16);
		}
		if(!this_color) {
			this_color = 0;
		}
		w.changeColor(this_color);
		localStorage.setItem("color", this_color);
	});
	modal.onClose(function(canceled) {
		if(!canceled) {
			modal.submitForm();
		}
	});
	modal.setFooter();
	modal.setFooterCheckbox("Outline", function(checked) {
		cursorOutlineEnabled = checked;
		storeConfig();
		if(!cursorCoords) return;
		var cursorTileX = cursorCoords[0];
		var cursorTileY = cursorCoords[1];
		w.setTileRedraw(cursorTileX, cursorTileY);
	}, cursorOutlineEnabled);
	w.ui.colorModal = modal;

	colorShortcuts = document.createElement("div");
	colorShortcuts.id = "color_shortcuts";
	modal.setFooterContentRight(colorShortcuts);
}

function makeSelectionModal() {
	var headerBar = document.createElement("div");

	var area_copy = document.createElement("button");
	area_copy.style.marginBottom = "1px";
	area_copy.innerText = "Copy to Clipboard";
	area_copy.onclick = function() {
		w.clipboard.copy(region_text.value);
	}

	var region_bounds = document.createElement("span");
	region_bounds.style.display = "none";
	region_bounds.style.marginLeft = "5px";
	var reg_label = document.createElement("b");
	reg_label.innerText = "Selection: ";
	var rb_coord1 = document.createElement("span");
	var rb_coord2 = document.createElement("span");
	region_bounds.appendChild(reg_label);
	region_bounds.appendChild(rb_coord1);
	region_bounds.appendChild(document.createTextNode(", "));
	region_bounds.appendChild(rb_coord2);
	var region_text = document.createElement("textarea")
	region_text.id = "area_results";

	headerBar.appendChild(area_copy);
	headerBar.appendChild(region_bounds);

	function updateOutput() {
		var o_color = c_color.cbElm.checked;
		var o_link = c_link.cbElm.checked;
		var o_prot = c_prot.cbElm.checked;
		var o_protpub = c_pprot.cbElm.checked;
		var o_tleft = t_left.cbElm.checked;
		var o_tright = t_right.cbElm.checked;
		var o_tempty = t_empty.cbElm.checked;
		var o_rgap = r_gap.cbElm.checked;
		var o_rlnbrk = r_br.cbElm.checked;
		var o_rsurrog = r_surr.cbElm.checked;
		var o_rcomb = r_comb.cbElm.checked;
		var text = s_str.split("\n");
		var currentCol = -1;
		for(var y = 0; y < text.length; y++) {
			text[y] = w.split(text[y], o_rsurrog, o_rcomb);
			var colRow;
			var linkRow;
			var protRow;
			if(o_color) colRow = s_colors.slice(y * text[y].length, y * text[y].length + text[y].length);
			if(o_link) linkRow = s_links.slice(y * text[y].length, y * text[y].length + text[y].length);
			if(o_prot) protRow = s_prots.slice(y * text[y].length, y * text[y].length + text[y].length);
			if(o_tleft || o_tright || o_rgap) spaceTrim(text[y], o_tleft, o_tright, o_rgap, [colRow, linkRow, protRow]);
			var line = text[y];
			if(o_color) {
				for(var x = 0; x < line.length; x++) {
					var col = colRow[x];
					if(col == currentCol) continue;
					currentCol = col;
					var chr = "\x1b";
					if(col == 0) {
						chr += "x";
					} else {
						chr += "F" + col.toString(16).padStart(6, 0);
					}
					chr += line[x];
					line[x] = chr;
				}
			}
			if(o_link) {
				for(var x = 0; x < line.length; x++) {
					var link = linkRow[x];
					if(!link) continue;
					line[x] = "\x1b" + link + line[x];
				}
			}
			if(o_prot) {
				for(var x = 0; x < line.length; x++) {
					var prot = protRow[x];
					if(prot == 0 && !o_protpub) continue;
					line[x] = "\x1b" + "P" + prot + line[x]; // prot should be one character in length
				}
			}
			text[y] = text[y].join("");
		}
		if(o_tempty) {
			for(var y = 0; y < text.length; y++) {
				if(!text[y]) {
					text.splice(y, 1);
					y--;
				}
			}
		}
		if(!o_rlnbrk) {
			text = text.join("\n");
		} else {
			text = text.join("");
		}
		region_text.value = text;
	}

	var s_str;
	var s_colors;
	var s_links
	var s_prots;

	var modal = new Modal();
	modal.setMinimumSize(500, 450);
	modal.append(headerBar);
	modal.append(region_text);
	modal.createCheckboxField();
	modal.createClose();
	var c_color = modal.addCheckbox("Copy colors");
	var c_link = modal.addCheckbox("Copy links");
	var c_prot = modal.addCheckbox("Copy protections");
	var c_pprot = modal.addCheckbox("Copy public protections", c_prot);
	var t_left = modal.addCheckbox("Trim left");
	var t_right = modal.addCheckbox("Trim right");
	var t_empty = modal.addCheckbox("Trim empty lines");
	var r_gap = modal.addCheckbox("Remove gaps");
	var r_br = modal.addCheckbox("Remove line breaks");
	var r_surr = modal.addCheckbox("Remove surrogates");
	var r_comb = modal.addCheckbox("Remove combining chars");
	modal.checkboxFieldOnInput(function(obj, checked) {
		updateOutput();
	});
	modal.onOpen(function(str, colors, links, protections, coords) {
		s_str = str;
		s_colors = colors;
		s_links = links;
		s_prots = protections;
		if(!showCursorCoordinates) {
			region_bounds.style.display = "none";
		} else {
			region_bounds.style.display = "";
			rb_coord1.innerText = JSON.stringify(coords[0]);
			rb_coord2.innerText = JSON.stringify(coords[1]);
		}
		updateOutput();
	});
	w.ui.selectionModal = modal;
}

// (MOD)
/*if(state.userModel.is_superuser) {
	w.loadScript("/static/yw/javascript/world_tools.js");
}*/

if(state.background) {
	w.backgroundInfo.x = ("x" in state.background) ? state.background.x : 0;
	w.backgroundInfo.y = ("y" in state.background) ? state.background.y : 0;
	w.backgroundInfo.w = ("w" in state.background) ? state.background.w : 0;
	w.backgroundInfo.h = ("h" in state.background) ? state.background.h : 0;
	w.backgroundInfo.rmod = ("rmod" in state.background) ? state.background.rmod : 0;
	w.backgroundInfo.alpha = ("alpha" in state.background) ? state.background.alpha : 1;
}

var tellEdit = [];
// tileY, tileX, charY, charX, X, X, editID
function searchTellEdit(tileX, tileY, charX, charY) {
	for(var i = 0; i < tellEdit.length; i++) {
		if(tellEdit[i][1] == tileX &&
			tellEdit[i][0] == tileY &&
			tellEdit[i][3] == charX &&
			tellEdit[i][2] == charY) {
			return true;
		}
	}
	return false;
}

function tile_offset_object(data, tileOffX, tileOffY) {
	var refs = {};
	var tilef;
	for(var tilef in data) {
		refs[tilef] = data[tilef];
		delete data[tilef];
	}
	for(var tkp in refs) {
		var new_key = getPos(tkp);
		new_key = (new_key[0] - tileOffY) + "," + (new_key[1] - tileOffX);
		data[new_key] = refs[tkp];
	}
}

var ws_functions = {
	fetch: function(data) {
		if("request" in data) {
			var id = data.request;
			var cb = network.callbacks[id];
			if(typeof cb == "function") {
				cb(data.tiles, null);
			}
		}
		if(tileFetchOffsetX || tileFetchOffsetY) {
			tile_offset_object(data.tiles, tileFetchOffsetX, tileFetchOffsetY);
		}
		w.emit("fetch", data);
		for(var tileKey in data.tiles) {
			var tile = data.tiles[tileKey];
			var pos = getPos(tileKey);
			if(tile) {
				tile.content = w.splitTile(tile.content);
				Tile.set(pos[1], pos[0], tile);
			} else {
				Tile.set(pos[1], pos[0], blankTile());
			}
			if(tiles[tileKey].properties.char) {
				tiles[tileKey].properties.char = decodeCharProt(tiles[tileKey].properties.char);
			}
			var tileX = pos[1];
			var tileY = pos[0];
			w.setTileRedraw(tileX, tileY);
			if(bufferLargeChars) {
				w.setTileRedraw(tileX, tileY - 1);
				w.setTileRedraw(tileX + 1, tileY - 1);
				w.setTileRedraw(tileX + 1, tileY);
			}
		}
		w.emit("afterFetch", data);
		updateHoveredLink(null, null, null, true);
		// too many tiles, remove tiles outside of the viewport
		var tileLim = Math.floor(getArea(fetchClientMargin) * 1.5 / zoom + 1000);
		if(w.tile.count > tileLim && unloadTilesAuto) {
			clearTiles();
		}
	},
	colors: function(data) {
		// update all world colors
		w.emit("colors", data);
		styles.public = data.colors.background;
		styles.cursor = data.colors.cursor;
		styles.guestCursor = data.colors.guest_cursor;
		styles.member = data.colors.member_area;
		styles.menu = data.colors.menu;
		styles.owner = data.colors.owner_area;
		styles.text = data.colors.text;
		styles.public_text = data.colors.public_text;
		styles.member_text = data.colors.member_text;
		styles.owner_text = data.colors.owner_text;
		checkTextColorOverride();
		w.render(true);
		menu_color(styles.menu);
	},
	tileUpdate: function(data) {
		w.emit("tileUpdate", data);
		var highlights = [];
		// settings are configured to offset server-fetched tiles
		if(tileFetchOffsetX || tileFetchOffsetY) {
			tile_offset_object(data.tiles, tileFetchOffsetX, tileFetchOffsetY);
		}
		for(var tileKey in data.tiles) {
			var pos = getPos(tileKey);
			var tileX = pos[1];
			var tileY = pos[0];
			// if tile isn't loaded, load it blank
			if(!tiles[tileKey]) {
				Tile.set(tileX, tileY, blankTile());
			}
			if(!data.tiles[tileKey]) {
				data.tiles[tileKey] = blankTile();
			}
			if(!data.tiles[tileKey].properties.color) {
				data.tiles[tileKey].properties.color = new Array(tileArea).fill(0);
			}
			if(data.tiles[tileKey].properties.char) {
				data.tiles[tileKey].properties.char = decodeCharProt(data.tiles[tileKey].properties.char);
			}
			if(!tiles[tileKey].properties.color) {
				tiles[tileKey].properties.color = new Array(tileArea).fill(0);
			}
			var newContent;
			var newColors;
			// get content and colors from new tile data
			if(data.tiles[tileKey]) {
				newContent = w.splitTile(data.tiles[tileKey].content);
				if(data.tiles[tileKey].properties.color) {
					newColors = data.tiles[tileKey].properties.color;
				} else {
					newColors = new Array(tileArea).fill(0);
				}
			} else {
				newContent = new Array(tileArea).fill(" ");
			}
			var oldContent = tiles[tileKey].content;
			var oldColors = tiles[tileKey].properties.color.slice(0);
			var charX = 0;
			var charY = 0;
			// compare data
			for(var g = 0; g < tileArea; g++) {
				var oChar = oldContent[g];
				var nChar = newContent[g];
				var oCol = oldColors[g];
				var nCol = newColors[g];
				if(oChar != nChar || oCol != nCol) {
					// don't overwrite local changes until those changes are confirmed
					if(!searchTellEdit(tileX, tileY, charX, charY)) {
						oldContent[g] = nChar;
						oldColors[g] = nCol;
					}
					// briefly highlight these changes (10 at a time)
					if(useHighlight && Tile.visible(tileX, tileY)) {
						highlights.push([tileX, tileY, charX, charY]);
					}
				}
				charX++;
				if(charX >= tileC) {
					charX = 0;
					charY++;
				}
			}
			tiles[tileKey].properties = data.tiles[tileKey].properties; // update tile
			tiles[tileKey].content = oldContent; // update only necessary character updates
			tiles[tileKey].properties.color = oldColors; // update only necessary color updates
			w.setTileRedraw(tileX, tileY);
			if(bufferLargeChars) {
				w.setTileRedraw(tileX, tileY - 1);
				w.setTileRedraw(tileX + 1, tileY - 1);
				w.setTileRedraw(tileX + 1, tileY);
			}
		}
		if(highlights.length > 0 && useHighlight) highlight(highlights);
		var tileLim = Math.floor(getArea(fetchClientMargin) * 1.5 / zoom + 1000);
		if(w.tile.count > tileLim && unloadTilesAuto) {
			clearTiles();
		}
		w.emit("afterTileUpdate", data);
	},
	write: function(data) {
		if("request" in data) {
			var id = data.request;
			var cb = network.callbacks[id];
			if(typeof cb == "function") {
				cb(data, null);
			}
		}
		w.emit("writeResponse", data);
		for(var i = 0; i < data.accepted.length; i++) {
			for(var x = 0; x < tellEdit.length; x++) {
				if(tellEdit[x][6] == data.accepted[i]) {
					var tileX = tellEdit[x][1];
					var tileY = tellEdit[x][0];
					var charX = tellEdit[x][3];
					var charY = tellEdit[x][2];
					// check if there are links in queue
					for(var r = 0; r < linkQueue.length; r++) {
						var queueItem = linkQueue[r];
						if(queueItem[1] == tileX && queueItem[2] == tileY && queueItem[3] == charX && queueItem[4] == charY) {
							var linkType = queueItem[0];
							if(linkType == "url") {
								network.link({
									tileY: tileY,
									tileX: tileX,
									charY: charY,
									charX: charX
								}, "url", { url: queueItem[5] });
							} else if(linkType == "coord") {
								network.link({
									tileY: tileY,
									tileX: tileX,
									charY: charY,
									charX: charX
								}, "coord", { x: queueItem[5], y: queueItem[6] });
							}
							linkQueue.splice(r, 1);
							break;
						}
					}
					if(uncolorChar(tileX, tileY, charX, charY, "err")) {
						w.setTileRedraw(tileX, tileY);
					}
					tellEdit.splice(x, 1);
					// because the element has been removed, the length of the array is shorter
					x--;
				}
			}
		}
		for(var i in data.rejected) {
			var rej = data.rejected[i];
			for(var x = 0; x < tellEdit.length; x++) {
				if(tellEdit[x][6] != i) continue;
				var tileX = tellEdit[x][1];
				var tileY = tellEdit[x][0];
				var charX = tellEdit[x][3];
				var charY = tellEdit[x][2];
				if(rej == 1 || rej == 4) { // denied because zero rate limit
					highlight([[tileX, tileY, charX, charY]], true, [255, 0, 0]);
					tellEdit.splice(x, 1);
					x--;
					continue;
				}
				colorChar(tileX, tileY, charX, charY, "err");
				w.setTileRedraw(tileX, tileY);
				tellEdit[x][4] = Date.now();
				writeBuffer.push(tellEdit[x]);
			}
		}
	},
	channel: function(data) {
		w.socketChannel = data.sender;
		w.clientId = data.id;
		w.userCount = data.initial_user_count;
		updateUserCount();
	},
	announcement: function(data) {
		w.emit("announcement", data);
		w.doAnnounce(data.text);
	},
	ping: function(data) {
		w.emit("ping", data);
		if(data.id) {
			if(network.callbacks[data.id]) {
				var cb = network.callbacks[data.id];
				delete network.callbacks[data.id];
				cb();
			}
		}
	},
	propUpdate: function(data) {
		w.emit("propUpdate", data.props);
		var props = data.props;
		for(var p = 0; p < props.length; p++) {
			var prop = props[p];
			var type = prop.type;
			var value = prop.value;
			switch(type) {
				case "isMember":
					state.userModel.is_member = value;
					break;
				case "isOwner":
					state.userModel.is_owner = value;
					break;
				case "goToCoord":
					state.worldModel.feature_go_to_coord = value;
					break;
				case "coordLink":
					state.worldModel.feature_coord_link = value;
					break;
				case "urlLink":
					state.worldModel.feature_url_link = value;
					break;
				case "paste":
					state.worldModel.feature_paste = value;
					break;
				case "chat":
					state.worldModel.chat_permission = value;
					elm.chatbar.disabled = !Permissions.can_chat(state.userModel, state.worldModel);
					break;
				case "showCursor":
					state.worldModel.show_cursor = value;
					break;
				case "colorText":
					state.worldModel.color_text = value;
					break;
				case "memberTilesAddRemove":
					state.worldModel.feature_membertiles_addremove = value;
					break;
				case "readability":
					break;
				case "writability":
					state.worldModel.writability = value;
					w.redraw();
					break;
				case "name":
					state.worldModel.name = value;
					state.worldModel.pathname = value ? "/" + value : "";
					if(!value || value.toLowerCase() == "main") {
						document.title = "Our World of Text";
					} else {
						document.title = state.worldModel.pathname;
					}
					ws_path = createWsPath();
					if(window.history && window.history.replaceState) {
						history.replaceState({}, "", state.worldModel.pathname + window.location.search + window.location.hash);
					}
					break;
				case "charRate":
					state.worldModel.char_rate = value;
					break;
				case "writeInt":
					w.setFlushInterval(value);
					break;
			}
		}
		updateMenuEntryVisiblity();
	},
	chat: function(data) {
		var type = chatType(data.registered, data.nickname, data.realUsername);
		w.emit("chat", {
			location: data.location,
			id: data.id,
			type: type,
			nickname: data.nickname,
			message: data.message,
			realUsername: data.realUsername,
			op: data.op,
			admin: data.admin,
			staff: data.staff,
			color: data.color,
			date: data.date,
			dataObj: data,
			hide: false
		});
	},
	user_count: function(data) {
		var count = data.count;
		w.emit("userCount", count);
		w.userCount = count;
		updateUserCount();
	},
	chathistory: function(data) {
		if(data.error) {
			return;
		}
		var global_prev = data.global_chat_prev;
		var page_prev = data.page_chat_prev;
		for(var g = 0; g < global_prev.length; g++) {
			var chat = global_prev[g];
			var type = chatType(chat.registered, chat.nickname, chat.realUsername);
			addChat(chat.location, chat.id, type, chat.nickname,
				chat.message, chat.realUsername, chat.op, chat.admin, chat.staff, chat.color, chat.date, chat);
		}
		for(var p = 0; p < page_prev.length; p++) {
			var chat = page_prev[p];
			var type = chatType(chat.registered, chat.nickname, chat.realUsername);
			addChat(chat.location, chat.id, type, chat.nickname,
				chat.message, chat.realUsername, chat.op, chat.admin, chat.staff, chat.color, chat.date, chat);
		}
	},
	chatdelete: function(data) {
		// subject to change
		var id = data.id; // client id
		var time = data.time;
		removeChatByIdAndDate(id, time);
	},
	cmd: function(data) {
		w.emit("cmd", data);
	},
	cursor: function(data) {
		w.emit("guestCursor", data);
		var channel = data.channel;
		var hidden = data.hidden;
		var position = data.position;
		if(channel == w.socketChannel) return;
		if(hidden) {
			var csr = guestCursors[channel];
			if(!csr) return;
			var tileX = csr.tileX;
			var tileY = csr.tileY;
			delete guestCursors[channel];
			var tilePos = tileY + "," + tileX;
			if(guestCursorsByTile[tilePos]) {
				delete guestCursorsByTile[tilePos][channel];
				if(Object.keys(guestCursorsByTile[tilePos]).length == 0) {
					delete guestCursorsByTile[tilePos];
				}
			}
			w.setTileRedraw(tileX, tileY);
		} else if(position) {
			var csr = guestCursors[channel];
			if(!csr) {
				csr = {};
				guestCursors[channel] = csr;
			} else {
				var prevTilePos = csr.tileY + "," + csr.tileX;
				if(guestCursorsByTile[prevTilePos]) {
					delete guestCursorsByTile[prevTilePos][channel];
				}
				if(Object.keys(guestCursorsByTile[prevTilePos]).length == 0) {
					delete guestCursorsByTile[prevTilePos];
				}
				w.setTileRedraw(csr.tileX, csr.tileY);
			}
			csr.tileX = position.tileX;
			csr.tileY = position.tileY;
			csr.charX = position.charX;
			csr.charY = position.charY;
			tilePos = csr.tileY + "," + csr.tileX;
			if(!guestCursorsByTile[tilePos]) {
				guestCursorsByTile[tilePos] = {};
			}
			guestCursorsByTile[tilePos][channel] = csr;
			w.setTileRedraw(csr.tileX, csr.tileY);
		}
	},
	error: function(data) {
		var code = data.code;
		var message = data.message;
		switch(code) {
			case "CONN_LIMIT": // too many connections
			case "INVALID_ADDR": // invalid websocket path
			case "NO_EXIST": // world does not exist
			case "NO_PERM": // no permission to access world
				console.log("Received error from the server with code [" + code + "]: " + message);
				if(code == "NO_PERM") {
					w.doAnnounce("Access to this world is denied. Please make sure you are logged in.", "err_access");
				} else if(code == "CONN_LIMIT") {
					w.doAnnounce("You have too many connections.", "err_limit");
				}
				break;
			case "PARAM": // invalid parameters in message
				break;
		}
	}
};

function begin() {
	getStoredConfig();
	getStoredNickname();

	makeCoordLinkModal();
	makeCoordGotoModal();
	makeURLModal();
	makeColorModal();
	makeSelectionModal();

	addColorShortcuts();
	updateColorPicker();

	if(state.announce) {
		w.doAnnounce(state.announce);
	}
	buildMenu();
	updateMenuEntryVisiblity();
	w.regionSelect.onselection(handleRegionSelection);
	w.regionSelect.init();

	w.protectSelect.onselection(protectSelectionStart);
	w.protectSelect.oncancel(protectSelectionCancel);
	w.protectSelect.tiled = true;
	w.protectSelect.init();

	manageCoordHash();
	
	setTimeout(function() {
		styles = defaultStyles();
		menu_color(styles.menu);
		writability_styles = [styles.public, styles.member, styles.owner];
		owotCtx.clearRect(0, 0, owotWidth, owotHeight);
		renderLoop();
		createSocket();
		elm.loading.style.display = "none";
	}, 1);
}

begin();
		</script>
		<script>
window.OWOTSearchUtil = true;
w.on("fetch", function(data) {
	var tiles = data.tiles;
	var tileCount = Object.keys(tiles).length;
	for(var i = 0; i < searchAwaitingBlocks.length; i++) {
		var context = searchAwaitingBlocks[i];
		var x1 = context[0];
		var y1 = context[1];
		var x2 = context[2];
		var y2 = context[3];
		var res = context[4];
		var areaSize = (x2 - x1 + 1) * (y2 - y1 + 1);
		if(tileCount != areaSize) continue;
		var isNotVerified = false;
		for(var tpos in tiles) {
			var pos = tpos.split(",");
			var tileX = parseInt(pos[1]);
			var tileY = parseInt(pos[0]);
			var inRange = x1 <= tileX && tileX <= x2 && y1 <= tileY && tileY <= y2;
			if(!inRange) {
				isNotVerified = true;
				break;
			}
		}
		if(isNotVerified) continue;
		searchAwaitingBlocks.splice(i, 1);
		i--;
		res(tiles);
	}
});
var searchAwaitingBlocks = [];
function searchGetBlock(x1, y1, x2, y2) {
	return new Promise(function(res) {
		network.fetch([{
			minX: x1, minY: y1,
			maxX: x2, maxY: y2
		}]);
		searchAwaitingBlocks.push([x1, y1, x2, y2, res]);
	});
}
function searchWait(ms) {
	return new Promise(function(res) {
		setTimeout(res, ms);
	});
}
function searchText(rows, text, startX) {
	var results = []; // [tileX, tileY, charX, charY]
	for(var r in rows) {
		var trow = rows[r];
		var tileY = parseInt(r);
		for(var y = 0; y < 8; y++) {
			var row = trow[y];
			var currentIndex = 0;
			while(true) {
				var lookup = row.indexOf(text, currentIndex);
				if(lookup == -1) break;
				currentIndex = lookup + text.length;
				results.push([
					startX + Math.floor(lookup / 16), tileY,
					lookup % 16, y
				]);
			}
		}
	}
	return results;
}
function searchHighlightResult(tileX, tileY, charX, charY, length) {
	var coords = [];
	var tilesLoaded = true;
	for(var i = 0; i < length; i++) {
		coords.push([tileX, tileY, charX, charY]);
		if(!Tile.loaded(tileX, tileY)) {
			tilesLoaded = false;
		}
		charX++;
		if(charX >= 16) {
			charX = 0;
			tileX++;
		}
	}
	if(!tilesLoaded) {
		var loadTimeout;
		var loadInterval = setInterval(function() {
			var loaded = true;
			for(var i = 0; i < coords.length; i++) {
				if(!Tile.loaded(coords[i][0], coords[i][1])) {
					loaded = false;
				}
			}
			if(loaded) {
				clearInterval(loadInterval);
				clearTimeout(loadTimeout);
				highlight(coords, true);
			}
		}, 1000 / 4);
		loadTimeout = setTimeout(function() {
			clearInterval(loadInterval);
		}, 5000);
	} else {
		highlight(coords, true);
	}
}
function searchTeleportTo(tileX, tileY, charX, charY, length) {
	var posX = tileX * 16 + charX + Math.floor(length / 2);
	var posY = tileY * 8 + charY;
	w.doGoToCoord(-(posY / (8 * 4)), posX / (16 * 4));
	searchHighlightResult(tileX, tileY, charX, charY, length);
}
async function searchLookup(conf, progress_cb) {
	var text = conf.text;
	var pos = w.getCenterCoords();
	var tileX = Math.floor(pos[1]);
	var tileY = Math.floor(pos[0]);
	var blockSize = 20;
	var startX = tileX - 25;
	var startY = tileY - 25;
	var endX = tileX + 25;
	var endY = tileY + 25;
	var areaWidth = endX - startX + 1;
	var areaHeight = endY - startY + 1;
	var areaSegWidth = Math.ceil(areaWidth / blockSize);
	var areaSegHeight = Math.ceil(areaHeight / blockSize);
	var areaSegTotal = areaSegWidth * areaSegHeight;
	var lastReq = 0;
	var reqCount = 0;
	var searchData = [];
	for(var y = 0; y < areaSegHeight; y++) {
		var rows = {};
		for(var x = 0; x < areaSegWidth; x++) {
			var x1 = startX + (x * blockSize);
			var y1 = startY + (y * blockSize);
			var x2 = x1 + blockSize - 1;
			var y2 = y1 + blockSize - 1;
			if(x2 > endX) x2 = endX;
			if(y2 > endY) y2 = endY;
			var time = Date.now();
			var timeDiff = time - lastReq;
			if(timeDiff >= 0 && timeDiff < 600) {
				await searchWait(600 - timeDiff);
			}
			var tiles = await searchGetBlock(x1, y1, x2, y2);
			lastReq = Date.now();
			reqCount++;
			if(typeof progress_cb == "function") {
				progress_cb(reqCount / areaSegTotal);
			}
			for(var ty = y1; ty <= y2; ty++) {
				if(!rows[ty]) {
					rows[ty] = ["", "", "", "", "", "", "", ""];
				}
				var row = rows[ty];
				for(var tx = x1; tx <= x2; tx++) {
					var cont = tiles[ty + "," + tx];
					if(!cont) {
						for(var by = 0; by < 8; by++) {
							row[by] += " ".repeat(16);
						}
						continue;
					}
					if(!conf.norm) {
						cont = w.split(cont.content);
					} else {
						cont = w.split(cont.content, false, false, true);
					}
					for(var cx = 0; cx < 128; cx++) {
						var rowNum = Math.floor(cx / 16);
						row[rowNum] += cont[cx].toLowerCase();
					}
				}	
			}
		}
		var search = searchText(rows, text, startX);
		for(var i = 0; i < search.length; i++) {
			searchData.push(search[i]);
		}
	}
	return searchData;
}
		</script>
		<script>
var atcInfo = document.createElement("label");
atcInfo.style.display = "none";
atcInfo.innerText = "Press CTRL and move your mouse around to clear tiles. " + 
	"This will clear all tiles where the mouse cursor is located.";
atcInfo.style.backgroundColor = "black";
atcInfo.style.color = "white";
atcInfo.style.position = "absolute";
atcInfo.style.left = "0px";
atcInfo.style.top = "0px";
document.body.appendChild(atcInfo);

var admclrActivated = document.createElement("label");
admclrActivated.innerText = " [ ACTIVE ]";
admclrActivated.style.backgroundColor = "black";
admclrActivated.style.color = "red";
admclrActivated.style.fontWeight = "bold";
admclrActivated.style.display = "none";
atcInfo.appendChild(admclrActivated);

menu.addCheckboxOption("Clear Tiles", function() {
	// activated
	atcInfo.style.display = "";
	admclr.activated = true;
}, function() {
	// deactivated
	atcInfo.style.display = "none";
	admclr.activated = false;
	tiles[currentPosition[1] + "," + currentPosition[0]].backgroundColor = "";
	w.setTileRedraw(currentPosition[0], currentPosition[1]);
});

var admclr = {
	activated: false,
	lastPos: null,
	ctrlDown: false,
	color: "#00FF00",
	renderTile: function(preserveLastPos) {
		if(tiles[currentPosition[1] + "," + currentPosition[0]]) {
			// change color to red
			tiles[currentPosition[1] + "," + currentPosition[0]].backgroundColor = admclr.color;
			if(!preserveLastPos)
				admclr.lastPos = [currentPosition[0], currentPosition[1]];
			// re-render the tile
			w.setTileRender(currentPosition[0], currentPosition[1]);
		}
	},
	handleClear: function(x, y) {
		network.clear_tile(x, y);
	}
};

// ctrl is pressed
function keydown_admclr(e) {
	if(!admclr.activated) return;
	if(admclr.ctrlDown) return;
	if(e.ctrlKey) {
		admclr.ctrlDown = true;
		admclrActivated.style.display = "";
		admclr.color = "#FF0000";
		admclr.renderTile(true);
		admclr.handleClear(currentPosition[0], currentPosition[1]);
	}
}
document.body.addEventListener("keydown", keydown_admclr);

// mouse is moved
function mousemove_admclr(e) {
	if(!admclr.activated) return;
	if(admclr.lastPos) {
		/*
			currentPosition is the built in way to get the current tile and char position from
			where your mouse cursor is.
			currentPosition = [tileX, tileY, charX, charY]
		*/
		// do no re-render if the cursor moved but is still inside the same tile
		if(admclr.lastPos[0] == currentPosition[0] && admclr.lastPos[1] == currentPosition[1]) {
			return;
		}
		var tileBackColorRes = tiles[admclr.lastPos[1] + "," + admclr.lastPos[0]];
		if(tileBackColorRes) tileBackColorRes.backgroundColor = "";
		// re-render the tile
		w.setTileRender(admclr.lastPos[0], admclr.lastPos[1]);
	}
	// if tile exists
	admclr.renderTile();
	if(admclr.ctrlDown) {
		admclr.handleClear(currentPosition[0], currentPosition[1]);
	}
}
document.body.addEventListener("mousemove", mousemove_admclr);

// a key is released
function keyup_admclr(e) {
	if(!admclr.activated) return;
	admclr.ctrlDown = false;
	admclrActivated.style.display = "none";
	admclr.color = "#00FF00";
	// remove color of tile
	if(admclr.lastPos) {
		tiles[admclr.lastPos[1] + "," + admclr.lastPos[0]].backgroundColor = "";
		// re-render the tile
		w.setTileRender(admclr.lastPos[0], admclr.lastPos[1]);
	}
	tiles[currentPosition[1] + "," + currentPosition[0]].backgroundColor = "";
	w.setTileRender(currentPosition[0], currentPosition[1]);
	admclr.lastPos = null;
}
document.body.addEventListener("keyup", keyup_admclr);

function enableServerPasting() {
	clearInterval(char_input_check);
	char_input_check = setInterval(function() {
		if(write_busy) return;
		var value = textInput.value;
		if(value == "") return;
		value = value.replace(/\r\n/g, "\n");
		value = value.replace(/\r/g, "\n");
		value = w.split(value);
		w.socket.send(JSON.stringify({
			kind: "paste",
			tileX: cursorCoords[0],
			tileY: cursorCoords[1],
			charX: cursorCoords[2],
			charY: cursorCoords[3],
			data: textInput.value
		}));
		textInput.value = "";
	}, 10);
}

client_commands.search = function(args) {
	var phrase = args.join(" ");
	if(!phrase) return;
	clientChatResponse("Looking for phrase: \"" + phrase + "\"");
	function doSearch() {
		searchLookup({
			text: phrase
		}, function(val) {
			val = (val * 100).toFixed(2);
			clientChatResponse("Searching... (" + val + "%)");
		}).then(function(coords) {
			var data = "Results:<br>";
			for(var i = 0; i < coords.length; i++) {
				var pos = coords[i];
				var scr = "javascript:searchTeleportTo(" + pos[0] + ", " + pos[1] + ", " + pos[2] + ", " + pos[3] + ", " + phrase.length + ")";
				var sty = "text-decoration: underline; color: blue;";
				data += "<a href=\"" + scr + "\" style=\"" + sty + "\">(" + pos[0] + ", " + pos[1] + ") [" + pos[2] + ", " + pos[3] + "]</a><br>";
			}
			addChat(null, 0, "user", "[ Client ]", data, "Client", true, false, false, null, getDate());
		});
	}
	// (MOD)
	doSearch();
}
		</script>
                <script>
        var atlInfo = document.createElement("label");
atlInfo.style.display = "none";
atlInfo.innerText = "Press CTRL and move your mouse around to lock tiles. " + 
    "This will lock all tiles where the mouse cursor is located.";
atlInfo.style.backgroundColor = "black";
atlInfo.style.color = "white";
atlInfo.style.position = "absolute";
atlInfo.style.left = "0px";
atlInfo.style.top = "0px";
document.body.appendChild(atlInfo);

var admlckActivated = document.createElement("label");
admlckActivated.innerText = " [ ACTIVE ]";
admlckActivated.style.backgroundColor = "black";
admlckActivated.style.color = "red";
admlckActivated.style.fontWeight = "bold";
admlckActivated.style.display = "none";
atlInfo.appendChild(admclrActivated);

menu.addCheckboxOption(" Lock Tiles", () => {
    // activated
    atlInfo.style.display = "";
    admlck.activated = true;
}, function() {
    // deactivated
    atlInfo.style.display = "none";
    admlck.activated = false;
    tiles[currentPosition[1] + "," + currentPosition[0]].backgroundColor = "";
    renderTile(currentPosition[0], currentPosition[1], true);
});

var admlck = {
    activated: false,
    lastPos: null,
    ctrlDown: false,
    color: "#00FFFF",
    renderTile: function(preserveLastPos) {
        if(tiles[currentPosition[1] + "," + currentPosition[0]]) {
            // change color to red
            tiles[currentPosition[1] + "," + currentPosition[0]].backgroundColor = admlck.color;
            if(!preserveLastPos)
                admlck.lastPos = [currentPosition[0], currentPosition[1]];
            // re-render the tile
            renderTile(currentPosition[0], currentPosition[1], true);
        }
    },
    handleLock: (x, y) => {
        network.lock_tile(x, y);
    }
};

// ctrl is pressed
function keydown_admlck(e) {
    if(!admlck.activated) return;
    if(admlck.ctrlDown) return;
    if(e.ctrlKey) {
        admlck.ctrlDown = true;
        admlckActivated.style.display = "";
        admlck.color = "#FF0000";
        admlck.renderTile(true);
        admlck.handleLock(currentPosition[0], currentPosition[1]);
    }
}
document.body.addEventListener("keydown", keydown_admlck);

// mouse is moved
function mousemove_admlck(e) {
    if(!admlck.activated) return;
    if(admlck.lastPos) {
        /*
            currentPosition is the built in way to get the current tile and char position from
            where your mouse cursor is.
            currentPosition = [tileX, tileY, charX, charY]
        */
        // do no re-render if the cursor moved but is still inside the same tile
        if(admlck.lastPos[0] == currentPosition[0] && admlck.lastPos[1] == currentPosition[1]) {
            return;
        }
        var tileBackColorRes = tiles[admlck.lastPos[1] + "," + admlck.lastPos[0]];
        if(tileBackColorRes) tileBackColorRes.backgroundColor = "";
        // re-render the tile
        renderTile(admlck.lastPos[0], admlck.lastPos[1], true);
    }
    // if tile exists
    admlck.renderTile();
    if(admlck.ctrlDown) {
        admlck.handleLock(currentPosition[0], currentPosition[1]);
    }
}
document.body.addEventListener("mousemove", mousemove_admlck)

// a key is released
function keyup_admlck(e) {
    if(!admlck.activated) return;
    admlck.ctrlDown = false;
    admlckActivated.style.display = "none";
    admlck.color = "#00FF00";
    // remove color of tile
    if(admlck.lastPos) {
        tiles[admlck.lastPos[1] + "," + admlck.lastPos[0]].backgroundColor = "";
        // re-render the tile
        renderTile(admlck.lastPos[0], admlck.lastPos[1], true);
    }
    tiles[currentPosition[1] + "," + currentPosition[0]].backgroundColor = "";
    renderTile(currentPosition[0], currentPosition[1], true);
    admlck.lastPos = null;
}
document.body.addEventListener("keyup", keyup_admlck);
        </script>
		<script>
// (EXT)
function exportWorld() {
	var filename = "export" + Date.now() + ".json"
	var down = document.createElement("a");
	down.setAttribute("href", "data:text/plain;charset=utf-8," + encodeURIComponent(JSON.stringify(tile_database)));
	down.setAttribute("download", filename);
	if (document.createEvent && "download" in down && !window.navigator.msSaveBlob) {
		var event = document.createEvent("MouseEvents");
		event.initEvent("click", true, true);
		down.dispatchEvent(event);
	} else if("download" in down && !window.navigator.msSaveBlob) {
		down.click();
	} else if(window.navigator.msSaveBlob) {
		window.navigator.msSaveBlob(new Blob([JSON.stringify(tile_database)], {type: "octet/stream"}), filename);
	}
}
		</script>
		<script>
// (EXT)
import_world.onchange = function(e) {
	var files = import_world.files;
	for(var i = 0; i < files.length; i++) {
		var file = files[i];
		var fr = new FileReader();
		fr.onload = function(res) {
			var data = JSON.parse(res.target.result);
			if(Array.isArray(data)) { // world-download export
				for(var t = 0; t < data.length; t++) {
					var tile = data[t];
					var content = tile.content;
					var tileX = tile.tileX;
					var tileY = tile.tileY;
					var properties = tile.properties;
					var writability = tile.writability;
					properties = JSON.parse(properties);
					properties.writability = writability;
					tile_database[tileY + "," + tileX] = {
						content: content,
						properties: properties
					};
				}
			} else { // offlineOWOT export
				for(var tile in data) {
					tile_database[tile] = data[tile];
				}
			}
			clearTiles(true);
			w.fetchUpdates();
		}
		fr.readAsText(file);
	}
}
		</script>
	</body>
</html>